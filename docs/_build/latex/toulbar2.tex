%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{toulbar2 Documentation}
\date{Nov 30, 2022}
\release{1.0.0}
\author{INRAE}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index_pdf::doc}}
\sphinxstepscope
\phantomsection\label{\detokenize{presentation:presentation}}





\chapter{About toulbar2}
\label{\detokenize{presentation:about-toulbar2}}\label{\detokenize{presentation:id2}}
\sphinxAtStartPar
\sphinxstylestrong{toulbar2} is an open\sphinxhyphen{}source C++ solver for cost function networks. It solves various combinatorial optimization problems.

\sphinxAtStartPar
The constraints and objective function are factorized in local functions on discrete variables. Each function returns a cost (a finite positive integer) for any assignment of its variables. Constraints are represented as functions with costs in \{0, \(\infty\)\} where \(\infty\) is a large integer representing forbidden assignments. toulbar2 looks for a non\sphinxhyphen{}forbidden assignment of all variables that minimizes the sum of all functions.

\sphinxAtStartPar
Its engine uses a hybrid best\sphinxhyphen{}first branch\sphinxhyphen{}and\sphinxhyphen{}bound algorithm exploiting soft arc consistencies. It incorporates a parallel variable neighborhood search method for better performances. See {\hyperref[\detokenize{publications:publications}]{\sphinxcrossref{\DUrole{std,std-ref}{Publications}}}}.

\sphinxAtStartPar
toulbar2 won several medals in competitions on Max\sphinxhyphen{}CSP/COP (\sphinxhref{http://www.cril.univ-artois.fr/CPAI08/}{CPAI08}, \sphinxhref{https://xcsp.org/competitions/}{2022 XCSP3}) and probabilistic graphical models (UAI \sphinxhref{https://www.ics.uci.edu/~dechter/softwares/benchmarks/UAI08/uai08-evaluation-2008-09-15.pdf}{2008}, \sphinxhref{http://www.cs.huji.ac.il/project/UAI10/summary.php}{2010}, \sphinxhref{http://auai.org/uai2014/competition.shtml}{2014} MAP task).

\sphinxAtStartPar
toulbar2 is now also able to collaborate with ML code that can learn an additive graphical model (with constraints) from data (see example at \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cfn-learn}{cfn\sphinxhyphen{}learn}).


\chapter{Authors}
\label{\detokenize{presentation:authors}}\label{\detokenize{presentation:id6}}
\sphinxAtStartPar
\sphinxstylestrong{toulbar2} was originally developped by Toulouse (INRAE MIAT) and Barcelona (UPC, IIIA\sphinxhyphen{}CSIC) teams, hence the name of the solver.

\sphinxAtStartPar
Additional contributions by:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Caen University, France (GREYC) and University of Oran, Algeria for (parallel) variable neighborhood search methods

\item {} 
\sphinxAtStartPar
The Chinese University of Hong Kong and Caen University, France (GREYC) for global cost functions

\item {} 
\sphinxAtStartPar
Marseille University, France (LSIS) for tree decomposition heuristics

\item {} 
\sphinxAtStartPar
Ecole des Ponts ParisTech, France (CERMICS/LIGM for \sphinxhref{http://imagine.enpc.fr/~neveub/incop/incoppresentation.html}{INCOP} local search solver

\item {} 
\sphinxAtStartPar
University College Cork, Ireland (Insight) for a Python interface in \sphinxhref{https://github.com/eomahony/Numberjack}{Numberjack}  and a portfolio dedicated to UAI graphical models \sphinxhref{https://github.com/9thbit/uai-proteus}{Proteus}

\item {} 
\sphinxAtStartPar
Artois University, France (CRIL) for an XCSP 2.1 format reader of CSP and WCSP instances

\item {} 
\sphinxAtStartPar
Université de Toulouse I Capitole (IRIT) and Université du Littoral Côte d’Opale, France (LISIC) for PILS local search solver

\end{itemize}


\chapter{Citations}
\label{\detokenize{presentation:citations}}\label{\detokenize{presentation:id7}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Hurley16b.pdf}{Multi\sphinxhyphen{}Language Evaluation of Exact Solvers in Graphical Model Discrete Optimization}

\sphinxAtStartPar
Barry Hurley, Barry O’Sullivan, David Allouche, George Katsirelos, Thomas Schiex, Matthias Zytnicki, Simon de Givry

\sphinxAtStartPar
Constraints, 21(3):413\sphinxhyphen{}434, 2016

\item {} 
\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Schiex16a.pdf}{Tractability\sphinxhyphen{}preserving Transformations of Global Cost Functions}

\sphinxAtStartPar
David Allouche, Christian Bessiere, Patrice Boizumault, Simon de Givry, Patricia Gutierrez, Jimmy HM. Lee, Ka Lun Leung, Samir Loudni, Jean\sphinxhyphen{}Philippe Métivier, Thomas Schiex, Yi Wu

\sphinxAtStartPar
Artificial Intelligence, 238:166\sphinxhyphen{}189, 2016

\item {} 
\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Cooper10a.pdf}{Soft arc consistency revisited}

\sphinxAtStartPar
Martin Cooper, Simon de Givry, Marti Sanchez, Thomas Schiex, Matthias Zytnicki, and Thomas Werner

\sphinxAtStartPar
Artificial Intelligence, 174(7\sphinxhyphen{}8):449\sphinxhyphen{}478, 2010

\end{itemize}


\chapter{Acknowledgements}
\label{\detokenize{presentation:acknowledgements}}\label{\detokenize{presentation:id8}}
\sphinxAtStartPar
\sphinxstylestrong{toulbar2} has been partly funded by the French \sphinxstyleemphasis{Agence Nationale de la Recherche} (projects STAL\sphinxhyphen{}DEC\sphinxhyphen{}OPT from 2006 to 2008, ANR\sphinxhyphen{}10\sphinxhyphen{}BLA\sphinxhyphen{}0214 \sphinxhref{http://costfunction.org}{Ficolofo} from 2011 to 2014, and ANR\sphinxhyphen{}16\sphinxhyphen{}CE40\sphinxhyphen{}0028 \sphinxhref{https://anr.fr/Projet-ANR-16-CE40-0028}{DemoGraph} from 2017 to 2021) and a PHC PROCORE project number 28680VH (from 2013 to 2015). It is currently supported by ANITI ANR\sphinxhyphen{}19\sphinxhyphen{}P3IA\sphinxhyphen{}0004 (2019\sphinxhyphen{}).


\chapter{License}
\label{\detokenize{presentation:license}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MIT} \PYG{n}{License}

\PYG{n}{Copyright} \PYG{p}{(}\PYG{n}{c}\PYG{p}{)} \PYG{l+m+mi}{2022} \PYG{n}{toulbar2} \PYG{n}{team}

\PYG{n}{Permission} \PYG{o+ow}{is} \PYG{n}{hereby} \PYG{n}{granted}\PYG{p}{,} \PYG{n}{free} \PYG{n}{of} \PYG{n}{charge}\PYG{p}{,} \PYG{n}{to} \PYG{n+nb}{any} \PYG{n}{person} \PYG{n}{obtaining} \PYG{n}{a} \PYG{n}{copy}
\PYG{n}{of} \PYG{n}{this} \PYG{n}{software} \PYG{o+ow}{and} \PYG{n}{associated} \PYG{n}{documentation} \PYG{n}{files} \PYG{p}{(}\PYG{n}{the} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Software}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{to} \PYG{n}{deal}
\PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{Software} \PYG{n}{without} \PYG{n}{restriction}\PYG{p}{,} \PYG{n}{including} \PYG{n}{without} \PYG{n}{limitation} \PYG{n}{the} \PYG{n}{rights}
\PYG{n}{to} \PYG{n}{use}\PYG{p}{,} \PYG{n}{copy}\PYG{p}{,} \PYG{n}{modify}\PYG{p}{,} \PYG{n}{merge}\PYG{p}{,} \PYG{n}{publish}\PYG{p}{,} \PYG{n}{distribute}\PYG{p}{,} \PYG{n}{sublicense}\PYG{p}{,} \PYG{o+ow}{and}\PYG{o}{/}\PYG{o+ow}{or} \PYG{n}{sell}
\PYG{n}{copies} \PYG{n}{of} \PYG{n}{the} \PYG{n}{Software}\PYG{p}{,} \PYG{o+ow}{and} \PYG{n}{to} \PYG{n}{permit} \PYG{n}{persons} \PYG{n}{to} \PYG{n}{whom} \PYG{n}{the} \PYG{n}{Software} \PYG{o+ow}{is}
\PYG{n}{furnished} \PYG{n}{to} \PYG{n}{do} \PYG{n}{so}\PYG{p}{,} \PYG{n}{subject} \PYG{n}{to} \PYG{n}{the} \PYG{n}{following} \PYG{n}{conditions}\PYG{p}{:}

\PYG{n}{The} \PYG{n}{above} \PYG{n}{copyright} \PYG{n}{notice} \PYG{o+ow}{and} \PYG{n}{this} \PYG{n}{permission} \PYG{n}{notice} \PYG{n}{shall} \PYG{n}{be} \PYG{n}{included} \PYG{o+ow}{in} \PYG{n+nb}{all}
\PYG{n}{copies} \PYG{o+ow}{or} \PYG{n}{substantial} \PYG{n}{portions} \PYG{n}{of} \PYG{n}{the} \PYG{n}{Software}\PYG{o}{.}

\PYG{n}{THE} \PYG{n}{SOFTWARE} \PYG{n}{IS} \PYG{n}{PROVIDED} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AS IS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{WITHOUT} \PYG{n}{WARRANTY} \PYG{n}{OF} \PYG{n}{ANY} \PYG{n}{KIND}\PYG{p}{,} \PYG{n}{EXPRESS} \PYG{n}{OR}
\PYG{n}{IMPLIED}\PYG{p}{,} \PYG{n}{INCLUDING} \PYG{n}{BUT} \PYG{n}{NOT} \PYG{n}{LIMITED} \PYG{n}{TO} \PYG{n}{THE} \PYG{n}{WARRANTIES} \PYG{n}{OF} \PYG{n}{MERCHANTABILITY}\PYG{p}{,}
\PYG{n}{FITNESS} \PYG{n}{FOR} \PYG{n}{A} \PYG{n}{PARTICULAR} \PYG{n}{PURPOSE} \PYG{n}{AND} \PYG{n}{NONINFRINGEMENT}\PYG{o}{.} \PYG{n}{IN} \PYG{n}{NO} \PYG{n}{EVENT} \PYG{n}{SHALL} \PYG{n}{THE}
\PYG{n}{AUTHORS} \PYG{n}{OR} \PYG{n}{COPYRIGHT} \PYG{n}{HOLDERS} \PYG{n}{BE} \PYG{n}{LIABLE} \PYG{n}{FOR} \PYG{n}{ANY} \PYG{n}{CLAIM}\PYG{p}{,} \PYG{n}{DAMAGES} \PYG{n}{OR} \PYG{n}{OTHER}
\PYG{n}{LIABILITY}\PYG{p}{,} \PYG{n}{WHETHER} \PYG{n}{IN} \PYG{n}{AN} \PYG{n}{ACTION} \PYG{n}{OF} \PYG{n}{CONTRACT}\PYG{p}{,} \PYG{n}{TORT} \PYG{n}{OR} \PYG{n}{OTHERWISE}\PYG{p}{,} \PYG{n}{ARISING} \PYG{n}{FROM}\PYG{p}{,}
\PYG{n}{OUT} \PYG{n}{OF} \PYG{n}{OR} \PYG{n}{IN} \PYG{n}{CONNECTION} \PYG{n}{WITH} \PYG{n}{THE} \PYG{n}{SOFTWARE} \PYG{n}{OR} \PYG{n}{THE} \PYG{n}{USE} \PYG{n}{OR} \PYG{n}{OTHER} \PYG{n}{DEALINGS} \PYG{n}{IN} \PYG{n}{THE}
\PYG{n}{SOFTWARE}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{Downloads}
\label{\detokenize{downloads:downloads}}\label{\detokenize{downloads:id1}}\label{\detokenize{downloads::doc}}

\section{Open\sphinxhyphen{}source code}
\label{\detokenize{downloads:open-source-code}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/toulbar2}{toulbar2 on GitHub}
\sphinxhref{https://github.com/toulbar2/toulbar2}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}

\end{itemize}


\section{Packages}
\label{\detokenize{downloads:packages}}\begin{itemize}
\item {} 
\sphinxAtStartPar
to install \sphinxstylestrong{toulbar2} using the package manager in Debian and Debian derived Linux distributions (Ubuntu, Mint,…):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{apt} \PYG{n}{install} \PYG{n}{toulbar2}
\end{sphinxVerbatim}

\end{itemize}


\section{Binaries}
\label{\detokenize{downloads:binaries}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Latest release toulbar2 binaries}

\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/toulbar2/releases/download/v1.1.1/toulbar2}{Linux 64bit} |
\sphinxhref{https://github.com/toulbar2/toulbar2/releases/download/v1.1.1/toulbar2mac}{MacOs 64bit} |
\sphinxhref{https://github.com/toulbar2/toulbar2/releases/download/v1.1.1/toulbar2.exe}{Windows 64bit}

\end{itemize}


\section{Python package}
\label{\detokenize{downloads:python-package}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pytoulbar2} module for Linux and MacOS on \sphinxhref{https://pypi.org/project/pytoulbar2}{PyPI}

\end{itemize}


\section{Docker images}
\label{\detokenize{downloads:docker-images}}\begin{itemize}
\item {} 
\sphinxAtStartPar
In \sphinxhref{https://github.com/toulbar2?tab=packages\&repo\_name=toulbar2}{Toulbar2 Packages} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{toulbar2} :
Docker image containing toulbar2 and its pytoulbar2 Python API
\sphinxstyleemphasis{(installed from sources with cmake options \sphinxhyphen{}DPYTB2=ON and \sphinxhyphen{}DXML=ON)}.
Install from the command line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{pull} \PYG{n}{ghcr}\PYG{o}{.}\PYG{n}{io}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{p}{:}\PYG{n}{master}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{pytoulbar2} :
Docker image containing pytoulbar2 the Python API of toulbar2
\sphinxstyleemphasis{(installed with python3 \sphinxhyphen{}m pip install pytoulbar2)}.
Install from the command line:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{docker} \PYG{n}{pull} \PYG{n}{ghcr}\PYG{o}{.}\PYG{n}{io}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{/}\PYG{n}{pytoulbar2}\PYG{p}{:}\PYG{n}{master}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxstepscope


\chapter{Benchmark libraries}
\label{\detokenize{benchmarks:benchmark-libraries}}\label{\detokenize{benchmarks:benchmarks}}\label{\detokenize{benchmarks::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://genoweb.toulouse.inra.fr/~degivry/evalgm}{EvalGM} : 3026 discrete optimization benchmarks available in various formats (wcsp, wcnf, uai, lp, mzn). {[}Hurley et al CPAIOR 2016{]}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library}{Cost Function Library} : an on\sphinxhyphen{}going collection of benchmarks from various domains of Artificial Intelligence, Constraint Programming, and Operations Research (formats in wcsp, wcnf, lp, qpbo, uai, opd, and more).

\end{itemize}

\sphinxstepscope


\chapter{Tutorials}
\label{\detokenize{examples/tutorials:tutorials}}\label{\detokenize{examples/tutorials:id1}}\label{\detokenize{examples/tutorials::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
tutorial \sphinxhref{https://forgemia.inra.fr/thomas.schiex/acpaior20}{materials} on
cost function networks at \sphinxhref{https://acp-iaro-school.sciencesconf.org}{ACP/ANITI/GDR\sphinxhyphen{}IA/RO Autumn School 2020}.

\item {} 
\sphinxAtStartPar
tutorial on cost function networks at CP2020 (\sphinxhref{https://www.youtube.com/watch?v=g8lgoR4XufU}{teaser}, \sphinxhref{https://www.youtube.com/watch?v=HHsqdVSJL8g}{part1}, \sphinxhref{https://youtu.be/BYhhyiPFPGw}{part2} videos, and \sphinxhref{https://github.com/toulbar2/toulbar2/blob/master/web/TUTORIALS/tutorialCP2020.md}{script}

\item {} 
\sphinxAtStartPar
tutorial on cost function networks at PFIA 2019 (\sphinxhref{http://miat.inrae.fr/degivry/talkPFIA2019part1.pdf}{part1}, \sphinxhref{http://miat.inrae.fr/degivry/talkPFIA2019part2.pdf}{part2}, \sphinxhref{https://miat.inrae.fr/degivry/talkPFIA2019demo.pdf}{demo}), Toulouse, France, July 4th, 2019.

\end{itemize}

\sphinxAtStartPar
Here are several examples that can be followed as tutorials.
They use toulbar2 in order to resolve different problems.
According to cases, they may contain source code, tutorials explaining the examples, possibility to run yourself…

\sphinxAtStartPar
You will find the mentioned examples, among the following exhaustive
list of examples.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_wnqp:tuto-wnqp}]{\sphinxcrossref{\DUrole{std,std-ref}{Weighted n\sphinxhyphen{}queen problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_wlsp:tuto-wlsp}]{\sphinxcrossref{\DUrole{std,std-ref}{Weighted latin square problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_rlfap:tuto-rlfap}]{\sphinxcrossref{\DUrole{std,std-ref}{Radio link frequency assignment problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_fapwp:tuto-fapwp}]{\sphinxcrossref{\DUrole{std,std-ref}{Frequency assignment problem with polarization}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_medp:tuto-medp}]{\sphinxcrossref{\DUrole{std,std-ref}{Mendelian error detection problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_bmp:tuto-bmp}]{\sphinxcrossref{\DUrole{std,std-ref}{Block modeling problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_alp:tuto-alp}]{\sphinxcrossref{\DUrole{std,std-ref}{Airplane landing problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_wlp:tuto-wlp}]{\sphinxcrossref{\DUrole{std,std-ref}{Warehouse location problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_spp:tuto-spp}]{\sphinxcrossref{\DUrole{std,std-ref}{Square packing problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_sspp:tuto-sspp}]{\sphinxcrossref{\DUrole{std,std-ref}{Square soft packing problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_grp:tuto-grp}]{\sphinxcrossref{\DUrole{std,std-ref}{Golomb ruler problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/tuto_bcp:tuto-bcp}]{\sphinxcrossref{\DUrole{std,std-ref}{Board coloration problem}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/ltps:ltps}]{\sphinxcrossref{\DUrole{std,std-ref}{Learning to play the Sudoku}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/rccs:rccs}]{\sphinxcrossref{\DUrole{std,std-ref}{Learning car configuration preferences}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/vstut:vs-tut}]{\sphinxcrossref{\DUrole{std,std-ref}{Visual Sudoku Tutorial}}}} \sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-colab}.png}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/snum:snum}]{\sphinxcrossref{\DUrole{std,std-ref}{Verbose version of a sudoku code}}}}

\end{itemize}

\sphinxstepscope


\chapter{Use cases}
\label{\detokenize{examples/usecases:use-cases}}\label{\detokenize{examples/usecases:usecases}}\label{\detokenize{examples/usecases::doc}}
\sphinxAtStartPar
Here are several toulbar2 use cases, where toulbar2 has been used in order to
resolve different problems.
According to cases, they can be used to overview, learn, use toulbar2…
They may contain source code, explanations, possibility to run yourself…

\sphinxAtStartPar
You will find the mentioned examples, among the following exhaustive
list of examples.

\sphinxAtStartPar
\sphinxstylestrong{toulbar2 and Deep Learning} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/vstut:vs-tut}]{\sphinxcrossref{\DUrole{std,std-ref}{Visual Sudoku Tutorial}}}} \sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-colab}.png}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/vsapp:vs-app}]{\sphinxcrossref{\DUrole{std,std-ref}{Visual Sudoku Application}}}} \sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-ws_ui-vsudoku}.png} \sphinxincludegraphics[width=20\sphinxpxdimen]{{logo-apk_visualsudokuapp}.png}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Some applications based on toulbar2} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mendelsoft} : \sphinxhref{https://miat.inrae.fr/MendelSoft}{Mendelsoft} detects
Mendelian errors in complex pedigree
{[}\sphinxhref{http://miat.inrae.fr/degivry/Sanchez07a.pdf}{Sanchez et al, Constraints 2008}{]}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pompd} : \sphinxhref{https://forgemia.inra.fr/thomas.schiex/pompd}{POsitive Multistate Protein Design},
{[}\sphinxhref{https://hal.inrae.fr/hal-02625007/file/main.pdf}{Vucini et al Bioinformatics 2020}{]}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/vsapp:vs-app}]{\sphinxcrossref{\DUrole{std,std-ref}{Visual Sudoku Application}}}} \sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-ws_ui-vsudoku}.png} \sphinxincludegraphics[width=20\sphinxpxdimen]{{logo-apk_visualsudokuapp}.png}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Misc} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{examples/snum:snum}]{\sphinxcrossref{\DUrole{std,std-ref}{A sudoku code}}}}

\end{itemize}

\sphinxstepscope


\chapter{List of all examples}
\label{\detokenize{examples/examples_toc:list-of-all-examples}}\label{\detokenize{examples/examples_toc:examples-toc}}\label{\detokenize{examples/examples_toc::doc}}
\sphinxstepscope


\section{Weighted n\sphinxhyphen{}queen problem}
\label{\detokenize{examples/tuto_wnqp:weighted-n-queen-problem}}\label{\detokenize{examples/tuto_wnqp:tuto-wnqp}}\label{\detokenize{examples/tuto_wnqp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_wnqp:brief-description}}
\sphinxAtStartPar
The problem consists in assigning N queens on a NxN chessboard with random costs in (1..N) associated to every cell such that each queen does not attack another queen and the sum of the costs of queen’s selected cells is minimized.


\subsection{CFN model}
\label{\detokenize{examples/tuto_wnqp:cfn-model}}
\sphinxAtStartPar
A solution must have only one queen per column and per row. We create N variables for every column with domain size N to represent the selected row for each queen. A clique of binary constraints is used to express that two queens cannot be on the same row. Forbidden assignments have cost k=N**2+1. Two other cliques of binary constraints are used to express that two queens do not attack each other on a lower/upper diagonal. We add N unary cost functions to create the objective function with random costs on every cell.


\subsection{Example for N=4 in JSON .cfn format}
\label{\detokenize{examples/tuto_wnqp:example-for-n-4-in-json-cfn-format}}
\sphinxAtStartPar
\sphinxstyleemphasis{More details :}

\noindent\sphinxincludegraphics[width=250\sphinxpxdimen]{{queen4_details}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
  \PYG{n}{problem}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{4\PYGZhy{}queen}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustbe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}17}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n}{variables}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
              \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Row3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n}{functions}\PYG{p}{:} \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}

    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}

    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{17}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}

    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Optimal solution with cost 11 for the 4\sphinxhyphen{}queen example :

\noindent\sphinxincludegraphics[height=250\sphinxpxdimen]{{queen4}.png}


\subsection{Python model}
\label{\detokenize{examples/tuto_wnqp:python-model}}
\sphinxAtStartPar
The following code using the pytoulbar2 library solves the weighted N\sphinxhyphen{}queen problem with the first argument being the number of queens N (e.g. “python3 weightedqueens.py 8”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{weightedqueens.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{randint}
\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456789}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{=} \PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{row}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{a}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	    	
		\PYG{c+c1}{\PYGZsh{}Two queens cannot be on the same row constraints}
		\PYG{n}{ListConstraintsRow} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
			\PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
				\PYG{k}{if} \PYG{n}{a} \PYG{o}{!=} \PYG{n}{b} \PYG{p}{:}
					\PYG{n}{ListConstraintsRow}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
				\PYG{k}{else}\PYG{p}{:}
				 	\PYG{n}{ListConstraintsRow}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsRow}\PYG{p}{)}
		
		\PYG{c+c1}{\PYGZsh{}Two queens cannot be on the same upper diagonal constraints}
		\PYG{n}{ListConstraintsUpperD} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
			\PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
				\PYG{k}{if} \PYG{n}{a} \PYG{o}{+} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{b} \PYG{o}{+} \PYG{n}{j} \PYG{p}{:}
					\PYG{n}{ListConstraintsUpperD}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
				\PYG{k}{else}\PYG{p}{:}
				 	\PYG{n}{ListConstraintsUpperD}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsUpperD}\PYG{p}{)}
		
		\PYG{c+c1}{\PYGZsh{}Two queens cannot be on the same lower diagonal constraints}
		\PYG{n}{ListConstraintsLowerD} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
			\PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
				\PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{b} \PYG{o}{\PYGZhy{}} \PYG{n}{j} \PYG{p}{:}
					\PYG{n}{ListConstraintsLowerD}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
				\PYG{k}{else}\PYG{p}{:}
				 	\PYG{n}{ListConstraintsLowerD}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsLowerD}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Random unary costs}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{ListConstraintsUnaryC} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{ListConstraintsUnaryC}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsUnaryC}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}WeightQueen.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{row} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{if} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{==}\PYG{n}{i} \PYG{k}{else} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}
		\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
	\PYG{c+c1}{\PYGZsh{} and its cost}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cost:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Weighted latin square problem}
\label{\detokenize{examples/tuto_wlsp:weighted-latin-square-problem}}\label{\detokenize{examples/tuto_wlsp:tuto-wlsp}}\label{\detokenize{examples/tuto_wlsp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_wlsp:brief-description}}
\sphinxAtStartPar
The problem consists in assigning a value from 0 to N\sphinxhyphen{}1 to every cell of a NxN chessboard.
Each row and each column must be a permutation of N values. For each cell, a random cost in (1…N) is associated to every domain value.
The objective is to find a complete assignment where the sum of the costs associated to the selected values for the cells is minimized.


\subsection{CFN model}
\label{\detokenize{examples/tuto_wlsp:cfn-model}}
\sphinxAtStartPar
We create NxN variables, one for every cell, with domain size N. An AllDifferent hard global constraint is used to model a permutation for every row and every column. Its encoding uses knapsack constraints.
Unary cost functions containing random costs associated to domain values are generated for every cell.
The worst possible solution is when every cell is associated with a cost of N, so the maximum cost of a solution is N**3, so forbidden assignments have cost k=N**3+1.


\subsection{Example for N=4 in JSON .cfn format}
\label{\detokenize{examples/tuto_wlsp:example-for-n-4-in-json-cfn-format}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}
  \PYG{n}{problem}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{LatinSquare4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustbe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}65}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n}{variables}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
  \PYG{n}{functions}\PYG{p}{:} \PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}

    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type:}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{salldiff}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{65}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}

    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X0\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X1\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X2\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X3\PYGZus{}3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{4}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
Optimal solution with cost 35 for the latin 4\sphinxhyphen{}square example (in red, costs associated to the selected values) :

\noindent\sphinxincludegraphics[height=250\sphinxpxdimen]{{latin4}.png}


\subsection{Python model}
\label{\detokenize{examples/tuto_wlsp:python-model}}
\sphinxAtStartPar
The following code using the pytoulbar2 library solves the weighted latin square problem with the first argument being the dimension N of the chessboard (e.g. “python3 latinsquare.py 6”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{latinsquare.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{seed}\PYG{p}{,} \PYG{n}{randint}
\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456789}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{=} \PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{3} \PYG{o}{+}\PYG{l+m+mi}{1}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}Create a variable for each square}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cell(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{}Create a constraint all different with variables on the same row}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddAllDifferent}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cell(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{encoding} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salldiffkp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{}Create a constraint all different with variables on the same column}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddAllDifferent}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cell(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{encoding} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{salldiffkp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Random unary costs}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ListConstraintsUnaryC} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{ListConstraintsUnaryC}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{randint}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Cell(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsUnaryC}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}WeightLatinSquare.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res} \PYG{o+ow}{and} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)} \PYG{o}{==} \PYG{n}{N}\PYG{o}{*}\PYG{n}{N}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} pretty print solution}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{[}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i} \PYG{o}{*} \PYG{n}{N} \PYG{o}{+} \PYG{n}{j}\PYG{p}{]} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} and its cost}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Cost:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Radio link frequency assignment problem}
\label{\detokenize{examples/tuto_rlfap:radio-link-frequency-assignment-problem}}\label{\detokenize{examples/tuto_rlfap:tuto-rlfap}}\label{\detokenize{examples/tuto_rlfap::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_rlfap:brief-description}}
\sphinxAtStartPar
The problem consists in assigning frequencies to radio communication links in such a way that no interferences occur. Domains are set of integers (non necessarily consecutives).

\sphinxAtStartPar
Two types of constraints occur:
\begin{itemize}
\item {} 
\sphinxAtStartPar
(I) the absolute difference between two frequencies should be greater than a given number d\_i ( | x \sphinxhyphen{} y | \textgreater{} d\_i )

\item {} 
\sphinxAtStartPar
(II) the absolute difference between two frequencies should exactly be equal to a given number d\_i ( | x \sphinxhyphen{} y | = d\_i ).

\end{itemize}

\sphinxAtStartPar
Different deviations d\_i, i in 0..4, may exist for the same pair of links. d\_0 corresponds to hard constraints while higher deviations are soft constraints that can be violated with an associated cost a\_i. Moreover, pre\sphinxhyphen{}assigned frequencies may be known for some links which are either hard or soft preferences (mobility cost b\_i, i in 0..4). The goal is to minimize the weighted sum of violated constraints.
\begin{description}
\sphinxlineitem{So the goal is to minimize the sum:}
\sphinxAtStartPar
a\_1*nc1+…+a\_4*nc4+b\_1*nv1+…+b\_4*nv4

\end{description}

\sphinxAtStartPar
where nci is the number of violated constraints with cost a\_i and nvi is the number of modified variables with mobility cost b\_i.

\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Schiex99.ps.gz}{Cabon, B., de Givry, S., Lobjois, L., Schiex, T.,  Warners, J.P. Constraints (1999) 4: 79}.


\subsection{CFN model}
\label{\detokenize{examples/tuto_rlfap:cfn-model}}
\sphinxAtStartPar
We create N variables for every radio link with a given integer domain. Hard and soft binary cost functions express interference constraints with possible deviations with cost equal to a\_i. Unary cost functions are used to model mobility costs with cost equal to b\_i. The initial upper bound is defined as 1 plus the total cost where all the soft constraints are maximally violated (costs a\_4/b\_4).


\subsection{Data}
\label{\detokenize{examples/tuto_rlfap:data}}
\sphinxAtStartPar
Original data files can be download from the cost function library \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/real/celar/data/FullRLFAP}{FullRLFAP}. Their format is described \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/real/celar/data/FullRLFAP/celar.blurb}{here}. You can try a small example CELAR6\sphinxhyphen{}SUB1 (\sphinxcode{\sphinxupquote{var.txt}}, \sphinxcode{\sphinxupquote{dom.txt}}, \sphinxcode{\sphinxupquote{ctr.txt}}, \sphinxcode{\sphinxupquote{cst.txt}}) with optimum value equal to 2669.


\subsection{Python model}
\label{\detokenize{examples/tuto_rlfap:python-model}}
\sphinxAtStartPar
The following code solves the corresponding cost function network using the pytoulbar2 library and needs 4 arguments: the variable file, the domain file, the constraints file and the cost file (e.g. “python3 rlfap.py var.txt dom.txt ctr.txt cst.txt”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{rlfap.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{k}{class} \PYG{n+nc}{Data}\PYG{p}{:}
	\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{var}\PYG{p}{,} \PYG{n}{dom}\PYG{p}{,} \PYG{n}{ctr}\PYG{p}{,} \PYG{n}{cst}\PYG{p}{)}\PYG{p}{:}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ctr} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cost} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nba} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbb} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top} \PYG{o}{=} \PYG{l+m+mi}{1}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{Domain} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}

		\PYG{n}{stream} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{var}\PYG{p}{)}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{stream}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{varnum}\PYG{p}{,} \PYG{n}{vardom}\PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{n}{mobility}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{Domain}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{varnum}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{vardom}\PYG{p}{)}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{varnum}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{vardom}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{value}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{mobility}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbb}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{mobility}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbb}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{mobility}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{varnum}\PYG{p}{,} \PYG{n}{vardom}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{]}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{Domain}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{varnum}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{vardom}\PYG{p}{)}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{varnum}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{vardom}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
		\PYG{n}{stream} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{stream}\PYG{p}{:}
			\PYG{n}{domain} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{domain}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{:}\PYG{p}{]}\PYG{p}{]}

		\PYG{n}{stream} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ctr}\PYG{p}{)}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{stream}\PYG{p}{:}
			\PYG{p}{(}\PYG{n}{var1}\PYG{p}{,} \PYG{n}{var2}\PYG{p}{,} \PYG{n}{dummy}\PYG{p}{,} \PYG{n}{operand}\PYG{p}{,} \PYG{n}{deviation}\PYG{p}{,} \PYG{n}{weight}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{]}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ctr}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{var1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{var2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{operand}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{deviation}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nba}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nba}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1}
			
		\PYG{n}{stream} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{cst}\PYG{p}{)}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{stream}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{aorbi}\PYG{p}{,} \PYG{n}{eq}\PYG{p}{,} \PYG{n}{cost}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
				\PYG{k}{if} \PYG{p}{(}\PYG{n}{eq} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{:}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{cost}\PYG{p}{[}\PYG{n}{aorbi}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{)}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{cost}\PYG{p}{)} \PYG{o}{*} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nba}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{aorbi}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbb}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{aorbi}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}

		            
\PYG{c+c1}{\PYGZsh{}collect data           }
\PYG{n}{data} \PYG{o}{=} \PYG{n}{Data}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{,} \PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{=} \PYG{n}{data}\PYG{o}{.}\PYG{n}{top}
\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each link}
\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{:}
	\PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
		\PYG{n}{domain}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{f}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{link}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n}{domain}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}binary hard and soft constraints}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{var1}\PYG{p}{,} \PYG{n}{var2}\PYG{p}{,} \PYG{n}{operand}\PYG{p}{,} \PYG{n}{deviation}\PYG{p}{,} \PYG{n}{weight}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ctr}\PYG{p}{:}
	\PYG{n}{ListConstraints} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n}{data}\PYG{o}{.}\PYG{n}{Domain}\PYG{p}{[}\PYG{n}{var1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
		\PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n}{data}\PYG{o}{.}\PYG{n}{Domain}\PYG{p}{[}\PYG{n}{var2}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
			\PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{operand}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{and} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{deviation}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{operand}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{=}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o+ow}{and} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{b}\PYG{p}{)} \PYG{o}{==} \PYG{n}{deviation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{cost}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{)}\PYG{p}{,}\PYG{n}{top}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{link}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{var1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{link}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{var2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraints}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}unary hard and soft constraints}
\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{:}
	\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{:} 
		\PYG{n}{ListConstraints} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{a} \PYG{o}{==} \PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{:}
				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{cost}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{n}{top}\PYG{p}{)}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{link}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraints}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}Rflap.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Best solution found with cost:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{in}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{GetNbNodes}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{search nodes.}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sorry, no solution found!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Frequency assignment problem with polarization}
\label{\detokenize{examples/tuto_fapwp:frequency-assignment-problem-with-polarization}}\label{\detokenize{examples/tuto_fapwp:tuto-fapwp}}\label{\detokenize{examples/tuto_fapwp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_fapwp:brief-description}}
\sphinxAtStartPar
The previously\sphinxhyphen{}described {\hyperref[\detokenize{examples/tuto_rlfap:tuto-rlfap}]{\sphinxcrossref{\DUrole{std,std-ref}{Radio link frequency assignment problem}}}} has been extended to take into account polarization constraints and user\sphinxhyphen{}defined relaxation of electromagnetic compatibility constraints. The problem is to assign a pair (frequency,polarization) to every radio communication link (also called a path). Frequencies are integer values taken in finite domains. Polarizations are in \{\sphinxhyphen{}1,1\}. Constraints are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
(I) two paths must use equal or different frequencies (\sphinxtitleref{f\_i=f\_j} or \sphinxtitleref{f\_i\textless{}\textgreater{}f\_j}),

\item {} 
\sphinxAtStartPar
(II) the absolute difference between two frequencies should exactly be equal or different to a given number e (\sphinxtitleref{|f\_i\sphinxhyphen{}f\_j|=e} or \sphinxtitleref{|f\_i\sphinxhyphen{}f\_j|\textless{}\textgreater{}e}),

\item {} 
\sphinxAtStartPar
(III) two paths must use equal or different polarizations (\sphinxtitleref{p\_i=p\_j} or \sphinxtitleref{p\_i\textless{}\textgreater{}p\_j}),

\item {} 
\sphinxAtStartPar
(IV) the absolute difference between two frequencies should be greater at a relaxation level l (0 to 10) than a given number g\_l (resp. d\_l) if polarization are equal (resp. different)  (\sphinxtitleref{|f\_i\sphinxhyphen{}f\_j|\textgreater{}=g\_l} if \sphinxtitleref{p\_i=p\_j} else \sphinxtitleref{|f\_i\sphinxhyphen{}f\_j|\textgreater{}=d\_l}), with \sphinxtitleref{g\_(l\sphinxhyphen{}1)\textgreater{}g\_l}, \sphinxtitleref{d\_(l\sphinxhyphen{}1)\textgreater{}d\_l}, and usually \sphinxtitleref{g\_l\textgreater{}d\_l}.

\end{itemize}

\sphinxAtStartPar
Constraints (I) to (III) are mandatory constraints, while constraints (IV) can be relaxed. The goal is to find a feasible assignment with the smallest relaxation level l and which minimizes the (weighted) number of violations of (IV) at lower levels. See \sphinxcode{\sphinxupquote{ROADEF\_Challenge\_2001}} .

\sphinxAtStartPar
The cost of a given solution will be calculated by the following formula: 10*k*nbsoft**2 + 10*nbsoft*V(k\sphinxhyphen{}1) + V(k\sphinxhyphen{}2) + V(k\sphinxhyphen{}3    ) + … + V0

\sphinxAtStartPar
where  nbsoft is the number of soft constraints in the problem and k the feasible relaxation level and V(i) the number of violated contraints of level i.

\noindent\sphinxincludegraphics[height=250\sphinxpxdimen]{{fapp}.png}


\subsection{CFN model}
\label{\detokenize{examples/tuto_fapwp:cfn-model}}
\sphinxAtStartPar
We create a single variable to represent a pair (frequency,polarization) for every radio link, but be aware, toulbar2 can only read str or int values, so in order to give a tuple to toulbar2 we need to first transform them into string. We use hard binary constraints to modelize (I) to (III) type constraints.

\sphinxAtStartPar
We assume the relaxation level k is given as input. In order to modelize (IV) type constraints we first take in argument the level of relaxation i, and we create 11 constraints, one for each relaxation level from 0 to 10. The first k\sphinxhyphen{}2 constraints are soft and with a violation cost of 1.
The soft constraint at level k\sphinxhyphen{}1 has a violation cost 10*nbsoft (the number of soft constraints) in order to maximize first the number of satisfied constraints at level k\sphinxhyphen{}1 and then the other soft constraints.
The constraints at levels k to 10 are hard constraints.

\sphinxAtStartPar
The initial upper bound of the problem will be 10*(k+1)*nbsoft**2 +1.


\subsection{Data}
\label{\detokenize{examples/tuto_fapwp:data}}
\sphinxAtStartPar
Original data files can be download from \sphinxhref{https://www.roadef.org/challenge/2001/en/sujet.php}{ROADEF} or \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/crafted/fapp/data}{fapp}. Their format is described \sphinxhref{https://www.roadef.org/challenge/2001/files/fapp\_roadef01\_rev2\_msword\_en.ps.gz}{here}. You can try a small example \sphinxcode{\sphinxupquote{exemple1.in}} (resp. \sphinxcode{\sphinxupquote{exemple2.in}}) with optimum 523 at relaxation level 3 with 1 violation at level 2 and 3 below (resp. 13871 at level 7 with 1 violation at level 6 and 11 below). See ROADEF Challenge 2001 \sphinxhref{https://uma.ensta-paris.fr/conf/roadef-2001-challenge/distrib/RES\_X/ResultatsComplets.xls}{results}.


\subsection{Python model}
\label{\detokenize{examples/tuto_fapwp:python-model}}
\sphinxAtStartPar
The following code solves the corresponding cost function network using the pytoulbar2 library and needs 4 arguments: the data file and the relaxation level (e.g. “python3 fapp.py exemple1.in 3”). You can also compile \sphinxcode{\sphinxupquote{fappeval.c}} using “gcc \sphinxhyphen{}o fappeval fappeval.c” and download \sphinxcode{\sphinxupquote{sol2fapp.awk}} in order to evaluate the solutions (e.g., “python3 fapp.py exemple1.in 3 | awk \sphinxhyphen{}f ./sol2fapp.awk \sphinxhyphen{} exemple1”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{fapp.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{k}{class} \PYG{n+nc}{Data}\PYG{p}{:}
	\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ctr} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{softeq} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{softne} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbsoft} \PYG{o}{=} \PYG{l+m+mi}{0}

		\PYG{n}{stream} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{stream}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{3} \PYG{o+ow}{and} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{DM}\PYG{p}{,} \PYG{n}{dom}\PYG{p}{,} \PYG{n}{freq}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{]}
				\PYG{k}{if} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{)} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{freq}\PYG{p}{)}\PYG{p}{]}
				\PYG{k}{else}\PYG{p}{:}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{freq}\PYG{p}{)}\PYG{p}{)}

			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{4} \PYG{o+ow}{and} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{TR}\PYG{p}{,} \PYG{n}{route}\PYG{p}{,} \PYG{n}{dom}\PYG{p}{,} \PYG{n}{polarisation}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{]}
				\PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{polarisation}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+} \PYG{p}{[}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}
				\PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{polarisation}\PYG{p}{)} \PYG{o}{==} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]} 
				\PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{polarisation}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{:}
					\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n}{f}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{k}{for} \PYG{n}{f} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dom}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{dom}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}

			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{6} \PYG{o+ow}{and} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CI}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{CI}\PYG{p}{,} \PYG{n}{route1}\PYG{p}{,} \PYG{n}{route2}\PYG{p}{,} \PYG{n}{vartype}\PYG{p}{,} \PYG{n}{operator}\PYG{p}{,} \PYG{n}{deviation}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{]}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ctr}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route2}\PYG{p}{)}\PYG{p}{,} \PYG{n}{vartype}\PYG{p}{,} \PYG{n}{operator}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{deviation}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{14} \PYG{o+ow}{and} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{CE}\PYG{p}{,} \PYG{n}{route1}\PYG{p}{,} \PYG{n}{route2}\PYG{p}{,} \PYG{n}{s0}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{,} \PYG{n}{s4}\PYG{p}{,} \PYG{n}{s5}\PYG{p}{,} \PYG{n}{s6}\PYG{p}{,} \PYG{n}{s7}\PYG{p}{,} \PYG{n}{s8}\PYG{p}{,} \PYG{n}{s9}\PYG{p}{,} \PYG{n}{s10}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{]}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{softeq}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{s0}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{,} \PYG{n}{s4}\PYG{p}{,} \PYG{n}{s5}\PYG{p}{,} \PYG{n}{s6}\PYG{p}{,} \PYG{n}{s7}\PYG{p}{,} \PYG{n}{s8}\PYG{p}{,} \PYG{n}{s9}\PYG{p}{,} \PYG{n}{s10}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbsoft} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{14} \PYG{o+ow}{and} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{==}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
				\PYG{p}{(}\PYG{n}{CD}\PYG{p}{,} \PYG{n}{route1}\PYG{p}{,} \PYG{n}{route2}\PYG{p}{,} \PYG{n}{s0}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{,} \PYG{n}{s4}\PYG{p}{,} \PYG{n}{s5}\PYG{p}{,} \PYG{n}{s6}\PYG{p}{,} \PYG{n}{s7}\PYG{p}{,} \PYG{n}{s8}\PYG{p}{,} \PYG{n}{s9}\PYG{p}{,} \PYG{n}{s10}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{]}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{softne}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{route2}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)} \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{s0}\PYG{p}{,} \PYG{n}{s1}\PYG{p}{,} \PYG{n}{s2}\PYG{p}{,} \PYG{n}{s3}\PYG{p}{,} \PYG{n}{s4}\PYG{p}{,} \PYG{n}{s5}\PYG{p}{,} \PYG{n}{s6}\PYG{p}{,} \PYG{n}{s7}\PYG{p}{,} \PYG{n}{s8}\PYG{p}{,} \PYG{n}{s9}\PYG{p}{,} \PYG{n}{s10}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{top} \PYG{o}{=} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{p}{(}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nbsoft}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1}        

\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{2}\PYG{p}{:}
	\PYG{n}{exit}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Command line argument is composed of the problem data filename and the relaxation level}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{k} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}collect data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{Data}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{k}\PYG{p}{)}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each link}
\PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{domain} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{e}\PYG{p}{]}\PYG{p}{:}
		\PYG{n}{domain}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)}\PYG{p}{,} \PYG{n}{domain}\PYG{p}{)}
	
\PYG{c+c1}{\PYGZsh{}hard binary constraints}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{route1}\PYG{p}{,} \PYG{n}{route2}\PYG{p}{,} \PYG{n}{vartype}\PYG{p}{,} \PYG{n}{operand}\PYG{p}{,} \PYG{n}{deviation}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ctr}\PYG{p}{:}
	\PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{p}{(}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{p1}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{route1}\PYG{p}{]}\PYG{p}{:}
	 	\PYG{k}{for} \PYG{p}{(}\PYG{n}{f2}\PYG{p}{,}\PYG{n}{p2}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{route2}\PYG{p}{]}\PYG{p}{:}
	 		\PYG{k}{if} \PYG{n}{vartype} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{F}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
	 			\PYG{k}{if} \PYG{n}{operand} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
	 				\PYG{k}{if} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{f2} \PYG{o}{\PYGZhy{}} \PYG{n}{f1}\PYG{p}{)} \PYG{o}{==} \PYG{n}{deviation}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
	 				\PYG{k}{else}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}
	 			\PYG{k}{else}\PYG{p}{:}
	 				\PYG{k}{if} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{f2} \PYG{o}{\PYGZhy{}} \PYG{n}{f1}\PYG{p}{)} \PYG{o}{!=} \PYG{n}{deviation}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
	 				\PYG{k}{else}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}
	 		\PYG{k}{else}\PYG{p}{:}
	 			\PYG{k}{if} \PYG{n}{operand} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
	 				\PYG{k}{if} \PYG{n}{p2} \PYG{o}{==} \PYG{n}{p1}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
	 				\PYG{k}{else}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}
	 			\PYG{k}{else}\PYG{p}{:}
	 				\PYG{k}{if} \PYG{n}{p2} \PYG{o}{!=} \PYG{n}{p1}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
	 				\PYG{k}{else}\PYG{p}{:}
	 					\PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{route1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{route2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Constraint}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{}soft binary constraints for equal polarization}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{route1}\PYG{p}{,} \PYG{n}{route2}\PYG{p}{,} \PYG{n}{deviations}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{softeq}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{ListConstraints} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{p}{(}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{p1}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{route1}\PYG{p}{]}\PYG{p}{:}
			\PYG{k}{for} \PYG{p}{(}\PYG{n}{f2}\PYG{p}{,}\PYG{n}{p2}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{route2}\PYG{p}{]}\PYG{p}{:}
	 			\PYG{k}{if} \PYG{n}{p1}\PYG{o}{!=}\PYG{n}{p2} \PYG{o+ow}{or} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{f1} \PYG{o}{\PYGZhy{}} \PYG{n}{f2}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{deviations}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
	 			\PYG{k}{elif} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{k}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}
	 			\PYG{k}{elif} \PYG{n}{i} \PYG{o}{==} \PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{data}\PYG{o}{.}\PYG{n}{nbsoft}\PYG{p}{)}
	 			\PYG{k}{else}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{route1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{route2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraints}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{}soft binary constraints for not equal polarization}
\PYG{k}{for} \PYG{p}{(}\PYG{n}{route1}\PYG{p}{,} \PYG{n}{route2}\PYG{p}{,} \PYG{n}{deviations}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{softne}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{ListConstraints} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{p}{(}\PYG{n}{f1}\PYG{p}{,}\PYG{n}{p1}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{route1}\PYG{p}{]}\PYG{p}{:}
	 		\PYG{k}{for} \PYG{p}{(}\PYG{n}{f2}\PYG{p}{,}\PYG{n}{p2}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{var}\PYG{p}{[}\PYG{n}{route2}\PYG{p}{]}\PYG{p}{:}
	 			\PYG{k}{if} \PYG{n}{p1}\PYG{o}{==}\PYG{n}{p2} \PYG{o+ow}{or} \PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{f1} \PYG{o}{\PYGZhy{}} \PYG{n}{f2}\PYG{p}{)} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{deviations}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
	 			\PYG{k}{elif} \PYG{n}{i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{k}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{top}\PYG{p}{)}
	 			\PYG{k}{elif} \PYG{n}{i} \PYG{o}{==} \PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{data}\PYG{o}{.}\PYG{n}{nbsoft}\PYG{p}{)}
	 			\PYG{k}{else}\PYG{p}{:}
	 				\PYG{n}{ListConstraints}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{route1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{X}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{route2}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraints}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}zero\PYGZhy{}arity cost function representing a constant cost corresponding to the relaxation at level k}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{o}{*}\PYG{n}{k}\PYG{o}{*}\PYG{n}{data}\PYG{o}{.}\PYG{n}{nbsoft}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}Fapp.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{900}\PYG{p}{)}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Mendelian error detection problem}
\label{\detokenize{examples/tuto_medp:mendelian-error-detection-problem}}\label{\detokenize{examples/tuto_medp:tuto-medp}}\label{\detokenize{examples/tuto_medp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_medp:brief-description}}
\sphinxAtStartPar
The problem is to detect marker genotyping incompatibilities (Mendelian errors) in complex pedigrees.
The input is a pedigree data with partial observed genotyping data at a single locus, we assume the pedigree to be exact, but not the genotyping data.
The problem is to assign genotypes (unordered pairs of alleles) to all individuals such that they are compatible with the Mendelian law of heredity (one allele is the same as their father’s and one as their mother’s). The goal is to maximize the number of matching allelle between the genotyping data and the solution. Each difference from the genotyping data has a cost of 1.

\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Sanchez07a.pdf}{Sanchez, M., de Givry, S. and Schiex, T. Constraints (2008) 13:130}.


\subsection{CFN model}
\label{\detokenize{examples/tuto_medp:cfn-model}}
\sphinxAtStartPar
We create N variables, one for each individual genotype with domain being all possible unordered pairs of existing alleles.
Hard ternary cost functions express mendelian law of heredity (one allele is the same as their father’s and one as their mother’s, with mother and father defined in the pedigree data).
For each genotyping data, we create one unary soft constraint with violation cost equal to 1 to represent the matching between the genotyping data and the solution.


\subsection{Data}
\label{\detokenize{examples/tuto_medp:data}}
\sphinxAtStartPar
Original data files can be download from the cost function library \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/real/pedigree/data/pre}{pedigree}. Their format is described \sphinxhref{http://miat.inrae.fr/MendelSoft}{here}. You can try a small example simple.pre (\sphinxcode{\sphinxupquote{simple.pre}}) with optimum value equal to 1.


\subsection{Python model}
\label{\detokenize{examples/tuto_medp:python-model}}
\sphinxAtStartPar
The following code solves the corresponding cost function network using the pytoulbar2 library (e.g. “python3 mendel.py simple.pre”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mendel.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{k}{class} \PYG{n+nc}{Data}\PYG{p}{:}
	\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{ped}\PYG{p}{)}\PYG{p}{:}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{id} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{father} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mother} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{allelesId} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ListAlle} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{p}{)}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{obs} \PYG{o}{=} \PYG{l+m+mi}{0}

		\PYG{n}{stream} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{ped}\PYG{p}{)}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{stream}\PYG{p}{:}
			\PYG{p}{(}\PYG{n}{locus}\PYG{p}{,} \PYG{n+nb}{id}\PYG{p}{,} \PYG{n}{father}\PYG{p}{,} \PYG{n}{mother}\PYG{p}{,} \PYG{n}{sex}\PYG{p}{,} \PYG{n}{allele1}\PYG{p}{,} \PYG{n}{allele2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{line}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{[}\PYG{p}{:}\PYG{p}{]}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{id}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{)}\PYG{p}{)}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{father}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{father}\PYG{p}{)}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{mother}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{mother}\PYG{p}{)}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{allelesId}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{)}\PYG{p}{]} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)}\PYG{p}{)} \PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)} \PYG{k}{else} \PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)}\PYG{p}{)}
			\PYG{k}{if} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)}\PYG{p}{)}
			\PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{o+ow}{not}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{)}\PYG{p}{:}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)}\PYG{p}{)}
			\PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele1}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{o+ow}{or} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{allele2}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
				\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{obs} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{}collect data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{Data}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{top} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{obs}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each individual}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{id}\PYG{p}{:}
	\PYG{n}{domains} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{a1} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
		\PYG{k}{for} \PYG{n}{a2} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{a1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{a2}\PYG{p}{:}
				\PYG{n}{domains}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{a1}\PYG{p}{)}\PYG{o}{+}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{+}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{a2}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{p}{,} \PYG{n}{domains}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create the constraints that represent the mendel\PYGZsq{}s laws}
\PYG{n}{ListConstraintsMendelLaw} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{p1} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{p2} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
		\PYG{k}{if} \PYG{n}{p1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{p2}\PYG{p}{:}	\PYG{c+c1}{\PYGZsh{} father alleles}
			\PYG{k}{for} \PYG{n}{m1} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
				\PYG{k}{for} \PYG{n}{m2} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
					\PYG{k}{if} \PYG{n}{m1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{m2}\PYG{p}{:}	\PYG{c+c1}{\PYGZsh{} mother alleles}
						\PYG{k}{for} \PYG{n}{a1} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
							\PYG{k}{for} \PYG{n}{a2} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
								\PYG{k}{if} \PYG{n}{a1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{a2}\PYG{p}{:}	\PYG{c+c1}{\PYGZsh{} child alleles}
									\PYG{k}{if} \PYG{p}{(}\PYG{n}{a1} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{p1}\PYG{p}{,}\PYG{n}{p2}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{a2} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{m1}\PYG{p}{,}\PYG{n}{m2}\PYG{p}{)}\PYG{p}{)} \PYG{o+ow}{or} \PYG{p}{(}\PYG{n}{a2} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{p1}\PYG{p}{,}\PYG{n}{p2}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{a1} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{m1}\PYG{p}{,}\PYG{n}{m2}\PYG{p}{)}\PYG{p}{)} \PYG{p}{:}
										\PYG{n}{ListConstraintsMendelLaw}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
									\PYG{k}{else} \PYG{p}{:}
									 	\PYG{n}{ListConstraintsMendelLaw}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{id}\PYG{p}{:}
	\PYG{c+c1}{\PYGZsh{}ternary constraints representing mendel\PYGZsq{}s laws}
	\PYG{k}{if} \PYG{n}{data}\PYG{o}{.}\PYG{n}{father}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mother}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{data}\PYG{o}{.}\PYG{n}{father}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(} \PYG{n}{data}\PYG{o}{.}\PYG{n}{mother}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsMendelLaw}\PYG{p}{)}
		
	\PYG{c+c1}{\PYGZsh{}unary constraints linked to the observations}
	\PYG{k}{if} \PYG{n}{data}\PYG{o}{.}\PYG{n}{allelesId}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{!=} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{data}\PYG{o}{.}\PYG{n}{allelesId}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
		\PYG{n}{ListConstraintsObservation} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a1} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
			\PYG{k}{for} \PYG{n}{a2} \PYG{o+ow}{in} \PYG{n}{data}\PYG{o}{.}\PYG{n}{ListAlle}\PYG{p}{:}
				\PYG{k}{if} \PYG{n}{a1} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{a2}\PYG{p}{:}
					\PYG{k}{if} \PYG{p}{(}\PYG{n}{a1}\PYG{p}{,}\PYG{n}{a2}\PYG{p}{)} \PYG{o}{==} \PYG{n}{data}\PYG{o}{.}\PYG{n}{allelesId}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{:}
						\PYG{n}{ListConstraintsObservation}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
					\PYG{k}{else} \PYG{p}{:}
					 	\PYG{n}{ListConstraintsObservation}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsObservation}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}Mendel.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{There are}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{difference(s) between the solution and the observation.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No solution found}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Block modeling problem}
\label{\detokenize{examples/tuto_bmp:block-modeling-problem}}\label{\detokenize{examples/tuto_bmp:tuto-bmp}}\label{\detokenize{examples/tuto_bmp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_bmp:brief-description}}
\sphinxAtStartPar
This is a clustering problem, occuring in social network analysis.

\sphinxAtStartPar
The problem is to divide a given directed graph G into k clusters such that the interactions between clusters can be summarized by a k*k 0/1 matrix M: if M{[}i,j{]}=1 then all the nodes in cluster i should be connected to all the nodes in cluster j in G, else if M{[}i,j{]}=0 then there should be no edge in G between the nodes from the two clusters.

\sphinxAtStartPar
For example, the following graph G is composed of 4 nodes:

\noindent\sphinxincludegraphics[height=200\sphinxpxdimen]{{graph}.png}

\sphinxAtStartPar
and corresponds to the following matrix:

\noindent\sphinxincludegraphics[height=100\sphinxpxdimen]{{matrix}.png}

\sphinxAtStartPar
It can be perfectly clusterized into the following graph by clustering together the nodes 0, 2 and 3 in cluster 1 and the node 1 in cluster 0:

\noindent\sphinxincludegraphics[height=75\sphinxpxdimen]{{graph2}.png}

\sphinxAtStartPar
and this graph corresponds to the following M matrix:

\noindent\sphinxincludegraphics[height=50\sphinxpxdimen]{{matrix2}.png}

\sphinxAtStartPar
On the contrary, if we decide to cluster the next graph G’ in the same way as above, the edge (2, 3) will be ‘lost’ in the process and the cost of the solution will be 1.

\noindent\sphinxincludegraphics[height=200\sphinxpxdimen]{{graph3}.png}

\sphinxAtStartPar
The goal is to find a k\sphinxhyphen{}clustering of a given graph and the associated matrix M that minimize the number of erroneous edges.

\sphinxAtStartPar
\sphinxhref{https://www.jair.org/index.php/jair/article/download/12280/26656}{A Mattenet, I Davidson, S Nijssen, P Schaus. Generic Constraint\sphinxhyphen{}Based Block Modeling Using Constraint Programming. CP 2019, pp656\sphinxhyphen{}673, Stamford, CT, USA}.


\subsection{CFN model}
\label{\detokenize{examples/tuto_bmp:cfn-model}}
\sphinxAtStartPar
We create N variables, one for every node of the graph, with domain size k representing the clustering.
We add k*k Boolean variables for representing M.

\sphinxAtStartPar
For all triplets of two nodes u, v, and one matrix cell M{[}i,j{]}, we have a ternary cost function which returns a cost of 1 if node u is assigned to cluster i, v to j, and M{[}i,j{]}=1 but (u,v) is not in G, or M{[}i,j{]}=0 and (u,v) is in G. In order to break symmetries, we constrain the first k\sphinxhyphen{}1 node variables to be assigned to a cluster number less than or equal to their index


\subsection{Data}
\label{\detokenize{examples/tuto_bmp:data}}
\sphinxAtStartPar
You can try a small example \sphinxcode{\sphinxupquote{simple.mat}} with optimum value equal to 0 for 3 clusters.

\sphinxAtStartPar
Perfect solution for the small example with k=3 (Mattenet et al, CP 2019)

\noindent\sphinxincludegraphics[height=250\sphinxpxdimen]{{simple}.png}

\sphinxAtStartPar
More examples with 3 clusters (Stochastic Block Models \sphinxhref{https://doi.org/10.1371/journal.pone.0215296}{{[}Funke and Becker, Plos One 2019{]}})

\noindent\sphinxincludegraphics[height=250\sphinxpxdimen]{{SBM}.png}

\sphinxAtStartPar
See other examples, such as \sphinxhref{https://www.ifip.com/Partitioning\_Political\_Actor.html}{PoliticalActor} and more, here :
\sphinxcode{\sphinxupquote{100.mat}} |
\sphinxcode{\sphinxupquote{150.mat}} |
\sphinxcode{\sphinxupquote{200.mat}} |
\sphinxcode{\sphinxupquote{30.mat}} |
\sphinxcode{\sphinxupquote{50.mat}} |
\sphinxcode{\sphinxupquote{hartford\_drug.mat}} |
\sphinxcode{\sphinxupquote{kansas.mat}} |
\sphinxcode{\sphinxupquote{politicalactor.mat}} |
\sphinxcode{\sphinxupquote{sharpstone.mat}} |
\sphinxcode{\sphinxupquote{transatlantic.mat}}.


\subsection{Python model}
\label{\detokenize{examples/tuto_bmp:python-model}}
\sphinxAtStartPar
The following code using pytoulbar2 library solves the corresponding cost function network (e.g. “python3 blockmodel.py simple.mat 3”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{blockmodel.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{c+c1}{\PYGZsh{}read adjency matrix of graph G}
\PYG{n}{Lines} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{GMatrix} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{e}\PYG{p}{)} \PYG{k}{for} \PYG{n}{e} \PYG{o+ow}{in} \PYG{n}{l}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{Lines}\PYG{p}{]}

\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{Lines}\PYG{p}{)}
\PYG{n}{Top} \PYG{o}{=} \PYG{n}{N}\PYG{o}{*}\PYG{n}{N} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{n}{K} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}give names to node variables}
\PYG{n}{Var} \PYG{o}{=} \PYG{p}{[}\PYG{p}{(}\PYG{n+nb}{chr}\PYG{p}{(}\PYG{l+m+mi}{65} \PYG{o}{+} \PYG{n}{i}\PYG{p}{)} \PYG{k}{if} \PYG{n}{N} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{28} \PYG{k}{else} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} Political actor or any instance}
\PYG{c+c1}{\PYGZsh{}    Var = [\PYGZdq{}ron\PYGZdq{},\PYGZdq{}tom\PYGZdq{},\PYGZdq{}frank\PYGZdq{},\PYGZdq{}boyd\PYGZdq{},\PYGZdq{}tim\PYGZdq{},\PYGZdq{}john\PYGZdq{},\PYGZdq{}jeff\PYGZdq{},\PYGZdq{}jay\PYGZdq{},\PYGZdq{}sandy\PYGZdq{},\PYGZdq{}jerry\PYGZdq{},\PYGZdq{}darrin\PYGZdq{},\PYGZdq{}ben\PYGZdq{},\PYGZdq{}arnie\PYGZdq{}] \PYGZsh{} Transatlantic}
\PYG{c+c1}{\PYGZsh{}    Var = [\PYGZdq{}justin\PYGZdq{},\PYGZdq{}harry\PYGZdq{},\PYGZdq{}whit\PYGZdq{},\PYGZdq{}brian\PYGZdq{},\PYGZdq{}paul\PYGZdq{},\PYGZdq{}ian\PYGZdq{},\PYGZdq{}mike\PYGZdq{},\PYGZdq{}jim\PYGZdq{},\PYGZdq{}dan\PYGZdq{},\PYGZdq{}ray\PYGZdq{},\PYGZdq{}cliff\PYGZdq{},\PYGZdq{}mason\PYGZdq{},\PYGZdq{}roy\PYGZdq{}] \PYGZsh{} Sharpstone}
\PYG{c+c1}{\PYGZsh{}    Var = [\PYGZdq{}Sherrif\PYGZdq{},\PYGZdq{}CivilDef\PYGZdq{},\PYGZdq{}Coroner\PYGZdq{},\PYGZdq{}Attorney\PYGZdq{},\PYGZdq{}HighwayP\PYGZdq{},\PYGZdq{}ParksRes\PYGZdq{},\PYGZdq{}GameFish\PYGZdq{},\PYGZdq{}KansasDOT\PYGZdq{},\PYGZdq{}ArmyCorps\PYGZdq{},\PYGZdq{}ArmyReserve\PYGZdq{},\PYGZdq{}CrableAmb\PYGZdq{},\PYGZdq{}FrankCoAmb\PYGZdq{},\PYGZdq{}LeeRescue\PYGZdq{},\PYGZdq{}Shawney\PYGZdq{},\PYGZdq{}BurlPolice\PYGZdq{},\PYGZdq{}LyndPolice\PYGZdq{},\PYGZdq{}RedCross\PYGZdq{},\PYGZdq{}TopekaFD\PYGZdq{},\PYGZdq{}CarbFD\PYGZdq{},\PYGZdq{}TopekaRBW\PYGZdq{}] \PYGZsh{} Kansas}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{Top}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a Boolean variable for each coefficient of the M GMatrix}
\PYG{k}{for} \PYG{n}{u} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a domain variable for each node in graph G}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{n}{Var}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}general case for each edge in G}
\PYG{k}{for} \PYG{n}{u} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{i} \PYG{o}{!=} \PYG{n}{j}\PYG{p}{:}
                    \PYG{n}{ListCost} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                    \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
                            \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{if} \PYG{p}{(}\PYG{n}{u} \PYG{o}{==} \PYG{n}{k} \PYG{o+ow}{and} \PYG{n}{v} \PYG{o}{==} \PYG{n}{l} \PYG{o+ow}{and} \PYG{n}{GMatrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                                    \PYG{n}{ListCost}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
                                \PYG{k}{else}\PYG{p}{:}
                                    \PYG{n}{ListCost}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Var}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Var}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}\PYG{n}{ListCost}\PYG{p}{)}



\PYG{c+c1}{\PYGZsh{} self\PYGZhy{}loops must be treated separately as they involves only two variables}
\PYG{k}{for} \PYG{n}{u} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ListCost} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{u} \PYG{o}{==} \PYG{n}{k} \PYG{o+ow}{and} \PYG{n}{GMatrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{!=} \PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                    \PYG{n}{ListCost}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n}{ListCost}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Var}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListCost}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} breaking partial symmetries by fixing first (K\PYGZhy{}1) domain variables to be assigned to a cluster number less than or equal to their index}
\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{k} \PYG{o}{\PYGZgt{}} \PYG{n}{l}\PYG{p}{:}
            \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{Top}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{Var}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Constraint}\PYG{p}{)}

\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Dump}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{replace}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.mat}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{.cfn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{M matrix:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{u} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Line} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{Line}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{u}\PYG{o}{*}\PYG{n}{K}\PYG{o}{+}\PYG{n}{v}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{Line}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{K}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{K}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]} \PYG{o}{==} \PYG{n}{k}\PYG{p}{:}
                \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Node}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{Var}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{with index}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{is in cluster}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{K}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Airplane landing problem}
\label{\detokenize{examples/tuto_alp:airplane-landing-problem}}\label{\detokenize{examples/tuto_alp:tuto-alp}}\label{\detokenize{examples/tuto_alp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_alp:brief-description}}
\sphinxAtStartPar
We consider a single plane’s landing runway.
Given a set of planes with given target landing time, the objective is to minimize the total weighted deviation from the target landing time for each plane.

\sphinxAtStartPar
There are costs associated with landing either earlier or later than the target landing time for each plane.

\sphinxAtStartPar
Each plane has to land within its predetermined time window.
For each pair of planes, there is an additionnal contraints to enforce that separation between those planes in bigger than a given number.

\sphinxAtStartPar
\sphinxhref{https://doi.org/10.1287/trsc.34.2.180.12302}{J.E. Beasley, M. Krishnamoorthy, Y.M. Sharaiha and D. Abramson. Scheduling aircraft landings \sphinxhyphen{} the static case. Transportation Science, vol.34, 2000}.


\subsection{CFN model}
\label{\detokenize{examples/tuto_alp:cfn-model}}
\sphinxAtStartPar
We create N variables, one for each plane, with domain value equal to all their possible landing time.

\sphinxAtStartPar
Binary hard cost functions express separation times between pairs of planes. Unary soft cost functions represent the weighted deviation for each plane.


\subsection{Data}
\label{\detokenize{examples/tuto_alp:data}}
\sphinxAtStartPar
Original data files can be download from the cost function library \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/crafted/airland/data}{airland}. Their format is described \sphinxhref{http://people.brunel.ac.uk/~mastjjb/jeb/orlib/airlandinfo.html}{here}. You can try a small example \sphinxcode{\sphinxupquote{airland1.txt}} with optimum value equal to 700.


\subsection{Python model solver}
\label{\detokenize{examples/tuto_alp:python-model-solver}}
\sphinxAtStartPar
The following code uses the pytoulbar2 module to generate the cost function network and solve it (e.g. “python3 airland.py airland1.txt”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{airland.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{tokens} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{tokens} \PYG{o}{+}\PYG{o}{=} \PYG{n}{l}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{pos} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{k}{def} \PYG{n+nf}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{global} \PYG{n}{pos}\PYG{p}{,} \PYG{n}{tokens}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{pos} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tokens}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{tokens}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}
    \PYG{n}{pos} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{N} \PYG{o}{=} \PYG{n}{token}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{token}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} skip freeze time}

\PYG{n}{LT} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{PC} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{ST} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{token}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} skip appearance time}
\PYG{c+c1}{\PYGZsh{} Times per plane: \PYGZob{}earliest landing time, target landing time, latest landing time\PYGZcb{}}
    \PYG{n}{LT}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Penalty cost per unit of time per plane:}
\PYG{c+c1}{\PYGZsh{} [for landing before target, after target]}
    \PYG{n}{PC}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Separation time required after i lands before j can land}
    \PYG{n}{ST}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{[}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{=} \PYG{l+m+mi}{99999}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{ListCost} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
    \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{if} \PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:}
            \PYG{n}{ListCost}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{PC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{a}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{else}\PYG{p}{:}
            \PYG{n}{ListCost}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{PC}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{p}{(}\PYG{n}{a} \PYG{o}{\PYGZhy{}} \PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListCost}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{LT}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{LT}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{LT}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{a}\PYG{o}{+}\PYG{n}{ST}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{b} \PYG{o+ow}{and} \PYG{n}{b}\PYG{o}{+}\PYG{n}{ST}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZgt{}}\PYG{n}{a}\PYG{p}{:}
                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{Constraint}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}airplane.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{NoPreprocessing}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Warehouse location problem}
\label{\detokenize{examples/tuto_wlp:warehouse-location-problem}}\label{\detokenize{examples/tuto_wlp:tuto-wlp}}\label{\detokenize{examples/tuto_wlp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_wlp:brief-description}}
\sphinxAtStartPar
A compagny consider opening warehouses at some candidate locations with each of them having a maintenance cost if they are open.

\sphinxAtStartPar
The compagny control a set of given stores and each of them need to take suplies to one of the warehouse, but depending the warehouse chosen, there will be an additionnal cost.

\sphinxAtStartPar
The objective is to choose wich warehouse to open and to divide the store among the open warehouse ion order to minimize the total cost of the store’s cost and the maintenance cost.


\subsection{CFN model}
\label{\detokenize{examples/tuto_wlp:cfn-model}}
\sphinxAtStartPar
We create Boolean variables for the warehouses (i.e., open or not) and integer variables for the store, with domain size the number of warehouses to represent to wich warehouse the store will take suplies.

\sphinxAtStartPar
Hard binary constraints represent that a store cannnot take suplies from a closed warehouse.
Soft unary constraints represent the maintenance cost of the warehouses.
Soft unary constraints represent the store’s cost regarding wich warehouse to take supplies from.


\subsection{Data}
\label{\detokenize{examples/tuto_wlp:data}}
\sphinxAtStartPar
Original data files can be download from the cost function library \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/crafted/warehouses/data/txt}{warehouses}. Their format is described \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/crafted/warehouses/readme.txt}{here}.


\subsection{Python model solver}
\label{\detokenize{examples/tuto_wlp:python-model-solver}}
\sphinxAtStartPar
The following code uses the pytoulbar2 module to generate the cost function network and solve it (e.g. “python3 warehouse.py cap44.txt 1” found optimum value equal to 10349757). Other instances are available \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/tree/master/crafted/warehouses/instances/cfn}{here} in cfn format.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{warehouse.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{precision} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} used to convert cost values from float to integer}

\PYG{n}{tokens} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{f}\PYG{p}{:}
    \PYG{n}{tokens} \PYG{o}{+}\PYG{o}{=} \PYG{n}{l}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{pos} \PYG{o}{=} \PYG{l+m+mi}{0}

\PYG{k}{def} \PYG{n+nf}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{global} \PYG{n}{pos}\PYG{p}{,} \PYG{n}{tokens}
    \PYG{k}{if} \PYG{n}{pos} \PYG{o}{==} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tokens}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return} \PYG{k+kc}{None}
    \PYG{n}{s} \PYG{o}{=} \PYG{n}{tokens}\PYG{p}{[}\PYG{n}{pos}\PYG{p}{]}
    \PYG{n}{pos} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
    \PYG{k}{return} \PYG{n}{s}


\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} number of warehouses}
\PYG{n}{M} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} number of stores}

\PYG{n}{top} \PYG{o}{=} \PYG{l+m+mi}{1}  \PYG{c+c1}{\PYGZsh{} sum of all costs plus one}

\PYG{n}{CostW} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} maintenance cost of warehouses}
\PYG{n}{Capacity} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} capacity limit of warehouses (not used)}

\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Capacity}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{CostW}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{10.}\PYG{o}{*}\PYG{o}{*}\PYG{n}{precision}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{CostW}\PYG{p}{)}

\PYG{n}{Demand} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} demand for each store}
\PYG{n}{CostS} \PYG{o}{=} \PYG{p}{[}\PYG{p}{[}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{]}  \PYG{c+c1}{\PYGZsh{} supply cost matrix}

\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Demand}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{CostS}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{token}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{10.}\PYG{o}{*}\PYG{o}{*}\PYG{n}{precision}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{top} \PYG{o}{+}\PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{CostS}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} create a new empty cost function network}
\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add warehouse variables}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add store variables}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{s}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add maintenance costs}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{CostW}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add supply costs for each store}
\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{N}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{CostS}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} add channeling constraints between warehouses and stores}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{M}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{a} \PYG{o}{==} \PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{b} \PYG{o}{==} \PYG{n}{i}\PYG{p}{:}
                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{n}{i}\PYG{p}{,} \PYG{n}{N}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Constraint}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}warehouse.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Square packing problem}
\label{\detokenize{examples/tuto_spp:square-packing-problem}}\label{\detokenize{examples/tuto_spp:tuto-spp}}\label{\detokenize{examples/tuto_spp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_spp:brief-description}}
\sphinxAtStartPar
We have N squares of respectives size 1×1, 2×2,…, NxN. We have to fit them without overlaps into a square of size SxS.

\sphinxAtStartPar
Results up to N=56 are given \sphinxhref{https://oeis.org/A005842}{here}.

\sphinxAtStartPar
Optimal solution for 15 squares packed into a 36x36 square (Fig. taken from Takehide Soh)

\noindent\sphinxincludegraphics[height=250\sphinxpxdimen]{{square}.png}


\subsection{CFN model}
\label{\detokenize{examples/tuto_spp:cfn-model}}
\sphinxAtStartPar
We create an integer variable of domain size (S\sphinxhyphen{}i)x(S\sphinxhyphen{}i) for each square.
The variable represents the position of the top left corner of the square.

\sphinxAtStartPar
The value of a given variable modulo (S\sphinxhyphen{}i) gives the x\sphinxhyphen{}coordinate, whereas its value divided by (S\sphinxhyphen{}i) gives the y\sphinxhyphen{}coordinate.

\sphinxAtStartPar
We have hard binary constraints to forbid any overlapping pair of squares.

\sphinxAtStartPar
We make the problem a pure satisfaction problem by fixing the initial upper bound to 1.


\subsection{Python model}
\label{\detokenize{examples/tuto_spp:python-model}}
\sphinxAtStartPar
The following code uses the pytoulbar2 library to generate the cost function network and solve it (e.g. “python3 square.py 3 5”).
\sphinxcode{\sphinxupquote{square.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}\PYG{p}{,} \PYG{n}{seed}		
\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456789}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}
\PYG{k}{try}\PYG{p}{:}
	\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
	\PYG{n}{S} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
	\PYG{k}{assert} \PYG{n}{N} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{S}
\PYG{k}{except}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Two integers need to be given as arguments: N and S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
	\PYG{n}{exit}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}pure constraint satisfaction problem}
\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each square}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}binary hard constraints for overlapping squares}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{ListConstraintsOverlaps} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{S}\PYG{o}{*}\PYG{n}{k}\PYG{o}{+}\PYG{n}{l} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}
			\PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{S}\PYG{o}{*}\PYG{n}{m}\PYG{o}{+}\PYG{n}{n} \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}
				\PYG{c+c1}{\PYGZsh{}calculating the coordinates of the squares}
				\PYG{n}{X\PYGZus{}i} \PYG{o}{=} \PYG{n}{a}\PYG{o}{\PYGZpc{}}\PYG{n}{S}
				\PYG{n}{X\PYGZus{}j} \PYG{o}{=} \PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{S}
				\PYG{n}{Y\PYGZus{}i} \PYG{o}{=} \PYG{n}{a}\PYG{o}{/}\PYG{o}{/}\PYG{n}{S}
				\PYG{n}{Y\PYGZus{}j} \PYG{o}{=} \PYG{n}{b}\PYG{o}{/}\PYG{o}{/}\PYG{n}{S}
				\PYG{c+c1}{\PYGZsh{}calculating if squares are overlapping}
				\PYG{k}{if} \PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{X\PYGZus{}j} \PYG{p}{:}
					\PYG{k}{if} \PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}j} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
						\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{Y\PYGZus{}j}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
						\PYG{k}{else}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
				\PYG{k}{else} \PYG{p}{:}
					\PYG{k}{if} \PYG{n}{X\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
						\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{Y\PYGZus{}j}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
						\PYG{k}{else}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsOverlaps}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}Square.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{row} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
		\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{p}{:}
			\PYG{n}{row} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
			\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
				\PYG{k}{if} \PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{j} \PYG{o+ow}{and} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{o}{/}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{i} \PYG{o+ow}{and} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{o}{/}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
					\PYG{n}{row} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n+nb}{chr}\PYG{p}{(}\PYG{l+m+mi}{65} \PYG{o}{+} \PYG{n}{k}\PYG{p}{)}
		\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No solution found!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{C++ program using libtb2.so}
\label{\detokenize{examples/tuto_spp:c-program-using-libtb2-so}}
\sphinxAtStartPar
The following code uses the C++ toulbar2 library. Compile toulbar2 with “cmake \sphinxhyphen{}DLIBTB2=ON \sphinxhyphen{}DPYTB2=ON . ; make” and copy the library in your current directory “cp lib/Linux/libtb2.so .” before compiling “g++ \sphinxhyphen{}o square square.cpp \sphinxhyphen{}Isrc \sphinxhyphen{}Llib/Linux \sphinxhyphen{}std=c++11 \sphinxhyphen{}O3 \sphinxhyphen{}DNDEBUG \sphinxhyphen{}DBOOST \sphinxhyphen{}DLONGDOUBLE\_PROB \sphinxhyphen{}DLONGLONG\_COST \sphinxhyphen{}DWCSPFORMATONLY libtb2.so” and running the example (e.g. “./square 15 36”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{square.cpp}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

/**
 * Square Packing Problem
 */

// Compile with cmake option \PYGZhy{}DLIBTB2=ON \PYGZhy{}DPYTB2=ON to get C++ toulbar2 library lib/Linux/libtb2.so
// Then,
// g++ \PYGZhy{}o square square.cpp \PYGZhy{}Isrc \PYGZhy{}Llib/Linux \PYGZhy{}std=c++11 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DWCSPFORMATONLY libtb2.so

\PYGZsh{}include \PYGZdq{}toulbar2lib.hpp\PYGZdq{}

\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}

int main(int argc, char* argv[])
\PYGZob{}
    int N = atoi(argv[1]);
    int S = atoi(argv[2]);

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

    ToulBar2::verbose = 0; // change to 0 or higher values to see more trace information

    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data\PYGZhy{}type

    Cost top = UNIT\PYGZus{}COST;
    WeightedCSPSolver* solver = WeightedCSPSolver::makeWeightedCSPSolver(top);

    for (int i=0; i\PYGZlt{}N; i++) \PYGZob{}
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}sq\PYGZdq{} + to\PYGZus{}string(i+1), 0, (S\PYGZhy{}i)*(S\PYGZhy{}i) \PYGZhy{} 1);
    \PYGZcb{}

    for (int i=0; i\PYGZlt{}N; i++) \PYGZob{}
        for (int j=i+1; j\PYGZlt{}N; j++) \PYGZob{}
            vector\PYGZlt{}Cost\PYGZgt{} costs((S\PYGZhy{}i)*(S\PYGZhy{}i)*(S\PYGZhy{}j)*(S\PYGZhy{}j), MIN\PYGZus{}COST);
    	    for (int a=0; a\PYGZlt{}(S\PYGZhy{}i)*(S\PYGZhy{}i); a++) \PYGZob{}
    	        for (int b=0; b\PYGZlt{}(S\PYGZhy{}j)*(S\PYGZhy{}j); b++) \PYGZob{}
                    costs[a*(S\PYGZhy{}j)*(S\PYGZhy{}j)+b] = ((((a\PYGZpc{}(S\PYGZhy{}i)) + i + 1 \PYGZlt{}= (b\PYGZpc{}(S\PYGZhy{}j))) || ((b\PYGZpc{}(S\PYGZhy{}j)) + j + 1 \PYGZlt{}= (a\PYGZpc{}(S\PYGZhy{}i))) || ((a/(S\PYGZhy{}i)) + i + 1 \PYGZlt{}= (b/(S\PYGZhy{}j))) || ((b/(S\PYGZhy{}j)) + j + 1 \PYGZlt{}= (a/(S\PYGZhy{}i))))?MIN\PYGZus{}COST:top);
                \PYGZcb{}
            \PYGZcb{}
            solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(i, j, costs);
        \PYGZcb{}
    \PYGZcb{}

    solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}sortConstraints(); // must be done at the end of the modeling

    tb2checkOptions();
    if (solver\PYGZhy{}\PYGZgt{}solve()) \PYGZob{}
            vector\PYGZlt{}Value\PYGZgt{} sol;
            solver\PYGZhy{}\PYGZgt{}getSolution(sol);
    	    for (int y=0; y\PYGZlt{}S; y++) \PYGZob{}
                for (int x=0; x\PYGZlt{}S; x++) \PYGZob{}
                    char c = \PYGZsq{} \PYGZsq{};
                    for (int i=0; i\PYGZlt{}N; i++) \PYGZob{}
                        if (x \PYGZgt{}= (sol[i]\PYGZpc{}(S\PYGZhy{}i)) \PYGZam{}\PYGZam{} x \PYGZlt{} (sol[i]\PYGZpc{}(S\PYGZhy{}i) ) + i + 1 \PYGZam{}\PYGZam{} y \PYGZgt{}= (sol[i]/(S\PYGZhy{}i)) \PYGZam{}\PYGZam{} y \PYGZlt{} (sol[i]/(S\PYGZhy{}i)) + i + 1) \PYGZob{}
                            c = 65+i;
                            break;
                        \PYGZcb{}
                     \PYGZcb{}
                     cout \PYGZlt{}\PYGZlt{} c;
                \PYGZcb{}
                cout \PYGZlt{}\PYGZlt{} endl;
            \PYGZcb{}
    \PYGZcb{} else \PYGZob{}
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}No solution found!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;
    \PYGZcb{}

    delete solver;
    return 0;
\PYGZcb{}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Square soft packing problem}
\label{\detokenize{examples/tuto_sspp:square-soft-packing-problem}}\label{\detokenize{examples/tuto_sspp:tuto-sspp}}\label{\detokenize{examples/tuto_sspp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_sspp:brief-description}}
\sphinxAtStartPar
The problem is almost identical to the square packing problem with the difference that we now allow overlaps but we want to minimize them.


\subsection{CFN model}
\label{\detokenize{examples/tuto_sspp:cfn-model}}
\sphinxAtStartPar
We reuse the {\hyperref[\detokenize{examples/tuto_spp:tuto-spp}]{\sphinxcrossref{\DUrole{std,std-ref}{Square packing problem}}}} model except that binary constraints are replaced by cost functions returning the overlapping size or zero if no overlaps.

\sphinxAtStartPar
To calculate an initial upper bound we simply compute the worst case scenario where N squares of size N*N are all stacks together. The cost of this is N**4, so we will take N**4+1 as the initial upperbound.


\subsection{Python model}
\label{\detokenize{examples/tuto_sspp:python-model}}
\sphinxAtStartPar
The following code using pytoulbar2 library solves the corresponding cost function network (e.g. “python3 squaresoft.py 10 20”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{squaresoft.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}\PYG{p}{,} \PYG{n}{seed}		
\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456789}\PYG{p}{)}

\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}
\PYG{k}{try}\PYG{p}{:}
	\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
	\PYG{n}{S} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
	\PYG{k}{assert} \PYG{n}{N} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{S}
\PYG{k}{except}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Two integers need to be given as arguments: N and S}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
	\PYG{n}{exit}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{4} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each square}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{}binary soft constraints for overlapping squares}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{ListConstraintsOverlaps} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
		\PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{S}\PYG{o}{*}\PYG{n}{k}\PYG{o}{+}\PYG{n}{l} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}
			\PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{S}\PYG{o}{*}\PYG{n}{m}\PYG{o}{+}\PYG{n}{n} \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)} \PYG{k}{for} \PYG{n}{n} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}
				\PYG{c+c1}{\PYGZsh{}calculating the coordinates of the squares}
				\PYG{n}{X\PYGZus{}i} \PYG{o}{=} \PYG{n}{a}\PYG{o}{\PYGZpc{}}\PYG{n}{S}
				\PYG{n}{X\PYGZus{}j} \PYG{o}{=} \PYG{n}{b}\PYG{o}{\PYGZpc{}}\PYG{n}{S}
				\PYG{n}{Y\PYGZus{}i} \PYG{o}{=} \PYG{n}{a}\PYG{o}{/}\PYG{o}{/}\PYG{n}{S}
				\PYG{n}{Y\PYGZus{}j} \PYG{o}{=} \PYG{n}{b}\PYG{o}{/}\PYG{o}{/}\PYG{n}{S}
				\PYG{c+c1}{\PYGZsh{}calculating if squares are overlapping}
				\PYG{k}{if} \PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{X\PYGZus{}j} \PYG{p}{:}
					\PYG{k}{if} \PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}j} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
						\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{Y\PYGZus{}j}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
						\PYG{k}{else}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
				\PYG{k}{else} \PYG{p}{:}
					\PYG{k}{if} \PYG{n}{X\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}i} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
						\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{Y\PYGZus{}j}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZlt{}} \PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{X\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}j}\PYG{p}{)}\PYG{p}{,}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
						\PYG{k}{else}\PYG{p}{:}
							\PYG{k}{if} \PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}i} \PYG{o}{\PYGZlt{}} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{X\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{X\PYGZus{}i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{Y\PYGZus{}j} \PYG{o}{\PYGZhy{}} \PYG{n}{Y\PYGZus{}i}\PYG{p}{)}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
							\PYG{k}{else}\PYG{p}{:}
								\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{n}{ListConstraintsOverlaps}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
		\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ListConstraintsOverlaps}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}SquareSoft.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
	\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{row} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}
		\PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{S}\PYG{p}{)}\PYG{p}{:}
			\PYG{n}{row} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}
			\PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{:}
				\PYG{k}{if} \PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{j} \PYG{o+ow}{and} \PYG{n}{j} \PYG{o}{\PYGZhy{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{\PYGZpc{}}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)} \PYG{o+ow}{and} \PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{o}{/}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{i} \PYG{o+ow}{and} \PYG{n}{i} \PYG{o}{\PYGZhy{}} \PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{o}{/}\PYG{p}{(}\PYG{n}{S}\PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{k}\PYG{p}{)}\PYG{p}{:}
					\PYG{n}{row} \PYG{o}{=} \PYG{n}{row}\PYG{p}{[}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{+} \PYG{n+nb}{chr}\PYG{p}{(}\PYG{l+m+mi}{65} \PYG{o}{+} \PYG{n}{k}\PYG{p}{)}
		\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
	\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No solution found!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{C++ program using libtb2.so}
\label{\detokenize{examples/tuto_sspp:c-program-using-libtb2-so}}
\sphinxAtStartPar
The following code uses the C++ toulbar2 library. Compile toulbar2 with “cmake \sphinxhyphen{}DLIBTB2=ON \sphinxhyphen{}DPYTB2=ON . ; make” and copy the library in your current directory “cp lib/Linux/libtb2.so .” before compiling “g++ \sphinxhyphen{}o squaresoft squaresoft.cpp \sphinxhyphen{}I./src \sphinxhyphen{}L./lib/Linux \sphinxhyphen{}std=c++11 \sphinxhyphen{}O3 \sphinxhyphen{}DNDEBUG \sphinxhyphen{}DBOOST \sphinxhyphen{}DLONGDOUBLE\_PROB \sphinxhyphen{}DLONGLONG\_COST \sphinxhyphen{}DWCSPFORMATONLY libtb2.so” and running the example (e.g. “./squaresoft 10 20”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{squaresoft.cpp}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

/**
 * Square Soft Packing Problem
 */

// Compile with cmake option \PYGZhy{}DLIBTB2=ON \PYGZhy{}DPYTB2=ON to get C++ toulbar2 library lib/Linux/libtb2.so
// Then,
// g++ \PYGZhy{}o squaresoft squaresoft.cpp \PYGZhy{}Isrc \PYGZhy{}Llib/Linux \PYGZhy{}std=c++11 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DWCSPFORMATONLY libtb2.so

\PYGZsh{}include \PYGZdq{}toulbar2lib.hpp\PYGZdq{}

\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}

int main(int argc, char* argv[])
\PYGZob{}
    int N = atoi(argv[1]);
    int S = atoi(argv[2]);

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

    ToulBar2::verbose = 0; // change to 0 or higher values to see more trace information

    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data\PYGZhy{}type

    Cost top = N*(N*(N\PYGZhy{}1)*(2*N\PYGZhy{}1))/6 + 1;
    WeightedCSPSolver* solver = WeightedCSPSolver::makeWeightedCSPSolver(top);

    for (int i=0; i \PYGZlt{} N; i++) \PYGZob{}
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}sq\PYGZdq{} + to\PYGZus{}string(i+1), 0, (S\PYGZhy{}i)*(S\PYGZhy{}i) \PYGZhy{} 1);
    \PYGZcb{}

    for (int i=0; i \PYGZlt{} N; i++) \PYGZob{}
        for (int j=i+1; j \PYGZlt{} N; j++) \PYGZob{}
            vector\PYGZlt{}Cost\PYGZgt{} costs((S\PYGZhy{}i)*(S\PYGZhy{}i)*(S\PYGZhy{}j)*(S\PYGZhy{}j), MIN\PYGZus{}COST);
    	    for (int a=0; a \PYGZlt{} (S\PYGZhy{}i)*(S\PYGZhy{}i); a++) \PYGZob{}
    	        for (int b=0; b \PYGZlt{} (S\PYGZhy{}j)*(S\PYGZhy{}j); b++) \PYGZob{}
                    costs[a*(S\PYGZhy{}j)*(S\PYGZhy{}j)+b] = ((((a\PYGZpc{}(S\PYGZhy{}i)) + i + 1 \PYGZlt{}= (b\PYGZpc{}(S\PYGZhy{}j))) || ((b\PYGZpc{}(S\PYGZhy{}j)) + j + 1 \PYGZlt{}= (a\PYGZpc{}(S\PYGZhy{}i))) || ((a/(S\PYGZhy{}i)) + i + 1 \PYGZlt{}= (b/(S\PYGZhy{}j))) || ((b/(S\PYGZhy{}j)) + j + 1 \PYGZlt{}= (a/(S\PYGZhy{}i))))?MIN\PYGZus{}COST:(min((a\PYGZpc{}(S\PYGZhy{}i)) + i + 1 \PYGZhy{} (b\PYGZpc{}(S\PYGZhy{}j)), (b\PYGZpc{}(S\PYGZhy{}j)) + j + 1 \PYGZhy{} (a\PYGZpc{}(S\PYGZhy{}i))) * min((a/(S\PYGZhy{}i)) + i + 1 \PYGZhy{} (b/(S\PYGZhy{}j)), (b/(S\PYGZhy{}j)) + j + 1 \PYGZhy{} (a/(S\PYGZhy{}i)))));
                \PYGZcb{}
            \PYGZcb{}
            solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(i, j, costs);
        \PYGZcb{}
    \PYGZcb{}

    solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}sortConstraints(); // must be done at the end of the modeling

    tb2checkOptions();
    if (solver\PYGZhy{}\PYGZgt{}solve()) \PYGZob{}
            vector\PYGZlt{}Value\PYGZgt{} sol;
            solver\PYGZhy{}\PYGZgt{}getSolution(sol);
    	    for (int y=0; y \PYGZlt{} S; y++) \PYGZob{}
                for (int x=0; x \PYGZlt{} S; x++) \PYGZob{}
                    char c = \PYGZsq{} \PYGZsq{};
                    for (int i=N\PYGZhy{}1; i \PYGZgt{}= 0; i\PYGZhy{}\PYGZhy{}) \PYGZob{}
                        if (x \PYGZgt{}= (sol[i]\PYGZpc{}(S\PYGZhy{}i)) \PYGZam{}\PYGZam{} x \PYGZlt{} (sol[i]\PYGZpc{}(S\PYGZhy{}i) ) + i + 1 \PYGZam{}\PYGZam{} y \PYGZgt{}= (sol[i]/(S\PYGZhy{}i)) \PYGZam{}\PYGZam{} y \PYGZlt{} (sol[i]/(S\PYGZhy{}i)) + i + 1) \PYGZob{}
                            if (c != \PYGZsq{} \PYGZsq{}) \PYGZob{}
                                c = 97+i;
                            \PYGZcb{} else \PYGZob{}
                                c = 65+i;
                            \PYGZcb{}
                        \PYGZcb{}
                     \PYGZcb{}
                     cout \PYGZlt{}\PYGZlt{} c;
                \PYGZcb{}
                cout \PYGZlt{}\PYGZlt{} endl;
            \PYGZcb{}
    \PYGZcb{} else \PYGZob{}
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}No solution found!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;
    \PYGZcb{}

    delete solver;
    return 0;
\PYGZcb{}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Golomb ruler problem}
\label{\detokenize{examples/tuto_grp:golomb-ruler-problem}}\label{\detokenize{examples/tuto_grp:tuto-grp}}\label{\detokenize{examples/tuto_grp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_grp:brief-description}}
\sphinxAtStartPar
A golomb ruler of order N is a set of integer marks 0=a1\textless{}a2\textless{}a3\textless{}a4\textless{}….\textless{}aN such that each difference between two ak’s are unique.

\sphinxAtStartPar
For example, this is a golomb ruler:

\noindent\sphinxincludegraphics{{gruler1}.png}

\sphinxAtStartPar
We can see that all differences are unique, rather than in this other ruler where 0\sphinxhyphen{}3 and 3\sphinxhyphen{}6 are both equal to 3.

\noindent\sphinxincludegraphics{{gruler2}.png}

\sphinxAtStartPar
The size of a golomb ruler is equal to aN, the greatest number of the ruler. The goal is to find the smallest golomb ruler given N.


\subsection{CFN model}
\label{\detokenize{examples/tuto_grp:cfn-model}}
\sphinxAtStartPar
We create N variables, one for each integer mark ak. Because we can not create an AllDifferent constraint with differences of variables, we also create a variable for each difference and create hard ternary constraints in order to fix them equal to the difference.
Because we do not use an absolute value when creating the hard constraints, it forces the assignment of ak’s variables to follow an increasing order.

\sphinxAtStartPar
Then we create an AllDifferent constraint on all the difference variables and one unary cost function on the last aN variable in order to minimize the size of the ruler.
In order to break symmetries, we fix the first mark to be zero.


\subsection{Python model}
\label{\detokenize{examples/tuto_grp:python-model}}
\sphinxAtStartPar
The following code using pytoulbar2 library solves the golomb ruler problem with the first argument being the number of marks N (e.g. “python3 golomb.py 8”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{golomb.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{n}{N} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{=} \PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each mark}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}ternary constraints to link new variables of difference with the original variables}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
        \PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{if} \PYG{n}{l}\PYG{o}{\PYGZhy{}}\PYG{n}{k} \PYG{o}{==} \PYG{n}{m}\PYG{p}{:}
                        \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
                    \PYG{k}{else}\PYG{p}{:}
                        \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Constraint}\PYG{p}{)}

\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddAllDifferent}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)} \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{N}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}fix the first mark to be zero}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{+} \PYG{p}{[}\PYG{n}{top}\PYG{p}{]} \PYG{o}{*} \PYG{p}{(}\PYG{n}{N}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}golomb.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
    \PYG{n}{ruler} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{0}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{N}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ruler} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{*}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Golomb ruler of size:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{ruler}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxstepscope


\section{Board coloration problem}
\label{\detokenize{examples/tuto_bcp:board-coloration-problem}}\label{\detokenize{examples/tuto_bcp:tuto-bcp}}\label{\detokenize{examples/tuto_bcp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/tuto_bcp:brief-description}}
\sphinxAtStartPar
Given a rectangular board with dimension n*m, the goal is to color the cells such that any inner rectangle included inside the board doesn’t have all its corners colored with the same color.
The goal is to minimize the number of colors used.

\sphinxAtStartPar
For examples, this is not a valid solution of the 3*4 problem, because the red and blue rectangles have both their 4 corners having the same color:

\noindent\sphinxincludegraphics{{tchess}.png}

\sphinxAtStartPar
On the contrary the following coloration is a valid solution of the 3*4 problem because every inner rectangle inside the board does not have a unique color for its corners:

\noindent\sphinxincludegraphics{{fchess}.png}


\subsection{CFN basic model}
\label{\detokenize{examples/tuto_bcp:cfn-basic-model}}
\sphinxAtStartPar
We create n*m variables, one for each square of the board, with domain size equal to n*m representing all the possible colors. We also create one variable for the number of colors.

\sphinxAtStartPar
We create hard quaterny constraints for every rectangle inside the board with cost equal to 0 if the 4 variables have different values and a forbidden cost if not.

\sphinxAtStartPar
We then create hard binary constraints between the variable of the number of colors for each cell to fix the variable for the number of colors as an upper bound.

\sphinxAtStartPar
Then we create a soft constraint on the number of colors to minimize it.


\subsection{Python model}
\label{\detokenize{examples/tuto_bcp:python-model}}
\sphinxAtStartPar
The following code using pytoulbar2 library solves the board coloration problem with the first two arguments being the dimension n and m of the board (e.g. “python3 boardcoloration.py 3 4”).

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{boardcoloration.py}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{from} \PYG{n+nn}{random} \PYG{k+kn}{import} \PYG{n}{randint}\PYG{p}{,} \PYG{n}{seed}
\PYG{n}{seed}\PYG{p}{(}\PYG{l+m+mi}{123456789}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{pytoulbar2}

\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{n} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{m} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{sys}\PYG{o}{.}\PYG{n}{argv}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Two integer need to be in arguments: number of rows n, number of columns m}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{exit}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{top} \PYG{o}{=} \PYG{n}{n}\PYG{o}{*}\PYG{n}{m} \PYG{o}{+} \PYG{l+m+mi}{1}

\PYG{n}{Problem} \PYG{o}{=} \PYG{n}{pytoulbar2}\PYG{o}{.}\PYG{n}{CFN}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for each cell}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}create a variable for the maximum of colors}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddVariable}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}quaterny hard constraints for rectangle with same color angles}
\PYG{c+c1}{\PYGZsh{}for each cell on the chessboard}
\PYG{k}{for} \PYG{n}{i1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i2} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
        \PYG{c+c1}{\PYGZsh{}for every cell on the chessboard that could form a rectangle with the first cell as up left corner and this cell as down right corner}
        \PYG{k}{for} \PYG{n}{j1} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{j2} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{i2}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
                \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                    \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                        \PYG{k}{for} \PYG{n}{o} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                            \PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                                \PYG{k}{if} \PYG{n}{k} \PYG{o}{==}\PYG{n}{l} \PYG{o+ow}{and} \PYG{n}{l} \PYG{o}{==} \PYG{n}{o} \PYG{o+ow}{and} \PYG{n}{o} \PYG{o}{==} \PYG{n}{p}\PYG{p}{:}
                                    \PYG{c+c1}{\PYGZsh{}if they are all the same color }
                                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
                                \PYG{k}{else}\PYG{p}{:}
                                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i1}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i2}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i1}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j2}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j1}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i2}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j1}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j2}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Constraint}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}binary hard constraints to fix the variable max as an upper bound}
\PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{Constraint} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
                \PYG{k}{if} \PYG{n}{k}\PYG{o}{\PYGZgt{}}\PYG{n}{l}\PYG{p}{:}
                    \PYG{c+c1}{\PYGZsh{}if the color of the square is more than the number of the max}
                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{top}\PYG{p}{)}
                \PYG{k}{else}\PYG{p}{:}
                    \PYG{n}{Constraint}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}
        \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sq(}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{,}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{Constraint}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}minimize the number of colors}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{AddFunction}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{max}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{o}{*}\PYG{n}{m}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Problem.Dump(\PYGZsq{}boardcoloration.cfn\PYGZsq{})}
\PYG{n}{Problem}\PYG{o}{.}\PYG{n}{CFN}\PYG{o}{.}\PYG{n}{timer}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}
\PYG{n}{res} \PYG{o}{=} \PYG{n}{Problem}\PYG{o}{.}\PYG{n}{Solve}\PYG{p}{(}\PYG{n}{showSolutions} \PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{res}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{row} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{j} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{:}
            \PYG{n}{row}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{res}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{m}\PYG{o}{*}\PYG{n}{i}\PYG{o}{+}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
\PYG{k}{else}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{No solutions found}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
                                                              \PYG{l+m+mi}{70}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{9}        \PYG{n}{Bas}
\end{sphinxVerbatim}

\sphinxstepscope


\section{Learning to play the Sudoku}
\label{\detokenize{examples/ltps:learning-to-play-the-sudoku}}\label{\detokenize{examples/ltps:ltps}}\label{\detokenize{examples/ltps::doc}}



\subsection{Available}
\label{\detokenize{examples/ltps:available}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/CFN-learn/tree/master/Sudoku\#readme}{Presentation}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/CFN-learn}{GitHub code}
\sphinxhref{https://github.com/toulbar2/CFN-learn}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}

\item {} 
\sphinxAtStartPar
Data
\sphinxhref{https://github.com/toulbar2/CFN-learn/tree/master/Sudoku}{GitHub code}
\sphinxhref{https://github.com/toulbar2/CFN-learn/tree/master/Sudoku}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}

\end{itemize}

\sphinxstepscope


\section{Learning car configuration preferences}
\label{\detokenize{examples/rccs:learning-car-configuration-preferences}}\label{\detokenize{examples/rccs:rccs}}\label{\detokenize{examples/rccs::doc}}



\subsection{Brief description}
\label{\detokenize{examples/rccs:brief-description}}
\sphinxAtStartPar
Renault car configuration system: learning user preferences.


\subsection{Available}
\label{\detokenize{examples/rccs:available}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/CFN-learn/tree/master/renault\#readme}{Presentation}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/CFN-learn}{GitHub code}
\sphinxhref{https://github.com/toulbar2/CFN-learn}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}

\item {} 
\sphinxAtStartPar
Data \sphinxhref{https://github.com/toulbar2/CFN-learn/tree/master/renault}{GitHub code}
\sphinxhref{https://github.com/toulbar2/CFN-learn/tree/master/renault}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}

\end{itemize}

\sphinxstepscope


\section{Visual Sudoku Tutorial}
\label{\detokenize{examples/vstut:visual-sudoku-tutorial}}\label{\detokenize{examples/vstut:vs-tut}}\label{\detokenize{examples/vstut::doc}}



\subsection{Brief description}
\label{\detokenize{examples/vstut:brief-description}}
\sphinxAtStartPar
A simple case mixing \sphinxstylestrong{Deep Learning} and \sphinxstylestrong{Graphical models}.


\subsection{Available}
\label{\detokenize{examples/vstut:available}}\begin{itemize}
\item {} 
\sphinxAtStartPar
You can run it directly from your browser as a
\sphinxhref{https://colab.research.google.com/drive/1ew7IceldcAhyZZ0bHvaHynZyM-s-ne0l\#scrollTo=tBwwmI21cFVZ}{Jupyter Notebook}
\sphinxhref{https://colab.research.google.com/drive/1ew7IceldcAhyZZ0bHvaHynZyM-s-ne0l\#scrollTo=tBwwmI21cFVZ}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-colab}.png}}

\end{itemize}

\sphinxstepscope


\section{Visual Sudoku Application}
\label{\detokenize{examples/vsapp:visual-sudoku-application}}\label{\detokenize{examples/vsapp:vs-app}}\label{\detokenize{examples/vsapp::doc}}



\subsection{Brief description}
\label{\detokenize{examples/vsapp:brief-description}}
\sphinxAtStartPar
An automatic Sudoku puzzle \sphinxstylestrong{solver} using \sphinxstylestrong{OpenCV}, \sphinxstylestrong{Deep Learning}, and \sphinxstylestrong{Optical Character Recognition} (\sphinxstylestrong{OCR}).


\subsection{Available}
\label{\detokenize{examples/vsapp:available}}

\subsubsection{Software}
\label{\detokenize{examples/vsapp:software}}
\sphinxAtStartPar
\sphinxstylestrong{Software} adapted by Simon de Givry (@ INRAE, 2022)
in order to use \sphinxstylestrong{toulbar2} solver, from a
\sphinxhref{https://pyimagesearch.com/2020/08/10/opencv-sudoku-solver-and-ocr}{tutorial}
by Adrian Rosebrock (@ PyImageSearch, 2022) :
\sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/-/tree/master/crafted/visualsudoku}{GitHub code}
\sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/-/tree/master/crafted/visualsudoku}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}


\subsubsection{As an APK}
\label{\detokenize{examples/vsapp:as-an-apk}}
\sphinxAtStartPar
Based on this software, a ‘Visual Sudoku’ application for Android has been developed to be used from a
smartphone.

\sphinxAtStartPar
See the {\hyperref[\detokenize{examples/vsapp_apk:vs-app-apk}]{\sphinxcrossref{\DUrole{std,std-ref}{detailed presentation}}}}
(description, source, download…).

\sphinxAtStartPar
The application allows to capture a grid from its own camera (\sphinxstyleemphasis{‘CAMERA’ menu})
or to select a grid among the smartphone existing files (\sphinxstyleemphasis{‘FILE’ menu}), for
example files coming from ‘DCIM’, in .jpg or .png formats. The grid image must
have been captured in portrait orientation. Once the grid has been chosen, the
\sphinxstyleemphasis{‘Solve’} button allows to get the solution.
\begin{quote}

\sphinxAtStartPar
Fig.1 \sphinxincludegraphics[width=150\sphinxpxdimen]{{apk_main_menu}.png} Fig.2 \sphinxincludegraphics[width=150\sphinxpxdimen]{{apk_grid_screen}.png} Fig.3 \sphinxincludegraphics[width=150\sphinxpxdimen]{{apk_solution_grid}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Fig.1 : Screen of main menu

\item {} 
\sphinxAtStartPar
Fig.2 : Screen of the grid to be solved

\item {} 
\sphinxAtStartPar
Fig.3 : Screen of the solution (in yellow) found by the solver

\end{itemize}
\end{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Examples of some input grids and their solved grids}}


\subsubsection{As a Web service}
\label{\detokenize{examples/vsapp:as-a-web-service}}
\sphinxAtStartPar
The software is available as a web service.
The \sphinxstylestrong{visual sudoku web service}, hosted by the \sphinxhref{http://147.100.179.250}{ws} web services (based on HTTP protocol), can be called by many ways : from a \sphinxstylestrong{browser} (like above), from any softwares written in a language supporting HTTP protocol (\sphinxstylestrong{Python}, \sphinxstylestrong{R}, \sphinxstylestrong{C++}, \sphinxstylestrong{Java}, \sphinxstylestrong{Php}…), from command line tools (\sphinxstylestrong{cURL}…)…
\begin{itemize}
\item {} 
\sphinxAtStartPar
Calling the visual sudoku web service from a \sphinxstylestrong{browser} :
\begin{quote}

\sphinxAtStartPar
\sphinxincludegraphics[width=200\sphinxpxdimen]{{logo-ws_ui-vsudoku}.png} \sphinxhref{http://147.100.179.250/api/ui/vsudoku}{\sphinxincludegraphics[width=100\sphinxpxdimen]{{qr-code_ui-vsudoku}.png}}
\sphinxhref{http://147.100.179.250/api/ui/vsudoku}{api/ui/vsudoku}
\end{quote}

\item {} 
\sphinxAtStartPar
Example of calling the visual sudoku web service from a \sphinxstylestrong{terminal} by
\sphinxstylestrong{cURL} :

\sphinxAtStartPar
Commands (\sphinxstyleemphasis{replace mygridfilename.jpg by your own image file name}) :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{output} \PYG{n}{mysolutionfilename}\PYG{o}{.}\PYG{n}{jpg} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{file=@mygridfilename.jpg}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{keep=40}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{border=15}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{147.100}\PYG{l+m+mf}{.179}\PYG{l+m+mf}{.250}\PYG{o}{/}\PYG{n}{api}\PYG{o}{/}\PYG{n}{tool}\PYG{o}{/}\PYG{n}{vsudoku}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
The ‘Visual Sudoku’ APK calls the visual sudoku web service.

\end{itemize}

\sphinxstepscope


\section{Visual Sudoku App for Android}
\label{\detokenize{examples/vsapp_apk:visual-sudoku-app-for-android}}\label{\detokenize{examples/vsapp_apk:vs-app-apk}}\label{\detokenize{examples/vsapp_apk::doc}}



\subsection{A visual sudoku solver based on cost function networks}
\label{\detokenize{examples/vsapp_apk:a-visual-sudoku-solver-based-on-cost-function-networks}}\begin{quote}

\sphinxAtStartPar
This application solves the sudoku problem from a smartphone by reading the
grid using its camera. The cost function network solver toulbar2 is used to
deal with the uncertainty on the digit recognition produced by the neural
network. This uncertainty, combined with the sudoku logical rules, makes it
possible to correct perceptual errors. It is particularly useful in the case
of hand\sphinxhyphen{}written digits or poor image quality. It is also possible to solve a
partially filled\sphinxhyphen{}in grid with printed and hand\sphinxhyphen{}written digits. The solver
will always suggest a valid solution that best adapts to the retrieved digit
information. It will naturally detect (a small number of) errors in a
partially filled\sphinxhyphen{}in grid and could be used later as a diagnosis tool (future
work). This software demonstration emphasizes the tight relation between
constraint programming, computer vision, and deep learning.

\sphinxAtStartPar
We used the open\sphinxhyphen{}source C++ solver
\sphinxhref{https://github.com/toulbar2/toulbar2}{toulbar2} in order to find the
maximum a posteriori solution of a constrained probabilistic graphical model.
With its dedicated numerical (soft) local consistency bounds, toulbar2
outperforms traditional CP solvers on this problem. Grid perception and cell
extraction are performed by the computer vision library
\sphinxhref{https://opencv.org}{OpenCV}. Digit recognition is done by \sphinxstylestrong{Keras} and
\sphinxstylestrong{TensorFlow}. The current android application is written in Python using
the \sphinxhref{https://kivy.org}{Kivy} framework. It is inspired from a
\sphinxhref{https://pyimagesearch.com/2020/08/10/opencv-sudoku-solver-and-ocr}{tutorial}
by Adrian Rosebrock. It uses the \sphinxhref{http://147.100.179.250}{ws} RESTful web
services in order to run the solver.

\sphinxAtStartPar
See also : {\hyperref[\detokenize{examples/vsapp:vs-app}]{\sphinxcrossref{\DUrole{std,std-ref}{Visual Sudoku Application}}}}.
\end{quote}


\subsection{Source Code}
\label{\detokenize{examples/vsapp_apk:source-code}}\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/visualsudoku}{GitHub code}
\sphinxhref{https://github.com/toulbar2/visualsudoku}{\sphinxincludegraphics[width=30\sphinxpxdimen]{{logo-github}.png}}
\end{quote}


\subsection{Download and Install}
\label{\detokenize{examples/vsapp_apk:download-and-install}}\begin{quote}

\sphinxAtStartPar
To install the ‘Visual Sudoku’ application on smartphone :
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Download} the \sphinxstylestrong{visualsudoku\sphinxhyphen{}release.apk} APK file from Github
repository :
\begin{quote}

\sphinxAtStartPar
\sphinxhref{https://github.com/toulbar2/visualsudoku/releases/latest}{\sphinxincludegraphics[width=100\sphinxpxdimen]{{qr-code_visualsudokuapk}.png}}
\sphinxurl{https://github.com/toulbar2/visualsudoku/releases/latest}
\end{quote}

\item {} 
\sphinxAtStartPar
Click on the downloaded \sphinxstylestrong{visualsudoku\sphinxhyphen{}release.apk} APK file to ask
for \sphinxstylestrong{installation}
(\sphinxstyleemphasis{you have to accept to ‘install anyway’ from unknown developer}).

\item {} 
\sphinxAtStartPar
In your parameter settings for the app, give permissions to the
‘Visual Sudoku’ application
(smartphone menu ‘Parameters’ \textgreater{} ‘Applications’ \textgreater{} ‘Visual Sudoku’) :
allow camera (required to capture grids), files and multimedia contents
(required to save images as files). Re\sphinxhyphen{}run the app.

\end{enumerate}

\sphinxAtStartPar
Warnings :
\begin{itemize}
\item {} 
\sphinxAtStartPar
The application may fail at first start and you may have to launch it
twice.

\item {} 
\sphinxAtStartPar
While setting up successfully, the application should have created
itself the required ‘VisualSudoku’ folder (under the smartphone
‘Internal storage’ folder) but if not, you will have to create it
by yourself manually.

\item {} 
\sphinxAtStartPar
Since the application calls a web service, an internet connection is required.

\end{itemize}
\end{quote}


\subsection{Description}
\label{\detokenize{examples/vsapp_apk:description}}\begin{quote}

\sphinxAtStartPar
The ‘SETTINGS’ menu allows to save grids or solutions as image files (‘savinginputfile’, ‘savingoutputfile’ parameters) and to access to some ‘expert’ parameters in order to enhance the resolution process (‘keep’, ‘border’, ‘time’ parameters).

\sphinxAtStartPar
The application allows to capture a grid from its own camera (\sphinxstyleemphasis{‘CAMERA’ menu})
or to select a grid among the smartphone existing files (\sphinxstyleemphasis{‘FILE’ menu}), for
example files coming from ‘DCIM’, in .jpg or .png formats. The grid image must
have been captured in portrait orientation. Once the grid has been chosen, the
\sphinxstyleemphasis{‘Solve’} button allows to get the solution.
\begin{quote}

\sphinxAtStartPar
Fig.1 \sphinxincludegraphics[width=150\sphinxpxdimen]{{apk_main_menu}.png} Fig.2 \sphinxincludegraphics[width=150\sphinxpxdimen]{{apk_grid_screen}.png} Fig.3 \sphinxincludegraphics[width=150\sphinxpxdimen]{{apk_solution_grid}.png}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Fig.1 : Screen of main menu

\item {} 
\sphinxAtStartPar
Fig.2 : Screen of the grid to be solved

\item {} 
\sphinxAtStartPar
Fig.3 : Screen of the solution (in yellow) found by the solver

\end{itemize}
\end{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Examples of some input grids and their solved grids}}
\end{quote}

\sphinxstepscope


\section{A sudoku code}
\label{\detokenize{examples/snum:a-sudoku-code}}\label{\detokenize{examples/snum:snum}}\label{\detokenize{examples/snum::doc}}



\subsection{Brief description}
\label{\detokenize{examples/snum:brief-description}}
\sphinxAtStartPar
A Sudoku code returning a sudoku partial grid (sudoku problem) and the corresponding completed grid (sudoku solution), such as \sphinxcode{\sphinxupquote{partial and completed grids}}.

\sphinxAtStartPar
The verbose version, that further gives a detailed description of what the program does, could be useful as tutorial example. Example :
\sphinxcode{\sphinxupquote{partial and completed grids with explanations}}.


\subsection{Available}
\label{\detokenize{examples/snum:available}}
\sphinxAtStartPar
Available as a web service.

\sphinxAtStartPar
You can run the software directly from your \sphinxstylestrong{browser} as a web service :

\sphinxAtStartPar
Grids information is returned into the output stream.
The \sphinxstylestrong{returned\_type} parameter of the web service allows to choose
how to receive it :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{returned\_type=stdout.txt} : to get the output stream as a .txt file.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{returned\_type=run.zip} : to get the .zip run folder containing the output stream \_\_WS\_\_stdout.txt (\sphinxstyleemphasis{+ the error stream \_\_WS\_\_stderr.txt that may be useful to investigate}).

\end{itemize}


\subsubsection{Web service to get one sudoku grids (both partial and completed) :}
\label{\detokenize{examples/snum:web-service-to-get-one-sudoku-grids-both-partial-and-completed}}\begin{quote}

\sphinxAtStartPar
\sphinxincludegraphics[width=200\sphinxpxdimen]{{logo-ws_ui-sudoku}.png}
\sphinxhref{http://147.100.179.250/api/ui/sudoku}{\sphinxincludegraphics[width=100\sphinxpxdimen]{{qr-code_ui-sudoku}.png}}
\sphinxhref{http://147.100.179.250/api/ui/sudoku}{api/ui/sudoku}
\end{quote}


\subsubsection{Web service to further get a detailed description of what the program does (verbose version) :}
\label{\detokenize{examples/snum:web-service-to-further-get-a-detailed-description-of-what-the-program-does-verbose-version}}\begin{quote}

\sphinxAtStartPar
\sphinxincludegraphics[width=200\sphinxpxdimen]{{logo-ws_ui-sudoku-tut}.png}
\sphinxhref{http://147.100.179.250/api/ui/sudoku/tut}{\sphinxincludegraphics[width=100\sphinxpxdimen]{{qr-code_ui-sudoku-tut}.png}}
\sphinxhref{http://147.100.179.250/api/ui/sudoku/tut}{api/ui/sudoku/tut (verbose version)}
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxstylestrong{sudoku web services}, hosted by the \sphinxhref{http://147.100.179.250}{ws} web services (based on HTTP protocol), can be called by many other ways : from a \sphinxstylestrong{browser} (like above), from any softwares written in a language supporting HTTP protocol (\sphinxstylestrong{Python}, \sphinxstylestrong{R}, \sphinxstylestrong{C++}, \sphinxstylestrong{Java}, \sphinxstylestrong{Php}…), from command line tools (\sphinxstylestrong{cURL}…)…
\end{sphinxadmonition}


\subsubsection{Example of calling the sudoku web services from a terminal by cURL :}
\label{\detokenize{examples/snum:example-of-calling-the-sudoku-web-services-from-a-terminal-by-curl}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Commands (\sphinxstyleemphasis{replace indice value by any value in 1…17999}) :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{output} \PYG{n}{mygrids}\PYG{o}{.}\PYG{n}{txt} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indice=778}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{returned\PYGZus{}type=stdout.txt}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{147.100}\PYG{l+m+mf}{.179}\PYG{l+m+mf}{.250}\PYG{o}{/}\PYG{n}{api}\PYG{o}{/}\PYG{n}{tool}\PYG{o}{/}\PYG{n}{sudoku}

\PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{output} \PYG{n}{myrun}\PYG{o}{.}\PYG{n}{zip} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indice=778}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{returned\PYGZus{}type=run.zip}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{147.100}\PYG{l+m+mf}{.179}\PYG{l+m+mf}{.250}\PYG{o}{/}\PYG{n}{api}\PYG{o}{/}\PYG{n}{tool}\PYG{o}{/}\PYG{n}{sudoku}

\PYG{c+c1}{\PYGZsh{} verbose version}

\PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{output} \PYG{n}{mygrids\PYGZus{}details}\PYG{o}{.}\PYG{n}{txt} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indice=778}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{returned\PYGZus{}type=stdout.txt}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{147.100}\PYG{l+m+mf}{.179}\PYG{l+m+mf}{.250}\PYG{o}{/}\PYG{n}{api}\PYG{o}{/}\PYG{n}{tool}\PYG{o}{/}\PYG{n}{sudoku}\PYG{o}{/}\PYG{n}{tut}

\PYG{n}{curl} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{output} \PYG{n}{myrun\PYGZus{}details}\PYG{o}{.}\PYG{n}{zip} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indice=778}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{F} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{returned\PYGZus{}type=run.zip}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{http}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{147.100}\PYG{l+m+mf}{.179}\PYG{l+m+mf}{.250}\PYG{o}{/}\PYG{n}{api}\PYG{o}{/}\PYG{n}{tool}\PYG{o}{/}\PYG{n}{sudoku}\PYG{o}{/}\PYG{n}{tut}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Responses corresponding with the requests above :
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mygrids.txt}}

\item {} 
\sphinxAtStartPar
\_\_WS\_\_stdout.txt into myrun.zip has the same content as
\sphinxcode{\sphinxupquote{mygrids.txt}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{mygrids\_details.txt}} (\sphinxstyleemphasis{\_\_WS\_\_stdout.txt into myrun\_details.zip has the same content})

\item {} 
\sphinxAtStartPar
\_\_WS\_\_stdout.txt into myrun\_details.zip has the same content as
\sphinxcode{\sphinxupquote{mygrids\_details.txt}}

\end{itemize}

\end{itemize}

\sphinxstepscope


\chapter{User Guide}
\label{\detokenize{userdoc:user-guide}}\label{\detokenize{userdoc:userdoc}}\label{\detokenize{userdoc::doc}}

\section{What is toulbar2}
\label{\detokenize{userdoc:what-is-toulbar2}}
\sphinxAtStartPar
toulbar2 is an exact black box discrete optimization solver targeted
at solving cost function networks (CFN), thus solving the so\sphinxhyphen{}called
“weighted Constraint Satisfaction Problem” or WCSP. Cost function
networks can be simply described by a set of discrete variables each
having a specific finite domain and a set of integer cost functions,
each involving some of the variables. The WCSP is to find an
assignment of all variables such that the sum of all cost functions is
minimum and lest than a given upper bound often denoted as \(k\) or
\(\top\). Functions can be typically specified by sparse or full tables
but also more concisely as specific functions called “global cost
functions” \sphinxcite{userdoc:schiex2016a}.

\sphinxAtStartPar
Using on the fly translation, toulbar2 can also directly solve
optimization problems on other graphical models such as Maximum
probability Explanation (MPE) on Bayesian networks \sphinxcite{userdoc:koller2009}, and
Maximum A Posteriori (MAP) on Markov random field \sphinxcite{userdoc:koller2009}. It can also
read partial weighted MaxSAT problems, Quadratic Pseudo Boolean
problems (MAXCUT) as well as Linkage \sphinxstylestrong{.pre} pedigree files for
genotyping error detection and correction.

\sphinxAtStartPar
toulbar2 is exact. It will only report an optimal solution when it
has both identified the solution and proved its optimality. Because it
relies only on integer operations, addition and subtraction, it does
not suffer from rounding errors. In the general case, the WCSP,
MPE/BN, MAP/MRF, PWMaxSAT, QPBO or MAXCUT being all NP\sphinxhyphen{}hard problems
and thus toulbar2 may take exponential time to prove optimality. This
is however a worst\sphinxhyphen{}case behavior and toulbar2 has been shown to be
able to solve to optimality problems with half a million non Boolean
variables defining a search space as large as \(2^{829,440}\). It may
also fail to solve in reasonable time problems with a search space
smaller than \(2^{264}\).

\sphinxAtStartPar
toulbar2 provides and uses by default an “anytime”
algorithm \sphinxcite{userdoc:katsirelos2015a} that tries to quickly provide good solutions together
with an upper bound on the gap between the cost of each solution and
the (unknown) optimal cost. Thus, even if it is unable to prove
optimality, it will bound the quality of the solution provided.
It can also apply a variable neighborhood search algorithm exploiting a problem decomposition \sphinxcite{userdoc:ouali2017}.
This algorithm is complete (if enough CPU\sphinxhyphen{}time is given) and it can be run in parallel using OpenMPI.
A parallel version of previous algorithm also exists {[}Beldjilali2022{]}.

\sphinxAtStartPar
Beyond the service of providing optimal solutions, toulbar2 can also find a greedy sequence of diverse solutions \sphinxcite{userdoc:ruffini2019a} or
exhaustively enumerate solutions below a cost threshold and
perform guaranteed approximate weighted counting of solutions. For
stochastic graphical models, this means that toulbar2 will compute
the partition function (or the normalizing constant \(Z\)). These
problems being \#P\sphinxhyphen{}complete, toulbar2 runtimes can quickly increase
on such problems.

\sphinxAtStartPar
By exploiting the new toulbar2 python interface, with incremental solving capabilities, it is possible to learn a CFN from data and to combine it with mandatory constraints \sphinxcite{userdoc:schiex2020b}.
See examples at \sphinxurl{https://forgemia.inra.fr/thomas.schiex/cfn-learn}.


\section{How do I install it ?}
\label{\detokenize{userdoc:how-do-i-install-it}}
\sphinxAtStartPar
toulbar2 is an open source solver distributed under the MIT license as a set of C++ sources managed with git at \sphinxurl{http://github.com/toulbar2/toulbar2}. If you want
to use a released version, then you can download there source archives of a specific release that should be easy to compile on most Linux systems.

\sphinxAtStartPar
If you want to compile the latest sources yourself, you will need a modern C++ compiler, CMake, Gnu MP Bignum library, a recent version of boost libraries and optionally the jemalloc memory management and OpenMPI libraries (for more information, see {\hyperref[\detokenize{_files/README:readme-5}]{\sphinxcrossref{\DUrole{std,std-ref}{Installation from sources}}}}). You can then clone toulbar2 on your machine and compile it by executing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{toulbar2}
\PYG{n}{mkdir} \PYG{n}{build}
\PYG{n}{cd} \PYG{n}{build}
\PYG{c+c1}{\PYGZsh{} ccmake ..}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, toulbar2 is available in the debian\sphinxhyphen{}science section of the unstable/sid Debian version. It should therefore be directly installable using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{toulbar2}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to try toulbar2 on crafted, random, or real problems, please look for benchmarks in the \sphinxhref{http://costfunction.org/en/benchmark}{Cost Function benchmark Section}. Other benchmarks coming from various discrete optimization languages are available at \sphinxhref{http://genoweb.toulouse.inra.fr/~degivry/evalgm}{Genotoul EvalGM} \sphinxcite{userdoc:hurley2016b}.


\section{How do I test it ?}
\label{\detokenize{userdoc:how-do-i-test-it}}
\sphinxAtStartPar
Some problem examples are available in the directory \sphinxstylestrong{toulbar2/validation}. After compilation with cmake, it is possible to run a series of tests using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make} \PYG{n}{test}
\end{sphinxVerbatim}

\sphinxAtStartPar
For debugging toulbar2 (compile with flag \sphinxcode{\sphinxupquote{CMAKE\_BUILD\_TYPE="Debug"}}), more test examples are available at \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library}{Cost Function Library}.
The following commands run toulbar2 (executable must be found on your system path) on every problems with a 1\sphinxhyphen{}hour time limit and compare their optimum with known optima (in .ub files).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{toulbar2}
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{forgemia}\PYG{o}{.}\PYG{n}{inra}\PYG{o}{.}\PYG{n}{fr}\PYG{o}{/}\PYG{n}{thomas}\PYG{o}{.}\PYG{n}{schiex}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{library}\PYG{o}{.}\PYG{n}{git}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{misc}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{runall}\PYG{o}{.}\PYG{n}{sh} \PYG{o}{.}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{library}\PYG{o}{/}\PYG{n}{trunk}\PYG{o}{/}\PYG{n}{validation}
\end{sphinxVerbatim}

\sphinxAtStartPar
Other tests on randomly generated problems can be done where optimal solutions are verified by using an older solver \sphinxhref{https://forgemia.inra.fr/thomas.schiex/toolbar}{toolbar} (executable must be found on your system path).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{toulbar2}
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{forgemia}\PYG{o}{.}\PYG{n}{inra}\PYG{o}{.}\PYG{n}{fr}\PYG{o}{/}\PYG{n}{thomas}\PYG{o}{.}\PYG{n}{schiex}\PYG{o}{/}\PYG{n}{toolbar}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{toolbar}\PYG{o}{/}\PYG{n}{toolbar}
\PYG{n}{make} \PYG{n}{toolbar}
\PYG{n}{cd} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{misc}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{rungenerate}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\section{Using it as a black box}
\label{\detokenize{userdoc:using-it-as-a-black-box}}
\sphinxAtStartPar
Using toulbar2 is just a matter of having a properly formatted input
file describing the cost function network, graphical model, PWMaxSAT,
PBO or Linkage \sphinxstylestrong{.pre} file and executing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{p}{[}\PYG{n}{option} \PYG{n}{parameters}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and toulbar2 will start solving the optimization problem described in its file argument. By default, the extension of the file (either \sphinxstylestrong{.cfn}, \sphinxstylestrong{.cfn.gz}, \sphinxstylestrong{.cfn.bz2}, \sphinxstylestrong{.cfn.xz}, \sphinxstylestrong{.wcsp}, \sphinxstylestrong{.wcsp.gz}, \sphinxstylestrong{.wcsp.bz2}, \sphinxstylestrong{.wcsp.xz}, \sphinxstylestrong{.wcnf}, \sphinxstylestrong{.wcnf.gz}, \sphinxstylestrong{.wcnf.bz2}, \sphinxstylestrong{.wcnf.xz}, \sphinxstylestrong{.cnf}, \sphinxstylestrong{.cnf.gz}, \sphinxstylestrong{.cnf.bz2}, \sphinxstylestrong{.cnf.xz}, \sphinxstylestrong{.qpbo}, \sphinxstylestrong{.qpbo.gz}, \sphinxstylestrong{.qpbo.bz2}, \sphinxstylestrong{.qpbo.xz}, \sphinxstylestrong{.opb}, \sphinxstylestrong{.opb.gz}, \sphinxstylestrong{.opb.bz2}, \sphinxstylestrong{.opb.xz}, \sphinxstylestrong{.uai}, \sphinxstylestrong{.uai.gz}, \sphinxstylestrong{.uai.bz2}, \sphinxstylestrong{.uai.xz}, \sphinxstylestrong{.LG}, \sphinxstylestrong{.LG.gz}, \sphinxstylestrong{.LG.bz2}, \sphinxstylestrong{.LG.xz}, \sphinxstylestrong{.xml}, \sphinxstylestrong{.xml.gz}, \sphinxstylestrong{.xml.bz2}, \sphinxstylestrong{.xml.xz}, \sphinxstylestrong{.pre} or \sphinxstylestrong{.bep}) is used to determine the nature of the file (see {\hyperref[\detokenize{userdoc:input-formats}]{\sphinxcrossref{\DUrole{std,std-ref}{Input formats}}}}).
There is no specific order for the options or problem file. toulbar2 comes with decently optimized default option parameters. It is however often possible to set it up for different target than pure optimization or tune it for faster action using specific command line options.


\section{Quick start}
\label{\detokenize{userdoc:quick-start}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download a binary weighted constraint satisfaction problem (WCSP) file \sphinxcode{\sphinxupquote{example.wcsp.xz}}. Solve it with default options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{68.750}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{5} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{15} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{22.222} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{18} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{18.519} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{21} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{55} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{49} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{122} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{63} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{153} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{81} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{217} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{89} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{240} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{25.417} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{89} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{240} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{460} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.006} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve a WCSP using INCOP, a local search method \sphinxcite{userdoc:idwalk-cp04} applied just after preprocessing, in order to find a good upper bound before a complete search:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{i}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{INCOP} \PYG{n}{solving} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.254} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{25.926}\PYG{o}{\PYGZpc{}}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{22.222} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{8} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{18.519} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{95} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{93} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{209} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{111} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{253} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{121} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{280} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{128} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{307} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{16.612} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{128} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{307} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{647} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.263} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve a WCSP with an initial upper bound and save its (first) optimal solution in filename “example.sol”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{ub}\PYG{o}{=}\PYG{l+m+mi}{28} \PYG{o}{\PYGZhy{}}\PYG{n}{w}\PYG{o}{=}\PYG{n}{example}\PYG{o}{.}\PYG{n}{sol}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{]} \PYG{l+m+mf}{28.571}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{22.222} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{18.519} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{25} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{61} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{56} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{133} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{60} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{148} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{83} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{228} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{89} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{265} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{32.453} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{89} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{265} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{441} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.007} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
… and see this saved “example.sol” file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cat} \PYG{n}{example}\PYG{o}{.}\PYG{n}{sol}
\PYG{c+c1}{\PYGZsh{} each value corresponds to one variable assignment in problem file order}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a larger WCSP file \sphinxcode{\sphinxupquote{scen06.wcsp.xz}}. Solve it using a limited discrepancy search strategy \sphinxcite{userdoc:ginsberg1995} with a VAC integrality\sphinxhyphen{}based variable ordering \sphinxcite{userdoc:trosser2020a} in order to speed\sphinxhyphen{}up the search for finding good upper bounds first (by default, toulbar2 uses another diversification strategy based on hybrid best\sphinxhyphen{}first search \sphinxcite{userdoc:katsirelos2015a}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen06}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{o}{\PYGZhy{}}\PYG{n}{vacint}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{44} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{1222} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000133} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.154752} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{82} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{3273} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{327} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{248338}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7771} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{101} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{101} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{c} \PYG{l+m+mi}{8388608} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5848} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{282} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5384} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{397} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5039} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{466} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4740} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{640} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{738} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4675} \PYG{p}{(}\PYG{l+m+mi}{37} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{966} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4633} \PYG{p}{(}\PYG{l+m+mi}{44} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1113} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4509} \PYG{p}{(}\PYG{l+m+mi}{45} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1165} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4502} \PYG{p}{(}\PYG{l+m+mi}{51} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1226} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4344} \PYG{p}{(}\PYG{l+m+mi}{54} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1291} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4258} \PYG{p}{(}\PYG{l+m+mi}{135} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1864} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4118} \PYG{p}{(}\PYG{l+m+mi}{136} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1907} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4107} \PYG{p}{(}\PYG{l+m+mi}{138} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1965} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4101} \PYG{p}{(}\PYG{l+m+mi}{147} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2040} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4099} \PYG{p}{(}\PYG{l+m+mi}{150} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2057} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4037} \PYG{p}{(}\PYG{l+m+mi}{152} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2080} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3853} \PYG{p}{(}\PYG{l+m+mi}{157} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2171} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3800} \PYG{p}{(}\PYG{l+m+mi}{209} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2475} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3781} \PYG{p}{(}\PYG{l+m+mi}{222} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2539} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3769} \PYG{p}{(}\PYG{l+m+mi}{226} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2559} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3750} \PYG{p}{(}\PYG{l+m+mi}{227} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2568} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3748} \PYG{p}{(}\PYG{l+m+mi}{229} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2575} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{2586} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3615} \PYG{p}{(}\PYG{l+m+mi}{663} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5086} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3614} \PYG{p}{(}\PYG{l+m+mi}{698} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5269} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3599} \PYG{p}{(}\PYG{l+m+mi}{704} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5310} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3594} \PYG{p}{(}\PYG{l+m+mi}{708} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5335} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3591} \PYG{p}{(}\PYG{l+m+mi}{709} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5343} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3580} \PYG{p}{(}\PYG{l+m+mi}{710} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5354} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3578} \PYG{p}{(}\PYG{l+m+mi}{716} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5374} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3551} \PYG{p}{(}\PYG{l+m+mi}{988} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6456} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3539} \PYG{p}{(}\PYG{l+m+mi}{996} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6522} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3516} \PYG{p}{(}\PYG{l+m+mi}{1000} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6554} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3507} \PYG{p}{(}\PYG{l+m+mi}{1002} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6573} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3483} \PYG{p}{(}\PYG{l+m+mi}{1037} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6718} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3464} \PYG{p}{(}\PYG{l+m+mi}{1038} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6739} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3438} \PYG{p}{(}\PYG{l+m+mi}{1047} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3412} \PYG{p}{(}\PYG{l+m+mi}{1049} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6824} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{Search} \PYG{k}{with} \PYG{n}{no} \PYG{n}{discrepancy} \PYG{n}{limit} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{9443} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3404} \PYG{p}{(}\PYG{l+m+mi}{4415} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14613} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{27}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3402} \PYG{p}{(}\PYG{l+m+mi}{4416} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14615} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3400} \PYG{p}{(}\PYG{l+m+mi}{4417} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14619} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{24}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3391} \PYG{p}{(}\PYG{l+m+mi}{4419} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14630} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{28}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3389} \PYG{p}{(}\PYG{l+m+mi}{4420} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14632} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{26}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{97.049} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{21663} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{49099} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{91.148} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{24321} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{54415} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{957}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{71.762} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{37965} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{81703} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1780}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{47.477} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{39060} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{83893} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1999}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{41.015} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{39252} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{84277} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{3389} \PYG{o+ow}{in} \PYG{l+m+mi}{39276} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{84325} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{444857} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{36.293} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a cluster decomposition file \sphinxcode{\sphinxupquote{scen06.dec}} (each line corresponds to a cluster of variables, clusters may overlap). Solve the previous WCSP using a variable neighborhood search algorithm (UDGVNS) \sphinxcite{userdoc:ouali2017} during 10 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen06}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen06}\PYG{o}{.}\PYG{n}{dec} \PYG{o}{\PYGZhy{}}\PYG{n}{vns} \PYG{o}{\PYGZhy{}}\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{44} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{1222} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{9.2e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.152035} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{82} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{3273} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{327} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{248338}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{8388608} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7566} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{109} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{110}\PYG{p}{)}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{55} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{1} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{5} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{4.782} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{12}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{1} \PYG{k}{with} \PYG{l+m+mi}{1} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{7566} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{109} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7555} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{109} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7545} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{111} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7397} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{114} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7289} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7287} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7277} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5274} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5169} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5159} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5158} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5105} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{120} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4767} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{140} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4667} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{140} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4655} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{164} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4588} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{171} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4543} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{172} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4541} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{172} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4424} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4423} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4411} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4401} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4367} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{175} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4175} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4174} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4173} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4171} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4152} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4142} \PYG{p}{(}\PYG{l+m+mi}{12} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{187} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4001} \PYG{p}{(}\PYG{l+m+mi}{43} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{562} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3900} \PYG{p}{(}\PYG{l+m+mi}{43} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{562} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3891} \PYG{p}{(}\PYG{l+m+mi}{78} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{779} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3890} \PYG{p}{(}\PYG{l+m+mi}{80} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{788} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3816} \PYG{p}{(}\PYG{l+m+mi}{130} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1192} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3768} \PYG{p}{(}\PYG{l+m+mi}{137} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1217} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3740} \PYG{p}{(}\PYG{l+m+mi}{205} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1660} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3738} \PYG{p}{(}\PYG{l+m+mi}{205} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1660} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3730} \PYG{p}{(}\PYG{l+m+mi}{229} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1780} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3723} \PYG{p}{(}\PYG{l+m+mi}{230} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1786} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3721} \PYG{p}{(}\PYG{l+m+mi}{230} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1786} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3711} \PYG{p}{(}\PYG{l+m+mi}{236} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1819} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3633} \PYG{p}{(}\PYG{l+m+mi}{239} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1850} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3628} \PYG{p}{(}\PYG{l+m+mi}{245} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1941} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3621} \PYG{p}{(}\PYG{l+m+mi}{245} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1943} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3609} \PYG{p}{(}\PYG{l+m+mi}{245} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1943} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3608} \PYG{p}{(}\PYG{l+m+mi}{411} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3079} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3600} \PYG{p}{(}\PYG{l+m+mi}{518} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3775} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3598} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3597} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3587} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3565} \PYG{p}{(}\PYG{l+m+mi}{534} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3846} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3554} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3856} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3534} \PYG{p}{(}\PYG{l+m+mi}{538} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3860} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3522} \PYG{p}{(}\PYG{l+m+mi}{538} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3861} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3507} \PYG{p}{(}\PYG{l+m+mi}{560} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3987} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3505} \PYG{p}{(}\PYG{l+m+mi}{584} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4130} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3500} \PYG{p}{(}\PYG{l+m+mi}{598} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4255} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3498} \PYG{p}{(}\PYG{l+m+mi}{600} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4281} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3493} \PYG{p}{(}\PYG{l+m+mi}{657} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4648} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{2} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{3493} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{6206} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3492} \PYG{p}{(}\PYG{l+m+mi}{1406} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9011} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{3} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{3492} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{10128} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3389} \PYG{p}{(}\PYG{l+m+mi}{1652} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{10572} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{4} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{3389} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{11566} \PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{Time} \PYG{n}{limit} \PYG{n}{expired}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Aborting}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another difficult instance \sphinxcode{\sphinxupquote{scen07.wcsp.xz}}. Solve it using a variable neighborhood search algorithm (UDGVNS) with maximum cardinality search cluster decomposition and absorption \sphinxcite{userdoc:ouali2017} during 5 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen07}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{vns} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{E} \PYG{o}{\PYGZhy{}}\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{200} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{44} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{2665} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000303} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{10001} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.010}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.351} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{162} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{6481} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{764} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{10001}\PYG{p}{,} \PYG{l+m+mi}{436543501}\PYG{p}{]} \PYG{l+m+mf}{99.998}\PYG{o}{\PYGZpc{}}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{8388608} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1455221} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{233}\PYG{p}{)}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.003} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{25} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{3} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{10} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{10.360} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{38}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{1} \PYG{k}{with} \PYG{l+m+mi}{1} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{1455221} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445522} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445520} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445320} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445319} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1435218} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1425218} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1425217} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1415216} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1405218} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1405216} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{286} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1395016} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{286} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1394815} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{289} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1394716} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{289} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394818} \PYG{p}{(}\PYG{l+m+mi}{13} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{300} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394816} \PYG{p}{(}\PYG{l+m+mi}{13} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{300} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394716} \PYG{p}{(}\PYG{l+m+mi}{15} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{307} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394715} \PYG{p}{(}\PYG{l+m+mi}{26} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{361} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394713} \PYG{p}{(}\PYG{l+m+mi}{26} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{361} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384515} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{379} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384513} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{379} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384313} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{379} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384213} \PYG{p}{(}\PYG{l+m+mi}{33} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{390} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384211} \PYG{p}{(}\PYG{l+m+mi}{33} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{390} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384208} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{426} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384207} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{427} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{364206} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{427} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353705} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{438} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353703} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{443} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353702} \PYG{p}{(}\PYG{l+m+mi}{44} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{450} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353701} \PYG{p}{(}\PYG{l+m+mi}{52} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{482} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343898} \PYG{p}{(}\PYG{l+m+mi}{88} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{705} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343698} \PYG{p}{(}\PYG{l+m+mi}{91} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{717} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343593} \PYG{p}{(}\PYG{l+m+mi}{94} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{726} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{2} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{343593} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1906} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343592} \PYG{p}{(}\PYG{l+m+mi}{319} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2203} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{3} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{343592} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{3467} \PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{Time} \PYG{n}{limit} \PYG{n}{expired}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Aborting}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download file \sphinxcode{\sphinxupquote{404.wcsp.xz}}. Solve it using Depth\sphinxhyphen{}First Brand and Bound with Tree Decomposition and HBFS (BTD\sphinxhyphen{}HBFS) \sphinxcite{userdoc:schiex2006a} based on a min\sphinxhyphen{}fill variable ordering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{404.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{710} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{6.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{64} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{35.938}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{3.030}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{67} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{1.493}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.008} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{88} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{228} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{591} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{155}\PYG{p}{]} \PYG{l+m+mf}{56.774}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{19}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{43}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{47}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.002} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{124} \PYG{p}{(}\PYG{l+m+mi}{20} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{35} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{124}\PYG{p}{]} \PYG{l+m+mf}{43.548} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{20} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{35} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{123} \PYG{p}{(}\PYG{l+m+mi}{34} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{64} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{77}\PYG{p}{,} \PYG{l+m+mi}{123}\PYG{p}{]} \PYG{l+m+mf}{37.398} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{34} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{64} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{119} \PYG{p}{(}\PYG{l+m+mi}{173} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{348} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{88}\PYG{p}{,} \PYG{l+m+mi}{119}\PYG{p}{]} \PYG{l+m+mf}{26.050} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{173} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{348} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{119}\PYG{p}{]} \PYG{l+m+mf}{23.529} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{202} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{442} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{117} \PYG{p}{(}\PYG{l+m+mi}{261} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{609} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{97}\PYG{p}{,} \PYG{l+m+mi}{117}\PYG{p}{]} \PYG{l+m+mf}{17.094} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{261} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{609} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{p}{(}\PYG{l+m+mi}{342} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{858} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{14.035} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{342} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{858} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{12.281} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{373} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{984} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{101}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{11.404} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{437} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1123} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{102}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{10.526} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{446} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1152} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{103}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{9.649} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{484} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1232} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{104}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{8.772} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{521} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1334} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{105}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{7.895} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{521} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1353} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{106}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{7.018} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1364} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{107}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{6.140} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1379} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{109}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{4.386} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{534} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1539} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{111}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{2.632} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1559} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{113}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{0.877} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1564} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1598} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{HBFS} \PYG{n+nb}{open} \PYG{n+nb}{list} \PYG{n}{restarts}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{o+ow}{and} \PYG{n}{reuse}\PYG{p}{:} \PYG{l+m+mf}{11.080} \PYG{o}{\PYGZpc{}} \PYG{n}{of} \PYG{l+m+mi}{352}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{34.355} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{o+ow}{in} \PYG{l+m+mi}{536} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1598} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{21} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.031} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve the same problem using Russian Doll Search exploiting BTD \sphinxcite{userdoc:sanchez2009a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{404.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{710} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{6.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{64} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{35.938}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{3.030}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{67} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{1.493}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.008} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{88} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{228} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{591} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{155}\PYG{p}{]} \PYG{l+m+mf}{56.774}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{19}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{43}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{47}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.002} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{5} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{6} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{7} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{44} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{42} \PYG{p}{(}\PYG{l+m+mi}{420} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{723} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{39} \PYG{p}{(}\PYG{l+m+mi}{431} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{743} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{35} \PYG{p}{(}\PYG{l+m+mi}{447} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{785} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{22}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{35}\PYG{p}{,}\PYG{l+m+mi}{35}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{557} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{960} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{46} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{p}{(}\PYG{l+m+mi}{557} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{960} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{,}\PYG{l+m+mi}{114}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{557} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{960} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{o+ow}{in} \PYG{l+m+mi}{557} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{960} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{50} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.026} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve another WCSP using the original Russian Doll Search method \sphinxcite{userdoc:verfaillie1996} with static variable ordering (following problem file) and soft arc consistency:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{505.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{svo} \PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{240} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{2242} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000911} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.013967} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{233} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{666} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{1966} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{34347}\PYG{p}{]} \PYG{l+m+mf}{99.994}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{59}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{233}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{239}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.017} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{0} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{1} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{2} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{3} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{p}{(}\PYG{l+m+mi}{26963} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48851} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21251} \PYG{p}{(}\PYG{l+m+mi}{26991} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{21251}\PYG{p}{,}\PYG{l+m+mi}{21251}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{26992} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{238} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{p}{(}\PYG{l+m+mi}{26992} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{21253}\PYG{p}{,}\PYG{l+m+mi}{21253}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{26992} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{o+ow}{in} \PYG{l+m+mi}{26992} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{48883} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{6.180} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve the same WCSP using a parallel variable neighborhood search algorithm (UPDGVNS) with min\sphinxhyphen{}fill cluster decomposition \sphinxcite{userdoc:ouali2017} using 4 cores during 5 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{4} \PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{505.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{vns} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{240} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{2242} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.002201} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{11120} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{81.403}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{11128} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.072}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.079} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{233} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{666} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{1966} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{11128}\PYG{p}{,} \PYG{l+m+mi}{34354}\PYG{p}{]} \PYG{l+m+mf}{67.608}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.017} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{89} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{4} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{11} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{11.831} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{23}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{26266} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{59} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{60}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{26265} \PYG{o+ow}{in} \PYG{l+m+mf}{0.038} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{26264} \PYG{o+ow}{in} \PYG{l+m+mf}{0.046} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{25266} \PYG{o+ow}{in} \PYG{l+m+mf}{0.047} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{25265} \PYG{o+ow}{in} \PYG{l+m+mf}{0.060} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{25260} \PYG{o+ow}{in} \PYG{l+m+mf}{0.071} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{24262} \PYG{o+ow}{in} \PYG{l+m+mf}{0.080} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{23262} \PYG{o+ow}{in} \PYG{l+m+mf}{0.090} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{23260} \PYG{o+ow}{in} \PYG{l+m+mf}{0.098} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{23259} \PYG{o+ow}{in} \PYG{l+m+mf}{0.108} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22262} \PYG{o+ow}{in} \PYG{l+m+mf}{0.108} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22261} \PYG{o+ow}{in} \PYG{l+m+mf}{0.110} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22260} \PYG{o+ow}{in} \PYG{l+m+mf}{0.113} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22259} \PYG{o+ow}{in} \PYG{l+m+mf}{0.118} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22258} \PYG{o+ow}{in} \PYG{l+m+mf}{0.128} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22257} \PYG{o+ow}{in} \PYG{l+m+mf}{0.138} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22255} \PYG{o+ow}{in} \PYG{l+m+mf}{0.154} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22254} \PYG{o+ow}{in} \PYG{l+m+mf}{0.170} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22252} \PYG{o+ow}{in} \PYG{l+m+mf}{0.206} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21257} \PYG{o+ow}{in} \PYG{l+m+mf}{0.227} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21256} \PYG{o+ow}{in} \PYG{l+m+mf}{0.256} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21254} \PYG{o+ow}{in} \PYG{l+m+mf}{0.380} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{o+ow}{in} \PYG{l+m+mf}{0.478} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{MPI\PYGZus{}ABORT} \PYG{n}{was} \PYG{n}{invoked} \PYG{n}{on} \PYG{n}{rank} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{communicator} \PYG{n}{MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{k}{with} \PYG{n}{errorcode} \PYG{l+m+mf}{0.}

\PYG{n}{NOTE}\PYG{p}{:} \PYG{n}{invoking} \PYG{n}{MPI\PYGZus{}ABORT} \PYG{n}{causes} \PYG{n}{Open} \PYG{n}{MPI} \PYG{n}{to} \PYG{n}{kill} \PYG{n+nb}{all} \PYG{n}{MPI} \PYG{n}{processes}\PYG{o}{.}
\PYG{n}{You} \PYG{n}{may} \PYG{o+ow}{or} \PYG{n}{may} \PYG{o+ow}{not} \PYG{n}{see} \PYG{n}{output} \PYG{k+kn}{from} \PYG{n+nn}{other} \PYG{n}{processes}\PYG{p}{,} \PYG{n}{depending} \PYG{n}{on}
\PYG{n}{exactly} \PYG{n}{when} \PYG{n}{Open} \PYG{n}{MPI} \PYG{n}{kills} \PYG{n}{them}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}

\PYG{n}{Time} \PYG{n}{limit} \PYG{n}{expired}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Aborting}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a cluster decomposition file \sphinxcode{\sphinxupquote{example.dec}} (each line corresponds to a cluster of variables, clusters may overlap). Solve a WCSP using a variable neighborhood search algorithm (UDGVNS) with a given cluster decomposition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{dec} \PYG{o}{\PYGZhy{}}\PYG{n}{vns}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{68.750}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{7} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{11} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{15} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{15.143} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{17}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{1} \PYG{k}{with} \PYG{l+m+mi}{1} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{28} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{2} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{57} \PYG{n}{nodes}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{3} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{143} \PYG{n}{nodes}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{4} \PYG{k}{with} \PYG{l+m+mi}{8} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{418} \PYG{n}{nodes}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{5} \PYG{k}{with} \PYG{l+m+mi}{16} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{846} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{521} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1156} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{3066} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.039} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve a WCSP using a parallel variable neighborhood search algorithm (UPDGVNS) with the same cluster decomposition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{4} \PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{dec} \PYG{o}{\PYGZhy{}}\PYG{n}{vns}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{2.7e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.002} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{68.750}\PYG{o}{\PYGZpc{}}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{7} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{11} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{15} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{15.143} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{17}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{0} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{7} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{36} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.064} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Total} \PYG{n}{CPU} \PYG{n}{time} \PYG{o}{=} \PYG{l+m+mf}{0.288} \PYG{n}{seconds}
\PYG{n}{Solving} \PYG{n}{real}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mf}{0.071} \PYG{n}{seconds} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{including} \PYG{n}{preprocessing} \PYG{n}{time}\PYG{p}{)}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download file \sphinxcode{\sphinxupquote{example.order}}. Solve a WCSP using BTD\sphinxhyphen{}HBFS based on a given (min\sphinxhyphen{}fill) reverse variable elimination ordering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{order} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.5e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{21} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{4.762}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{67.188}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{8}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{16}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{18}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{29} \PYG{p}{(}\PYG{l+m+mi}{19} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{30} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{37} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{62} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{]} \PYG{l+m+mf}{21.429} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{37} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{62} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{]} \PYG{l+m+mf}{17.857} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{309} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{629} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{328} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{672} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{328} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{672} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{347} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{724} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{372} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{819} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{3.704} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{372} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{829} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{372} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{873} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{HBFS} \PYG{n+nb}{open} \PYG{n+nb}{list} \PYG{n}{restarts}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{o+ow}{and} \PYG{n}{reuse}\PYG{p}{:} \PYG{l+m+mf}{10.769} \PYG{o}{\PYGZpc{}} \PYG{n}{of} \PYG{l+m+mi}{65}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{16.724} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{372} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{873} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{463} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.020} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download file \sphinxcode{\sphinxupquote{example.cov}}. Solve a WCSP using BTD\sphinxhyphen{}HBFS based on a given explicit (min\sphinxhyphen{}fill path\sphinxhyphen{}) tree\sphinxhyphen{}decomposition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{cov} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Read 25 variables, with 5 values at most, and 63 cost functions, with maximum arity 2.
Warning! Cannot apply variable elimination during search with a given tree decomposition file.
Warning! Cannot apply functional variable elimination with a given tree decomposition file.
Cost function decomposition time : 1.6e\PYGZhy{}05 seconds.
Reverse DAC dual bound: 20 (+15.000\PYGZpc{})
Reverse DAC dual bound: 22 (+9.091\PYGZpc{})
Preprocessing time: 0.001 seconds.
25 unassigned variables, 120 values in all current domains (med. size:5, max size:5) and 63 non\PYGZhy{}unary cost functions (med. arity:2, med. degree:5)
Initial lower and upper bounds: [22, 64] 65.625\PYGZpc{}
Tree decomposition width  : 16
Tree decomposition height : 24
Number of clusters         : 9
Tree decomposition time: 0.000 seconds.
New solution: 29 (23 backtracks, 29 nodes, depth 3)
New solution: 28 (32 backtracks, 46 nodes, depth 3)
Optimality gap: [23, 28] 17.857 \PYGZpc{} (37 backtracks, 58 nodes)
New solution: 27 (61 backtracks, 122 nodes, depth 3)
Optimality gap: [23, 27] 14.815 \PYGZpc{} (61 backtracks, 122 nodes)
Optimality gap: [24, 27] 11.111 \PYGZpc{} (132 backtracks, 269 nodes)
Optimality gap: [25, 27] 7.407 \PYGZpc{} (177 backtracks, 395 nodes)
Optimality gap: [26, 27] 3.704 \PYGZpc{} (189 backtracks, 467 nodes)
Optimality gap: [27, 27] 0.000 \PYGZpc{} (189 backtracks, 482 nodes)
HBFS open list restarts: 0.000 \PYGZpc{} and reuse: 25.926 \PYGZpc{} of 27
Node redundancy during HBFS: 25.519 \PYGZpc{}
Optimum: 27 in 189 backtracks and 482 nodes ( 95 removals by DEE) and 0.010 seconds.
end.
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a Markov Random Field (MRF) file \sphinxcode{\sphinxupquote{pedigree9.uai.xz}} in UAI format. Solve it using bounded (of degree at most 8) variable elimination enhanced by cost function decomposition in preprocessing \sphinxcite{userdoc:favier2011a} followed by BTD\sphinxhyphen{}HBFS exploiting only small\sphinxhyphen{}size (less than four variables) separators:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{pedigree9}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{1118} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{7} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{1118} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{4.}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file} \PYG{n}{specified}\PYG{o}{.} \PYG{n}{Trying} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{pedigree9}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz}\PYG{o}{.}\PYG{n}{evid}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Generic} \PYG{n}{variable} \PYG{n}{elimination} \PYG{n}{of} \PYG{n}{degree} \PYG{l+m+mi}{4}
\PYG{n}{Maximum} \PYG{n}{degree} \PYG{n}{of} \PYG{n}{generic} \PYG{n}{variable} \PYG{n}{elimination}\PYG{p}{:} \PYG{l+m+mi}{4}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.003733} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.073664} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{232} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{517} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{415} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{553902779}\PYG{p}{,} \PYG{l+m+mi}{13246577453}\PYG{p}{]} \PYG{l+m+mf}{95.819}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{227}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{230}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{890}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.047} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{865165767} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{298.395} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{2.564e\PYGZhy{}130} \PYG{p}{(}\PYG{l+m+mi}{72} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{140} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{844685630} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{296.347} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.987e\PYGZhy{}129} \PYG{p}{(}\PYG{l+m+mi}{128} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{254} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{822713386} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{294.149} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.789e\PYGZhy{}128} \PYG{p}{(}\PYG{l+m+mi}{188} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{373} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{809800912} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{292.858} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{6.506e\PYGZhy{}128} \PYG{p}{(}\PYG{l+m+mi}{327} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{665} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{769281277} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{288.806} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{3.742e\PYGZhy{}126} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{771} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{755317979} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{287.410} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.512e\PYGZhy{}125} \PYG{p}{(}\PYG{l+m+mi}{714} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1549} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{755129381} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{287.391} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.540e\PYGZhy{}125} \PYG{p}{(}\PYG{l+m+mi}{927} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2038} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{711184893} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{282.997} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.248e\PYGZhy{}123} \PYG{p}{(}\PYG{l+m+mi}{1249} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2685} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{HBFS} \PYG{n+nb}{open} \PYG{n+nb}{list} \PYG{n}{restarts}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{o+ow}{and} \PYG{n}{reuse}\PYG{p}{:} \PYG{l+m+mf}{39.620} \PYG{o}{\PYGZpc{}} \PYG{n}{of} \PYG{l+m+mi}{1474}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{22.653} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{711184893} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{282.997} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.248e\PYGZhy{}123} \PYG{o+ow}{in} \PYG{l+m+mi}{21719} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{56124} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{72435} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{4.310} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another MRF file \sphinxcode{\sphinxupquote{GeomSurf\sphinxhyphen{}7\sphinxhyphen{}gm256.uai.xz}}. Solve it using Virtual Arc Consistency (VAC) in preprocessing \sphinxcite{userdoc:cooper2008} and exploit a VAC\sphinxhyphen{}based value \sphinxcite{userdoc:cooper2010a} and variable \sphinxcite{userdoc:trosser2020a} ordering heuristics:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GeomSurf}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{n}{gm256}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{o}{\PYGZhy{}}\PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{n}{vacint}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{787} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{7} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{3527} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file} \PYG{n}{specified}\PYG{o}{.} \PYG{n}{Trying} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GeomSurf}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{n}{gm256}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz}\PYG{o}{.}\PYG{n}{evid}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.001227} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{5879065363} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1074.088} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.082}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{VAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{5906374927} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1076.819} \PYG{p}{(}\PYG{n+nb}{iter}\PYG{p}{:}\PYG{l+m+mi}{486}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{726}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{240} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{234}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{1.872} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{729} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{4819} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{3128} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5906374927}\PYG{p}{,} \PYG{l+m+mi}{111615200815}\PYG{p}{]} \PYG{l+m+mf}{94.708}\PYG{o}{\PYGZpc{}}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5968997522} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1083.081} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{4.204e\PYGZhy{}471} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{19} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{21}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5920086558}\PYG{p}{,} \PYG{l+m+mi}{5968997522}\PYG{p}{]} \PYG{l+m+mf}{0.819} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{17} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{36} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5922481881} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1078.430} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{4.404e\PYGZhy{}469} \PYG{p}{(}\PYG{l+m+mi}{17} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5922481881}\PYG{p}{,} \PYG{l+m+mi}{5922481881}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{21} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{52} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{846}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{360} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{351}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{11.538} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{5922481881} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1078.430} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{4.404e\PYGZhy{}469} \PYG{o+ow}{in} \PYG{l+m+mi}{21} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{52} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{2749} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.980} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another MRF file \sphinxcode{\sphinxupquote{1CM1.uai.xz}}. Solve it by applying first an initial upper bound probing, and secondly, use a modified variable ordering heuristic based on VAC\sphinxhyphen{}integrality during search \sphinxcite{userdoc:trosser2020a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{n}{CM1}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{o}{=}\PYG{l+m+mi}{1000} \PYG{o}{\PYGZhy{}}\PYG{n}{vacint} \PYG{o}{\PYGZhy{}}\PYG{n}{rasps} \PYG{o}{\PYGZhy{}}\PYG{n}{vacthr}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{37} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{350} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{703} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file} \PYG{n}{specified}\PYG{o}{.} \PYG{n}{Trying} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{n}{CM1}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz}\PYG{o}{.}\PYG{n}{evid}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000679} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{103988236701} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12486.138} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{VAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{103988236701} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12486.138} \PYG{p}{(}\PYG{n+nb}{iter}\PYG{p}{:}\PYG{l+m+mi}{4068}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{4389}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{189} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{186}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{2326139858} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{2320178814} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{21288438} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{19} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{11823689} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{8187968} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{21} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6858739} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{22} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6058812} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{22} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{5504560} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{22} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3972336} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{23} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000002}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3655432} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{23} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000002}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3067825} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{23} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000002}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{2174446} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000003}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1641827} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000004}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1376213} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000005}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{208082} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000031}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{104041} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{26} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000068}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{52020} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000140}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{26010} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000281}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{13005} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000561}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6502} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0001122}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3251} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0002245}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1625} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0004491}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{812} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0008987}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{406} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0017974}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{203} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0035947}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{101} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0072250}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{50} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0145946}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{25} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0291892}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{12} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0608108}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.1216216}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.2432432}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.7297297}
\PYG{n}{RASPS}\PYG{o}{/}\PYG{n}{VAC} \PYG{n}{threshold}\PYG{p}{:} \PYG{l+m+mi}{203}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{41.340} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{37} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{3366} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{38}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{331}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{626} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{35}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{103988236701}\PYG{p}{,} \PYG{l+m+mi}{239074057808}\PYG{p}{]} \PYG{l+m+mf}{56.504}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{104206588216} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12464.303} \PYG{n}{prob}\PYG{p}{:} \PYG{n}{inf} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{RASPS} \PYG{n}{done} \PYG{o+ow}{in} \PYG{n}{preprocessing} \PYG{p}{(}\PYG{n}{backtrack}\PYG{p}{:} \PYG{l+m+mi}{4} \PYG{n}{nodes}\PYG{p}{:} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{104174014744} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12467.560} \PYG{n}{prob}\PYG{p}{:} \PYG{n}{inf} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{12} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{104174014744}\PYG{p}{,} \PYG{l+m+mi}{104174014744}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{7} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{15} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{4695}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{458} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{451}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{104174014744} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12467.560} \PYG{n}{prob}\PYG{p}{:} \PYG{n}{inf} \PYG{o+ow}{in} \PYG{l+m+mi}{7} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{15} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{937} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{41.354} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a weighted Max\sphinxhyphen{}SAT file \sphinxcode{\sphinxupquote{brock200\_4.clq.wcnf.xz}} in wcnf format. Solve it using a modified variable ordering heuristic \sphinxcite{userdoc:schiex2014a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{brock200\PYGZus{}4}\PYG{o}{.}\PYG{n}{clq}\PYG{o}{.}\PYG{n}{wcnf}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c} \PYG{n}{Read} \PYG{l+m+mi}{200} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{7011} \PYG{n}{clauses}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000485} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{91} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{86.813}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{92} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{1.087}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.040} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{200} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{400} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{6811} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{68}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{92}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{]} \PYG{l+m+mf}{54.000}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{189} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{188} \PYG{p}{(}\PYG{l+m+mi}{45} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{143} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{37}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{187} \PYG{p}{(}\PYG{l+m+mi}{155} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{473} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{47}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{186} \PYG{p}{(}\PYG{l+m+mi}{892} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2247} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{19}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{185} \PYG{p}{(}\PYG{l+m+mi}{3874} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{8393} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{70}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{184} \PYG{p}{(}\PYG{l+m+mi}{29475} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{62393} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{40}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{183} \PYG{p}{(}\PYG{l+m+mi}{221446} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{522724} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{37.221} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{183} \PYG{o+ow}{in} \PYG{l+m+mi}{281307} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{896184} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{9478} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{25.977} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another WCSP file \sphinxcode{\sphinxupquote{latin4.wcsp.xz}}. Count the number of feasible solutions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{latin4}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{a}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{16} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{24} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{4.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{2e\PYGZhy{}06} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{2.083}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.006} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{16} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{64} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{8} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{48}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{95.200}\PYG{o}{\PYGZpc{}}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{95.100} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{17} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{41} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{58}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{94.200} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{355} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{812} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{72}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{92.800} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{575} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1309} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{575} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1318} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}    \PYG{p}{:} \PYG{o}{=}  \PYG{l+m+mi}{576}
\PYG{n}{Time}                   \PYG{p}{:}    \PYG{l+m+mf}{0.306} \PYG{n}{seconds}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o+ow}{in} \PYG{l+m+mi}{575} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1318} \PYG{n}{nodes}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Find a greedy sequence of at most 20 diverse solutions with Hamming distance greater than 12 between any pair of solutions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{latin4}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{20} \PYG{o}{\PYGZhy{}}\PYG{n}{div}\PYG{o}{=}\PYG{l+m+mi}{12}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{16} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{24} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{4.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{3e\PYGZhy{}06} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{2.083}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.009} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{320} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{7968} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{8} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{48}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{95.200}\PYG{o}{\PYGZpc{}}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{1} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{49} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{11} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{18.182} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{o+ow}{in} \PYG{l+m+mi}{2} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{11} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.017} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{2} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{52} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{879} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{871}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{5} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{882} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{51} \PYG{p}{(}\PYG{l+m+mi}{5} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1748} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{868}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{51}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.922} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1749} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{0.172} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{51} \PYG{o+ow}{in} \PYG{l+m+mi}{6} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1749} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.046} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{3} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2569} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{823}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{62} \PYG{p}{(}\PYG{l+m+mi}{14} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3407} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{824}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{p}{(}\PYG{l+m+mi}{21} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4245} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{821}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.547} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{29} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4270} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12.500} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4276} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{57}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{14.035} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{31} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4292} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{57} \PYG{p}{(}\PYG{l+m+mi}{31} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5114} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{819}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{1.017} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{57} \PYG{o+ow}{in} \PYG{l+m+mi}{31} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{5114} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.146} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{4} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{73} \PYG{p}{(}\PYG{l+m+mi}{44} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5923} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{773}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{46} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6702} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{778}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{p}{(}\PYG{l+m+mi}{53} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7485} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{773}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{58}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.517} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{70} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7584} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{1.846} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{o+ow}{in} \PYG{l+m+mi}{70} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{7584} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.256} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{5} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{70} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{8307} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{726}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{p}{(}\PYG{l+m+mi}{100} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9139} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{728}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{l+m+mi}{112} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9896} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{724}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{64} \PYG{p}{(}\PYG{l+m+mi}{116} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{10636} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{725}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{p}{(}\PYG{l+m+mi}{171} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{11654} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{725}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{3.484} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{o+ow}{in} \PYG{l+m+mi}{171} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{11654} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.474} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{6} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{178} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{12347} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{677}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{207} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{13102} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{677}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{p}{(}\PYG{l+m+mi}{212} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{13804} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{680}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{16.949} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{251} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14053} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.333} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{256} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14093} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{19.672} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{259} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14126} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20.968} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{260} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14165} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{62} \PYG{p}{(}\PYG{l+m+mi}{260} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14849} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{675}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{4.936} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{62} \PYG{o+ow}{in} \PYG{l+m+mi}{260} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{14849} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.688} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{7} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{77} \PYG{p}{(}\PYG{l+m+mi}{267} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{15495} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{630}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{283} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{16160} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{629}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{75} \PYG{p}{(}\PYG{l+m+mi}{334} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{16982} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{628}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{335} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{17615} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{628}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{23.438} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{17946} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{18577} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{627}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{65}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{24.615} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{18581} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{5.915} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{o+ow}{in} \PYG{l+m+mi}{383} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{18581} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.963} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{8} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{81} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{19161} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{583}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{425} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{19865} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{583}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{69} \PYG{p}{(}\PYG{l+m+mi}{471} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{20646} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{585}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{479} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{21273} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{581}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{p}{(}\PYG{l+m+mi}{483} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{21881} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{580}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{6.014} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{o+ow}{in} \PYG{l+m+mi}{483} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{21881} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.175} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{9} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{483} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{22413} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{535}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{66}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{25.758} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{581} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{22902} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{l+m+mi}{581} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{23434} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{531}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{6.900} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{o+ow}{in} \PYG{l+m+mi}{581} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{23434} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.379} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{10} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{619} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24035} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{484}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{26.866} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{686} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24436} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{68}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{27.941} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{686} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24444} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{7.924} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{o+ow}{in} \PYG{l+m+mi}{686} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{24444} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.597} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{11} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{714} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24958} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{436}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{739} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{25534} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{436}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{8.052} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{o+ow}{in} \PYG{l+m+mi}{739} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{25534} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.712} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{12} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{81} \PYG{p}{(}\PYG{l+m+mi}{770} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{26006} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{p}{(}\PYG{l+m+mi}{772} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{26399} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{77} \PYG{p}{(}\PYG{l+m+mi}{779} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{26818} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{809} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{27354} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{390}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{858} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28065} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{69}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{28.986} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{863} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28122} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{30.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{864} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28130} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{71}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{30.986} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{864} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28140} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{71} \PYG{p}{(}\PYG{l+m+mi}{864} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28532} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{387}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{8.762} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{71} \PYG{o+ow}{in} \PYG{l+m+mi}{864} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{28532} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.981} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{13} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{898} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28974} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{343}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{906} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{29334} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{340}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{72}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{31.944} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{979} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{29782} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.563} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{o+ow}{in} \PYG{l+m+mi}{979} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{29782} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.212} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{14} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{86} \PYG{p}{(}\PYG{l+m+mi}{1062} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{30429} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{292}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1078} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{30768} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{292}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{p}{(}\PYG{l+m+mi}{1085} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31080} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{292}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{74}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{33.784} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1102} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31203} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{10.124} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{o+ow}{in} \PYG{l+m+mi}{1102} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{31203} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.441} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{15} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{1103} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31448} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{246}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{p}{(}\PYG{l+m+mi}{1122} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31726} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{246}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{1183} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32087} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{245}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{76}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{35.526} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1231} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32181} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.816} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{o+ow}{in} \PYG{l+m+mi}{1231} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{32181} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.603} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{16} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1253} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32419} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{197}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{1315} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32735} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{197}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{p}{(}\PYG{l+m+mi}{1336} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32968} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{196}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{78}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{37.179} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1349} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32993} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.575} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{o+ow}{in} \PYG{l+m+mi}{1349} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{32993} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.760} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{17} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1349} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33141} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{151}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{1374} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33334} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{149}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{37.975} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1474} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33532} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.421} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{o+ow}{in} \PYG{l+m+mi}{1474} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{33532} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.924} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{18} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1546} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33775} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{102}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{38.750} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1592} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33864} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.328} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{o+ow}{in} \PYG{l+m+mi}{1592} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{33864} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{3.085} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{19} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1687} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{34105} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{54}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.263} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{o+ow}{in} \PYG{l+m+mi}{1687} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{34105} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{3.219} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{20} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{95.100} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1809} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{34349} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.197} \PYG{o}{\PYGZpc{}}
\PYG{n}{No} \PYG{n}{solution} \PYG{o+ow}{in} \PYG{l+m+mi}{1809} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{34349} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{3.377} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a crisp CSP file \sphinxcode{\sphinxupquote{GEOM40\_6.wcsp.xz}} (initial upper bound equal to 1). Count the number of solutions using \#BTD \sphinxcite{userdoc:favier2009a} using a min\sphinxhyphen{}fill variable ordering (warning, cannot use BTD to find all solutions in optimization):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GEOM40\PYGZus{}6}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{ub}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{hbfs}\PYG{p}{:}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{40} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{6} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.1e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001019} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{40} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{240} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{5}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{20}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{29}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}    \PYG{p}{:} \PYG{o}{=}  \PYG{l+m+mi}{411110802705928379432960}
\PYG{n}{Number} \PYG{n}{of} \PYG{c+c1}{\PYGZsh{}goods       :    3993}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{used} \PYG{c+c1}{\PYGZsh{}goods  :    17190}
\PYG{n}{Size} \PYG{n}{of} \PYG{n}{sep}            \PYG{p}{:}    \PYG{l+m+mi}{4}
\PYG{n}{Time}                   \PYG{p}{:}    \PYG{l+m+mf}{0.055} \PYG{n}{seconds}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o+ow}{in} \PYG{l+m+mi}{13689} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{27378} \PYG{n}{nodes}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Get a quick approximation of the number of solutions of a CSP with Approx\#BTD \sphinxcite{userdoc:favier2009a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GEOM40\PYGZus{}6}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{o}{\PYGZhy{}}\PYG{n}{ub}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{hbfs}\PYG{p}{:}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{40} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{6} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{9e\PYGZhy{}06} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.000997} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{40} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{240} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}

\PYG{n}{part} \PYG{l+m+mi}{1} \PYG{p}{:} \PYG{l+m+mi}{40} \PYG{n}{variables} \PYG{o+ow}{and} \PYG{l+m+mi}{71} \PYG{n}{constraints} \PYG{p}{(}\PYG{n}{really} \PYG{n}{added}\PYG{p}{)}
\PYG{n}{part} \PYG{l+m+mi}{2} \PYG{p}{:} \PYG{l+m+mi}{10} \PYG{n}{variables} \PYG{o+ow}{and} \PYG{l+m+mi}{7} \PYG{n}{constraints} \PYG{p}{(}\PYG{n}{really} \PYG{n}{added}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{number} \PYG{n}{of} \PYG{n}{parts} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{n}{seconds}\PYG{o}{.}

\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{5}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{17}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{33}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}

\PYG{n}{Cartesian} \PYG{n}{product}                  \PYG{p}{:}    \PYG{l+m+mi}{13367494538843734031554962259968}
\PYG{n}{Upper} \PYG{n}{bound} \PYG{n}{of} \PYG{n}{number} \PYG{n}{of} \PYG{n}{solutions} \PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1719926784000000000000000}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}    \PYG{p}{:} \PYG{o}{\PYGZti{}}\PYG{o}{=} \PYG{l+m+mi}{480000000000000000000000}
\PYG{n}{Number} \PYG{n}{of} \PYG{c+c1}{\PYGZsh{}goods       :    468}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{used} \PYG{c+c1}{\PYGZsh{}goods  :    4788}
\PYG{n}{Size} \PYG{n}{of} \PYG{n}{sep}            \PYG{p}{:}    \PYG{l+m+mi}{3}
\PYG{n}{Time}                   \PYG{p}{:}    \PYG{l+m+mf}{0.011} \PYG{n}{seconds}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o+ow}{in} \PYG{l+m+mi}{3738} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{7476} \PYG{n}{nodes}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\end{itemize}


\section{Command line options}
\label{\detokenize{userdoc:command-line-options}}
\sphinxAtStartPar
If you just execute:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2}
\end{sphinxVerbatim}

\sphinxAtStartPar
toulbar2 will give you its (long) list of optional parameters, that you can
see in part \sphinxstyleemphasis{‘Available options’} of :
\sphinxcode{\sphinxupquote{ToulBar2 Help Message}}.

\sphinxAtStartPar
To deactivate a default command line option, just use the command\sphinxhyphen{}line option
followed by \sphinxcode{\sphinxupquote{:}}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{o}{\PYGZhy{}}\PYG{n}{dee}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
will disable the default Dead End Elimination \sphinxcite{userdoc:givry2013a} (aka Soft
Neighborhood Substitutability) preprocessing.

\sphinxAtStartPar
We now describe in more detail toulbar2 optional parameters.


\subsection{General control}
\label{\detokenize{userdoc:general-control}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}agap={[}decimal{]}}
\sphinxAtStartPar
stops search if the absolute optimality gap reduces below the given value (provides guaranteed approximation) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}rgap={[}double{]}}
\sphinxAtStartPar
stops search if the relative optimality gap reduces below the given value (provides guaranteed approximation) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}a={[}integer{]}}
\sphinxAtStartPar
finds at most a given number of solutions with a cost strictly lower than the initial upper bound and stops, or if no integer is given, finds all solutions (or counts the number of zero\sphinxhyphen{}cost satisfiable solutions in conjunction with BTD)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}D]  
\sphinxAtStartPar
approximate satisfiable solution count with BTD
\item [\sphinxhyphen{}logz]  
\sphinxAtStartPar
computes log of probability of evidence (i.e. log partition function or log(Z) or PR task) for graphical models only (problem file extension .uai)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}timer={[}integer{]}}
\sphinxAtStartPar
gives a CPU time limit in seconds. toulbar2 will stop after the specified CPU time has been consumed. The time limit is a CPU user time limit, not wall clock time limit.

\sphinxlineitem{\sphinxhyphen{}bt={[}integer{]}}
\sphinxAtStartPar
gives a limit on the number of backtracks (\(9223372036854775807\) by default)

\sphinxlineitem{\sphinxhyphen{}seed={[}integer{]}}
\sphinxAtStartPar
random seed non\sphinxhyphen{}negative value or use current time if a negative value is given (default value is 1)

\end{description}


\subsection{Preprocessing}
\label{\detokenize{userdoc:preprocessing}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}nopre]  
\sphinxAtStartPar
deactivates all preprocessing options (equivalent to \sphinxhyphen{}e:
\sphinxhyphen{}p: \sphinxhyphen{}t: \sphinxhyphen{}f: \sphinxhyphen{}dec: \sphinxhyphen{}n: \sphinxhyphen{}mst: \sphinxhyphen{}dee: \sphinxhyphen{}trws:)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}p={[}integer{]}}
\sphinxAtStartPar
preprocessing only: general variable elimination
of degree less than or equal to the given value (default value is \sphinxhyphen{}1)

\sphinxlineitem{\sphinxhyphen{}t={[}integer{]}}
\sphinxAtStartPar
preprocessing only: simulates restricted path
consistency by adding ternary cost functions on triangles of binary
cost functions within a given maximum space limit (in MB)

\sphinxlineitem{\sphinxhyphen{}f={[}integer{]}}
\sphinxAtStartPar
preprocessing only: variable elimination of
functional (f=1) (resp. bijective (f=2)) variables (default value is 1)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}dec]  
\sphinxAtStartPar
preprocessing only: pairwise decomposition \sphinxcite{userdoc:favier2011a} of cost
functions with arity \(>=3\) into smaller arity cost functions
(default option)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}n={[}integer{]}}
\sphinxAtStartPar
preprocessing only: projects n\sphinxhyphen{}ary cost functions
on all binary cost functions if n is lower than the given value
(default value is 10). See \sphinxcite{userdoc:favier2011a}.

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}amo]  
\sphinxAtStartPar
automatically detects at\sphinxhyphen{}most\sphinxhyphen{}one constraints and adds them to existing
knapsack/linear/pseudo\sphinxhyphen{}boolean constraints.
\item [\sphinxhyphen{}mst]  
\sphinxAtStartPar
find a maximum spanning tree ordering for DAC
\item [\sphinxhyphen{}S]  
\sphinxAtStartPar
preprocessing only: performs singleton consistency (only in
conjunction with option \sphinxhyphen{}A)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}M={[}integer{]}}
\sphinxAtStartPar
preprocessing only:
apply the Min Sum Diffusion algorithm (default is inactivated, with
a number of iterations of 0). See \sphinxcite{userdoc:cooper2010a}.

\sphinxlineitem{\sphinxhyphen{}trws={[}float{]}}
\sphinxAtStartPar
preprocessing only: enforces TRW\sphinxhyphen{}S until a given precision is reached
(default value is 0.001). See Kolmogorov 2006.

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}\sphinxhyphen{}trws\sphinxhyphen{}order]  
\sphinxAtStartPar
replaces DAC order by Kolmogorov’s TRW\sphinxhyphen{}S order.
\end{optionlist}
\begin{description}
\sphinxlineitem{\textendash{}trws\sphinxhyphen{}n\sphinxhyphen{}iters={[}integer{]}}
\sphinxAtStartPar
enforce at most N iterations of TRW\sphinxhyphen{}S (default value is 1000).

\sphinxlineitem{\textendash{}trws\sphinxhyphen{}n\sphinxhyphen{}iters\sphinxhyphen{}no\sphinxhyphen{}change={[}integer{]}}
\sphinxAtStartPar
stop TRW\sphinxhyphen{}S when N iterations did not change the lower bound up the given precision (default value is 5, \sphinxhyphen{}1=never).

\sphinxlineitem{\textendash{}trws\sphinxhyphen{}n\sphinxhyphen{}iters\sphinxhyphen{}compute\sphinxhyphen{}ub={[}integer{]}}
\sphinxAtStartPar
compute a basic upper bound every N steps during TRW\sphinxhyphen{}S (default value is 100)

\end{description}


\subsection{Initial upper bounding}
\label{\detokenize{userdoc:initial-upper-bounding}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}l={[}integer{]}}
\sphinxAtStartPar
limited discrepancy search \sphinxcite{userdoc:ginsberg1995}, use a negative value to stop the search after the given absolute number of discrepancies has been explored (discrepancy bound = 4 by default)

\sphinxlineitem{\sphinxhyphen{}L={[}integer{]}}
\sphinxAtStartPar
randomized (quasi\sphinxhyphen{}random variable ordering) search with restart (maximum number of nodes/VNS restarts = 10000 by default)

\sphinxlineitem{\sphinxhyphen{}i={[}“string”{]}}
\sphinxAtStartPar
initial upper bound found by INCOP local search
solver \sphinxcite{userdoc:idwalk-cp04}. The string parameter is optional,
using “0 1 3 idwa 100000 cv v 0 200 1 0 0” by default with the
following meaning:
\sphinxstyleemphasis{stoppinglowerbound randomseed nbiterations method nbmoves
neighborhoodchoice neighborhoodchoice2 minnbneighbors maxnbneighbors
neighborhoodchoice3 autotuning tracemode}.

\sphinxlineitem{\sphinxhyphen{}pils={[}“string”{]}}
\sphinxAtStartPar
initial upper bound found by PILS local search
solver. The string parameter is optional,
using “3 0 0.333 100 500 10000 0.1 0.5 0.1 0.1” by default with the
following meaning:
\sphinxstyleemphasis{nbruns perturb\_mode perturb\_strength flatMaxIter nbEvalHC
nbEvalMax strengthMin strengthMax incrFactor decrFactor}.

\sphinxlineitem{\sphinxhyphen{}x={[}(,i{[}\(=\#<>\){]}a)*{]}}
\sphinxAtStartPar
performs an elementary operation (’\(=\)’:assign,
‘\(\#\)’:remove, ‘\(<\)’:decrease, ‘\(>\)’:increase) with
value a on variable of index i (multiple operations are separated by a
comma and no space) (without any
argument, a complete assignment \textendash{} used as initial upper bound and
as a value heuristic \textendash{} read from default file “sol” taken as a
certificate or given directly as an additional input
filename with “.sol” extension and without \sphinxstylestrong{\sphinxhyphen{}x})

\sphinxlineitem{\sphinxhyphen{}ub={[}decimal{]}}
\sphinxAtStartPar
gives an initial upper bound

\sphinxlineitem{\sphinxhyphen{}rasps={[}integer{]}}
\sphinxAtStartPar
VAC\sphinxhyphen{}based upper bound probing heuristic (0: disable, \textgreater{}0: max. nb. of
backtracks, 1000 if no integer given) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}raspslds={[}integer{]}}
\sphinxAtStartPar
VAC\sphinxhyphen{}based upper bound probing heuristic using LDS instead of DFS
(0: DFS, \textgreater{}0: max. discrepancy) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}raspsdeg={[}integer{]}}
\sphinxAtStartPar
automatic threshold cost value selection for probing heuristic
(default value is 10 degrees)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}raspsini]  
\sphinxAtStartPar
reset weighted degree variable ordering heuristic after doing
upper bound probing
\end{optionlist}


\subsection{Tree search algorithms and tree decomposition selection}
\label{\detokenize{userdoc:tree-search-algorithms-and-tree-decomposition-selection}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}hbfs={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search \sphinxcite{userdoc:katsirelos2015a}, restarting from the
root after a given number of backtracks (default value is 16384)

\sphinxlineitem{\sphinxhyphen{}hbfsmin={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search compromise between BFS and DFS minimum node redundancy
threshold (alpha percentage, default value is 5\%)

\sphinxlineitem{\sphinxhyphen{}hbfsmax={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search compromise between BFS and DFS maximum node redundancy
threshold (beta percentage default value is 10\%)

\sphinxlineitem{\sphinxhyphen{}open={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search limit on the number
of stored open nodes (default value is \sphinxhyphen{}1, i.e., no limit)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}burst]  
\sphinxAtStartPar
in parallel HBFS, workers send their solutions and open nodes as soon as possible (by default)
For using a parallel version of HBFS, after compiling with MPI option (cmake \sphinxhyphen{}DMPI=ON .)
use “mpirun \sphinxhyphen{}n {[}NbOfProcess{]} toulbar2 problem.wcsp”
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}eps={[}integer|filename{]}}
\sphinxAtStartPar
Embarrassingly parallel search mode. It outputs a given number of open nodes in \sphinxhyphen{}x format and exit  (default value is 0).
See ./misc/script/eps.sh to run them. Use this option twice to specify the output filename.

\sphinxlineitem{\sphinxhyphen{}B={[}integer{]}}
\sphinxAtStartPar
(0) HBFS, (1) BTD\sphinxhyphen{}HBFS \sphinxcite{userdoc:schiex2006a} \sphinxcite{userdoc:katsirelos2015a},
(2) RDS\sphinxhyphen{}BTD \sphinxcite{userdoc:sanchez2009a}, (3) RDS\sphinxhyphen{}BTD with path decomposition
instead of tree decomposition \sphinxcite{userdoc:sanchez2009a} (default value is 0)

\sphinxlineitem{\sphinxhyphen{}O={[}filename{]}}
\sphinxAtStartPar
reads either a reverse variable elimination order (given by a list
of variable indexes) from a file
in order to build a tree decomposition (if BTD\sphinxhyphen{}like and/or variable
elimination methods are used) or reads a valid tree decomposition directly (given by a list of clusters in topological order of a rooted forest, each line contains a cluster number, followed by a cluster parent number with \sphinxhyphen{}1 for the first/root(s) cluster(s), followed by a list of variable indexes). It is also used as a DAC ordering.

\sphinxlineitem{\sphinxhyphen{}O={[}negative integer{]}}
\sphinxAtStartPar
build a tree decomposition (if BTD\sphinxhyphen{}like
and/or variable elimination methods are used) and also a compatible
DAC ordering using
\begin{itemize}
\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}1) maximum cardinality search ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}2) minimum degree ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}3) minimum fill\sphinxhyphen{}in ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}4) maximum spanning tree ordering (see \sphinxhyphen{}mst),

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}5) reverse Cuthill\sphinxhyphen{}Mckee ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}6) approximate minimum degree ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}7) default file ordering

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}8) lexicographic ordering of variable names

\end{itemize}

\sphinxAtStartPar
If not specified, then use the variable order in which variables appear in the problem file.

\sphinxlineitem{\sphinxhyphen{}root={[}integer{]}}
\sphinxAtStartPar
root cluster heuristic
(0:largest, 1:max. size/(height\sphinxhyphen{}size), 2:min. size/(height\sphinxhyphen{}size), 3:min. height) (default value is 0)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}minheight]  
\sphinxAtStartPar
minimizes cluster tree height when searching for the root cluster (can be slow to perform)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}j={[}integer{]}}
\sphinxAtStartPar
splits large clusters into a chain of smaller embedded clusters with a number of proper variables less than this number (use options “\sphinxhyphen{}B=3 \sphinxhyphen{}j=1 \sphinxhyphen{}svo \sphinxhyphen{}k=1” for pure RDS, use value 0 for no splitting) (default value is 0).

\sphinxlineitem{\sphinxhyphen{}r={[}integer{]}}
\sphinxAtStartPar
limit on the maximum cluster separator size (merge cluster with its father otherwise, use a negative value for no limit) (default value is \sphinxhyphen{}1)

\sphinxlineitem{\sphinxhyphen{}X={[}integer{]}}
\sphinxAtStartPar
limit on the minimum number of proper variables in a cluster (merge cluster with its father otherwise, use a zero for no limit) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}E={[}float{]}}
\sphinxAtStartPar
merges leaf clusters with their fathers if small local treewidth (in conjunction with option “\sphinxhyphen{}e” and positive threshold value) or ratio of number of separator variables by number of cluster variables above a given threshold (in conjunction with option \sphinxhyphen{}vns) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}F={[}integer{]}}
\sphinxAtStartPar
merges clusters automatically to give more freedom to variable ordering heuristic in BTD\sphinxhyphen{}HBFS
(\sphinxhyphen{}1: no merging, positive value: maximum iteration value for trying to solve the same subtree given its separator assignment before considering it as unmerged) (default value is \sphinxhyphen{}1)

\sphinxlineitem{\sphinxhyphen{}R={[}integer{]}}
\sphinxAtStartPar
choice for a specific root cluster number

\sphinxlineitem{\sphinxhyphen{}I={[}integer{]}}
\sphinxAtStartPar
choice for solving only a particular rooted cluster subtree
(with RDS\sphinxhyphen{}BTD only)

\end{description}


\subsection{Variable neighborhood search algorithms}
\label{\detokenize{userdoc:variable-neighborhood-search-algorithms}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}vns]  
\sphinxAtStartPar
unified decomposition guided variable neighborhood search
\sphinxcite{userdoc:ouali2017} (UDGVNS). A problem decomposition into clusters can be
given as *.dec, *.cov, or *.order input files or using tree
decomposition options such as \sphinxhyphen{}O. For a parallel version (UPDGVNS),
use “mpirun \sphinxhyphen{}n {[}NbOfProcess{]} toulbar2 \sphinxhyphen{}vns problem.wcsp”.
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}vnsini={[}integer{]}}
\sphinxAtStartPar
initial solution for VNS\sphinxhyphen{}like methods found: (\sphinxhyphen{}1) at random, (\sphinxhyphen{}2) min domain values, (\sphinxhyphen{}3) max domain values, (\sphinxhyphen{}4) first solution found by a complete method, (k=0 or more) tree search with k discrepancy max (\sphinxhyphen{}4 by default)

\sphinxlineitem{\sphinxhyphen{}ldsmin={[}integer{]}}
\sphinxAtStartPar
minimum discrepancy for VNS\sphinxhyphen{}like methods (1 by default)

\sphinxlineitem{\sphinxhyphen{}ldsmax={[}integer{]}}
\sphinxAtStartPar
maximum discrepancy for VNS\sphinxhyphen{}like methods (number of problem variables multiplied by maximum domain size \sphinxhyphen{}1 by default)

\sphinxlineitem{\sphinxhyphen{}ldsinc={[}integer{]}}
\sphinxAtStartPar
discrepancy increment strategy for VNS\sphinxhyphen{}like methods using (1) Add1, (2) Mult2, (3) Luby operator (2 by default)

\sphinxlineitem{\sphinxhyphen{}kmin={[}integer{]}}
\sphinxAtStartPar
minimum neighborhood size for VNS\sphinxhyphen{}like methods (4 by default)

\sphinxlineitem{\sphinxhyphen{}kmax={[}integer{]}}
\sphinxAtStartPar
maximum neighborhood size for VNS\sphinxhyphen{}like methods (number of problem variables by default)

\sphinxlineitem{\sphinxhyphen{}kinc={[}integer{]}}
\sphinxAtStartPar
neighborhood size increment strategy for VNS\sphinxhyphen{}like methods using: (1) Add1, (2) Mult2, (3) Luby operator (4) Add1/Jump (4 by default)

\sphinxlineitem{\sphinxhyphen{}best={[}integer{]}}
\sphinxAtStartPar
stop VNS\sphinxhyphen{}like methods if a better solution is found (default value is 0)

\end{description}


\subsection{Node processing \& bounding options}
\label{\detokenize{userdoc:node-processing-bounding-options}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}e={[}integer{]}}
\sphinxAtStartPar
performs “on the fly” variable elimination of variable with small
degree (less than or equal to a specified value, default is 3 creating
a maximum of ternary cost functions). See \sphinxcite{userdoc:larrosa2000}.

\sphinxlineitem{\sphinxhyphen{}k={[}integer{]}}
\sphinxAtStartPar
soft local consistency level (NC \sphinxcite{userdoc:larrosa2002} with Strong NIC for global cost functions=0 \sphinxcite{userdoc:ll2009}, (G)AC=1 \sphinxcite{userdoc:schiex2000b} \sphinxcite{userdoc:larrosa2002}, D(G)AC=2 \sphinxcite{userdoc:cooperfcsp}, FD(G)AC=3 \sphinxcite{userdoc:larrosa2003}, (weak) ED(G)AC=4 \sphinxcite{userdoc:heras2005} \sphinxcite{userdoc:ll2010}) (default value is 4). See also \sphinxcite{userdoc:cooper2010a} \sphinxcite{userdoc:ll2012asa}.

\sphinxlineitem{\sphinxhyphen{}A={[}integer{]}}
\sphinxAtStartPar
enforces VAC \sphinxcite{userdoc:cooper2008} at each search node with a search depth less than a given value (default value is 0)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}V]  
\sphinxAtStartPar
VAC\sphinxhyphen{}based value ordering heuristic (default option)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}T={[}decimal{]}}
\sphinxAtStartPar
threshold cost value for VAC (default value is 1)

\sphinxlineitem{\sphinxhyphen{}P={[}decimal{]}}
\sphinxAtStartPar
threshold cost value for VAC during the preprocessing phase only (default value is 1)

\sphinxlineitem{\sphinxhyphen{}C={[}float{]}}
\sphinxAtStartPar
multiplies all costs internally by this number when loading the problem (cannot be done with cfn format and probabilistic graphical models in uai/LG formats) (default value is 1)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}vacthr]  
\sphinxAtStartPar
automatic threshold cost value selection for VAC during search (must be combined with option \sphinxhyphen{}A)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}dee={[}integer{]}}
\sphinxAtStartPar
restricted dead\sphinxhyphen{}end elimination \sphinxcite{userdoc:givry2013a} (value pruning by dominance rule from EAC value (dee \(>=1\)  and dee \(<=3\) )) and soft neighborhood substitutability (in preprocessing (dee=2 or dee=4) or during search (dee=3)) (default value is 1)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}o]  
\sphinxAtStartPar
ensures an optimal worst\sphinxhyphen{}case time complexity of DAC and EAC
(can be slower in practice)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}kpdp={[}integer{]}}
\sphinxAtStartPar
solves knapsack constraints using dynamic programming
(\sphinxhyphen{}2: never, \sphinxhyphen{}1: only in preprocessing, 0: at every search node, \textgreater{}0: after a given number of nodes) (default value is \sphinxhyphen{}2)

\end{description}


\subsection{Branching, variable and value ordering}
\label{\detokenize{userdoc:branching-variable-and-value-ordering}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}svo]  
\sphinxAtStartPar
searches using a static variable ordering heuristic.
The variable order value used will be the same order as the DAC order.
\item [\sphinxhyphen{}b]  
\sphinxAtStartPar
searches using binary branching (by default) instead of n\sphinxhyphen{}ary branching.
Uses binary branching for interval domains and small domains
and dichotomic branching for large enumerated domains (see option \sphinxhyphen{}d).
\item [\sphinxhyphen{}c]  
\sphinxAtStartPar
searches using binary branching with last conflict
backjumping variable ordering heuristic \sphinxcite{userdoc:lecoutre2009}.
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}q={[}integer{]}}
\sphinxAtStartPar
use weighted degree variable ordering heuristic \sphinxcite{userdoc:boussemart2004}
if the number of cost
functions is less than the given value (default value is 1000000).

\sphinxlineitem{\sphinxhyphen{}var={[}integer{]}}
\sphinxAtStartPar
searches by branching only on the first {[}given value{]}
decision variables, assuming the remaining variables are
intermediate variables that will be completely assigned by the
decision variables (use a zero if all variables are decision
variables, default value is 0)

\sphinxlineitem{\sphinxhyphen{}m={[}integer{]}}
\sphinxAtStartPar
use a variable ordering heuristic that selects first variables such
that the sum of the mean (m=1) or median (m=2) cost of all incident
cost functions is maximum \sphinxcite{userdoc:schiex2014a}
(in conjunction with weighted degree
heuristic \sphinxhyphen{}q) (default value is 0: unused).

\sphinxlineitem{\sphinxhyphen{}d={[}integer{]}}
\sphinxAtStartPar
searches using dichotomic branching. The default d=1 splits domains
in the middle of domain range while d=2 splits domains in the middle
of the sorted domain based on unary costs.

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}sortd]  
\sphinxAtStartPar
sorts domains in preprocessing based on increasing unary costs
(works only for binary WCSPs).
\item [\sphinxhyphen{}sortc]  
\sphinxAtStartPar
sorts constraints in preprocessing based on lexicographic ordering (1), decreasing DAC ordering (2 \sphinxhyphen{} default option), decreasing constraint tightness (3), DAC then tightness (4), tightness then DAC (5), randomly (6) or the opposite order if using a negative value.
\item [\sphinxhyphen{}solr]  
\sphinxAtStartPar
solution\sphinxhyphen{}based phase saving (reuse last found solution as preferred value assignment in the value ordering heuristic) (default option).
\item [\sphinxhyphen{}vacint]  
\sphinxAtStartPar
VAC\sphinxhyphen{}integrality/Full\sphinxhyphen{}EAC variable ordering heuristic (can be combined with option \sphinxhyphen{}A)
\end{optionlist}


\subsection{Diverse solutions}
\label{\detokenize{userdoc:diverse-solutions}}
\sphinxAtStartPar
toulbar2 can search for a greedy sequence of diverse solutions with guaranteed local optimality and minimum pairwise Hamming distance \sphinxcite{userdoc:ruffini2019a}.
\begin{description}
\sphinxlineitem{\sphinxhyphen{}div={[}integer{]}}
\sphinxAtStartPar
minimum Hamming distance between diverse solutions (use in conjunction
with \sphinxhyphen{}a=integer with a limit of 1000 solutions) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}divm={[}integer{]}}
\sphinxAtStartPar
diversity encoding method (0:Dual, 1:Hidden, 2:Ternary, 3:Knapsack)
(default value is 3)

\sphinxlineitem{\sphinxhyphen{}mdd={[}integer{]}}
\sphinxAtStartPar
maximum relaxed MDD width for diverse solution global constraint
(default value is 0)

\sphinxlineitem{\sphinxhyphen{}mddh={[}integer{]}}
\sphinxAtStartPar
MDD relaxation heuristic: 0: random, 1: high div, 2: small div,
3: high unary costs (default value is 0)

\end{description}


\subsection{Console output}
\label{\detokenize{userdoc:console-output}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}help]  
\sphinxAtStartPar
shows the default help message that toulbar2 prints when
it gets no argument.
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}v={[}integer{]}}
\sphinxAtStartPar
sets the verbosity level (default 0).

\sphinxlineitem{\sphinxhyphen{}Z={[}integer{]}}
\sphinxAtStartPar
debug mode (save problem at each node if verbosity
option \sphinxhyphen{}v=num \(>= 1\) and \sphinxhyphen{}Z=num \(>=3\))

\sphinxlineitem{\sphinxhyphen{}s={[}integer{]}}
\sphinxAtStartPar
shows each solution found during search. The solution is
printed on one line, giving by default (\sphinxhyphen{}s=1) the value (integer)
of each variable successively
in increasing file order. For \sphinxhyphen{}s=2, the value name is used instead,
and for \sphinxhyphen{}s=3, variable name=value name is printed instead.

\end{description}


\subsection{File output}
\label{\detokenize{userdoc:file-output}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}w={[}filename{]}}
\sphinxAtStartPar
writes last/all solutions found in the specified
filename (or “sol” if no parameter is given). The current directory
is used as a relative path.

\sphinxlineitem{\sphinxhyphen{}w={[}integer{]}}
\sphinxAtStartPar
1: writes value numbers, 2: writes value names, 3: writes also variable names (default value is 1, this option can be used in combination with \sphinxhyphen{}w=filename).

\sphinxlineitem{\sphinxhyphen{}z={[}filename{]}}
\sphinxAtStartPar
saves problem in wcsp or cfn format in filename (or
“problem.wcsp”/”problem.cfn” if no parameter is given) writes also
the graphviz dot file and the degree distribution of the input problem

\sphinxlineitem{\sphinxhyphen{}z={[}integer{]}}
\sphinxAtStartPar
1 or 3: saves original instance in 1\sphinxhyphen{}wcsp or 3\sphinxhyphen{}cfn format
(1 by default), 2 or 4: saves
after preprocessing in 2\sphinxhyphen{}wcsp or 4\sphinxhyphen{}cfn format (this option can be
used in combination with \sphinxhyphen{}z=filename)

\sphinxlineitem{\sphinxhyphen{}x={[}(,i{[}\(=\#<>\){]}a)*{]}}
\sphinxAtStartPar
performs an elementary operation (’\(=\)’:assign, ‘\(\#\)’:remove, ‘\(<\)’:decrease, ‘\(>\)’:increase) with value a on variable of index i (multiple
operations are separated by a comma and no space) (without any
argument, a complete assignment \textendash{} used as initial upper bound and
as value heuristic \textendash{} read from default file “sol” or given as input
filename with “.sol” extension)

\end{description}


\subsection{Probability representation and numerical control}
\label{\detokenize{userdoc:probability-representation-and-numerical-control}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}precision={[}integer{]}}
\sphinxAtStartPar
probability/real precision is a conversion
factor (a power of ten) for representing fixed point numbers
(default value is 7)

\sphinxlineitem{\sphinxhyphen{}epsilon={[}float{]}}
\sphinxAtStartPar
approximation factor for computing the partition
function (greater than 1, default value is infinity)

\end{description}


\subsection{Random problem generation}
\label{\detokenize{userdoc:random-problem-generation}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}random={[}bench profile{]}}
\sphinxAtStartPar
bench profile must be specified as follows.
\begin{itemize}
\item {} 
\sphinxAtStartPar
n and d are respectively the number of variable and the
maximum domain size of the random problem.

\sphinxAtStartPar
bin\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
t1 is the tightness in percentage \% of random binary cost
functions

\item {} 
\sphinxAtStartPar
p2 is the number of binary cost functions to include

\item {} 
\sphinxAtStartPar
the seed parameter is optional

\end{itemize}

\sphinxAtStartPar
binsub\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}\sphinxhyphen{}\{seed\} binary random \& submodular
cost functions
\begin{itemize}
\item {} 
\sphinxAtStartPar
t1 is the tightness in percentage \% of random cost functions

\item {} 
\sphinxAtStartPar
p2 is the number of binary cost functions to include

\item {} 
\sphinxAtStartPar
p3 is the percentage \% of submodular cost functions among p2
cost functions
(plus 10 permutations of two randomly\sphinxhyphen{}chosen values for each
domain)

\end{itemize}

\sphinxAtStartPar
tern\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
p3 is the number of ternary cost functions

\end{itemize}

\sphinxAtStartPar
nary\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}…\sphinxhyphen{}\{pn\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
pn is the number of n\sphinxhyphen{}ary cost functions

\end{itemize}

\sphinxAtStartPar
salldiff\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}…\sphinxhyphen{}\{pn\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
pn is the number of salldiff global cost functions (p2 and
p3 still being used for the number of random binary and
ternary cost functions). \sphinxstyleemphasis{salldiff} can be replaced by
\sphinxstyleemphasis{gcc} or \sphinxstyleemphasis{regular} keywords with three possible forms
(\sphinxstyleemphasis{e.g., sgcc, sgccdp, wgcc}) and by \sphinxstyleemphasis{knapsack}.

\end{itemize}

\end{itemize}

\end{description}


\section{Input formats}
\label{\detokenize{userdoc:input-formats}}\label{\detokenize{userdoc:id56}}

\subsection{Introduction}
\label{\detokenize{userdoc:introduction}}
\sphinxAtStartPar
The available \sphinxstylestrong{file formats} (possibly compressed by gzip or bzip2 or xz, e.g., .cfn.gz, .wcsp.xz, .opb.bz2) are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cost Function Network format ({\hyperref[\detokenize{formats/cfnformat:cfn-format}]{\sphinxcrossref{\DUrole{std,std-ref}{.cfn}}}} file extension)

\item {} 
\sphinxAtStartPar
Weighted Constraint Satisfaction Problem ({\hyperref[\detokenize{formats/wcspformat:wcsp-format}]{\sphinxcrossref{\DUrole{std,std-ref}{.wcsp}}}} file extension)

\item {} 
\sphinxAtStartPar
Probabilistic Graphical Model (\sphinxhref{http://www.cs.huji.ac.il/project/PASCAL/fileFormat.php}{.uai} / .LG file extension ; the file format .LG is identical to .UAI except that we expect log\sphinxhyphen{}potentials)

\item {} 
\sphinxAtStartPar
Weigthed Partial Max\sphinxhyphen{}SAT (\sphinxhref{http://www.maxsat.udl.cat/08/index.php?disp=requirements}{.cnf/.wcnf} file extension)

\item {} 
\sphinxAtStartPar
Quadratic Unconstrained Pseudo\sphinxhyphen{}Boolean Optimization ({\hyperref[\detokenize{formats/qpboformat:qpbo-format}]{\sphinxcrossref{\DUrole{std,std-ref}{.qpbo}}}} file extension)

\item {} 
\sphinxAtStartPar
Pseudo\sphinxhyphen{}Boolean Optimization (\sphinxhref{http://www.cril.univ-artois.fr/PB16/format.pdf}{.opb} file extension)

\item {} 
\sphinxAtStartPar
Constraint Satisfaction and Optimization Problem (\sphinxhref{https://xcsp.org}{.xml} file extension)

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Some examples} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
A simple 2 variables maximization problem \sphinxhref{https://github.com/toulbar2/toulbar2/raw/master/validation/default/maximization.cfn}{maximization.cfn} in JSON\sphinxhyphen{}compatible CFN format, with decimal positive and negative costs.

\item {} 
\sphinxAtStartPar
Random binary cost function network \sphinxcode{\sphinxupquote{example.wcsp}}, with a specific variable ordering \sphinxcode{\sphinxupquote{example.order}}, a tree decomposition \sphinxcode{\sphinxupquote{example.cov}}, and a cluster decomposition \sphinxcode{\sphinxupquote{example.dec}}

\item {} 
\sphinxAtStartPar
Latin square 4x4 with random costs on each variable \sphinxcode{\sphinxupquote{latin4.wcsp}}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/schiex/Doc/Export/CELAR.ps.gz}{Radio link frequency assignment CELAR} instances \sphinxcode{\sphinxupquote{scen06.wcsp}}, \sphinxcode{\sphinxupquote{scen06.cov}}, \sphinxcode{\sphinxupquote{scen06.dec}}, \sphinxcode{\sphinxupquote{scen07.wcsp}}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/-/raw/master/real/spot5/BensanaLemaitreVerfaillieConstraints1999.pdf}{Earth observation satellite management SPOT5} instances \sphinxcode{\sphinxupquote{404.wcsp}} and \sphinxcode{\sphinxupquote{505.wcsp}} with associated tree/cluster decompositions \sphinxcode{\sphinxupquote{404.cov}}, \sphinxcode{\sphinxupquote{505.cov}}, \sphinxcode{\sphinxupquote{404.dec}}, \sphinxcode{\sphinxupquote{505.dec}}

\item {} 
\sphinxAtStartPar
Linkage analysis instance \sphinxcode{\sphinxupquote{pedigree9.uai}}

\item {} 
\sphinxAtStartPar
Computer vision superpixel\sphinxhyphen{}based image segmentation instance \sphinxcode{\sphinxupquote{GeomSurf\sphinxhyphen{}7\sphinxhyphen{}gm256.uai}}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Schiex14a.pdf}{Protein folding} instance \sphinxcode{\sphinxupquote{1CM1.uai}}

\item {} 
\sphinxAtStartPar
Max\sphinxhyphen{}clique DIMACS instance \sphinxcode{\sphinxupquote{brock200\_4.clq.wcnf}}

\item {} 
\sphinxAtStartPar
Graph 6\sphinxhyphen{}coloring instance \sphinxcode{\sphinxupquote{GEOM40\_6.wcsp}}

\item {} 
\sphinxAtStartPar
Many more instances available \sphinxhref{http://genoweb.toulouse.inra.fr/~degivry/evalgm}{evalgm} and  \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library}{Cost Function Library}.

\end{itemize}

\sphinxAtStartPar
Notice that by default toulbar2 distinguishes file formats based on their extension.
It is possible to read a file from a unix pipe using option \sphinxcode{\sphinxupquote{\sphinxhyphen{}stdin={[}format{]}}}; \sphinxstyleemphasis{e.g.}, \sphinxcode{\sphinxupquote{cat example.wcsp | toulbar2 \sphinxhyphen{}\sphinxhyphen{}stdin=wcsp}}

\sphinxAtStartPar
It is also possible to read and combine multiple problem files (warning, they must be all in the same format, either wcsp, cfn, or xml).
Variables with the same name are merged (domains must be identical), otherwise the merge is based on variable indexes (wcsp format).


\subsection{Formats details}
\label{\detokenize{userdoc:formats-details}}
\sphinxstepscope


\subsubsection{CFN format (.cfn suffix)}
\label{\detokenize{formats/cfnformat:cfn-format-cfn-suffix}}\label{\detokenize{formats/cfnformat:cfn-format}}\label{\detokenize{formats/cfnformat::doc}}
\sphinxAtStartPar
With this JSON compatible format, it is possible:
\begin{itemize}
\item {} 
\sphinxAtStartPar
to give a name to variables and functions.

\item {} 
\sphinxAtStartPar
to associate a local label to every value that is accessible inside toulbar2 (among others for heuristics design purposes).

\item {} 
\sphinxAtStartPar
to use decimal and possibly negative costs.

\item {} 
\sphinxAtStartPar
to solve both minimization and maximization problems.

\item {} 
\sphinxAtStartPar
to debug your \sphinxstylestrong{.cfn} files: the parser gives a cause and line number when it fails.

\item {} 
\sphinxAtStartPar
to use gzip’d or xz compressed files directly as input (.cfn.gz and .cfn.xz).

\item {} 
\sphinxAtStartPar
to use dense descriptions for dense cost tables.

\end{itemize}

\sphinxAtStartPar
In a \sphinxstylestrong{cfn} file, a Cost Function Network is described as a JSON object with extra freedom and extra constraints.

\sphinxAtStartPar
Freedom:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the double quotes around strings are not compulsory: both \sphinxcode{\sphinxupquote{"problem"}} and \sphinxcode{\sphinxupquote{problem}} are strings.

\item {} 
\sphinxAtStartPar
double quotes can also be added around numbers: both \sphinxcode{\sphinxupquote{1.20}} and \sphinxcode{\sphinxupquote{"1.20"}} will be interpreted as decimal numbers.

\item {} 
\sphinxAtStartPar
the commas that separates the fields inside an array or object are not compulsory. Any separator will do (comma, white space). So \sphinxcode{\sphinxupquote{{[}1, 2{]}}} or \sphinxcode{\sphinxupquote{{[}1,2{]}}} or \sphinxcode{\sphinxupquote{{[}1 2{]}}} are all describing the same array.

\item {} 
\sphinxAtStartPar
the delimiters for objects and arrays (\sphinxcode{\sphinxupquote{\{\}}} and \sphinxcode{\sphinxupquote{{[}{]}}}) can be used arbitrarily for both types of items.

\item {} 
\sphinxAtStartPar
the colon (\sphinxcode{\sphinxupquote{:}}) that separates the name of a field in an object from the contents of the field is not compulsory.

\item {} 
\sphinxAtStartPar
It is possible to comment a line with a \sphinxcode{\sphinxupquote{\#}} the first position of a line.

\end{itemize}

\sphinxAtStartPar
Constraints:
\begin{itemize}
\item {} 
\sphinxAtStartPar
strings should not start with a character in \sphinxcode{\sphinxupquote{0123456789\sphinxhyphen{}.+}} and cannot contain \sphinxcode{\sphinxupquote{/\#{[}{]}\{\}}} or a space character (tabs…).

\item {} 
\sphinxAtStartPar
numbers can only be integers or decimals. No scientific notation.

\item {} 
\sphinxAtStartPar
the orders of fields inside an object is compulsory and cannot be changed.

\end{itemize}

\sphinxAtStartPar
A CFN is an object with 3 data: a definition of the main problem properties (tag \sphinxcode{\sphinxupquote{problem}}), of variables and their domains (tag \sphinxcode{\sphinxupquote{variables}}) and of cost functions (tag \sphinxcode{\sphinxupquote{functions}}), in this order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{problem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{problem} \PYG{n}{properties}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{variables}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{variables} \PYG{o+ow}{and} \PYG{n}{domains}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{functions}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{functions} \PYG{n}{descriptions}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Problem properties:}

\sphinxAtStartPar
An object with two fields:
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"name"}} : the name of the problem.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"mustbe"}} : specifies the direction of optimization and a global (upper/lower) bound on the objective. This is the concatenation of a comparator (\sphinxcode{\sphinxupquote{\textgreater{}}} or \sphinxcode{\sphinxupquote{\textless{}}}) immediately followed by a decimal number, described as a string. The comparator specifies the direction of optimization:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}"}}: we are minimizing and the decimal indicates a global upper bound (all costs equal to or larger than this are considered as unfeasible).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}"}}: we are maximizing and and the decimal indicates a global lower bound (all costs equal to or less than this are considered as unfeasible).

\end{itemize}

\sphinxAtStartPar
The number of significant digits in the decimal number gives the precision that will be used for all cost computations inside toulbar2.

\sphinxAtStartPar
An an example, \sphinxcode{\sphinxupquote{"mustbe": "\textless{}10.00"}} means that the CFN describes a function where all costs larger than or equal to 10.00 are considered as infinite. All costs will also be handled with 2 digits of precision after the decimal point.
\end{quote}

\sphinxAtStartPar
The two fields must appear in this order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}problem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustbe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}\PYGZhy{}12.100}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{test}\PYG{o}{.}\PYG{n}{problem} \PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{12.100}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
in a more concise non JSON\sphinxhyphen{}compatible form.

\sphinxAtStartPar
\sphinxstylestrong{Variables and domains:}

\sphinxAtStartPar
An object with as many fields as variables. All fields must have different names. The contents of a variable field can be an array or an integer. An array gives the sequence of values (defined by their name) of the variable domain. An integer gives the domain cardinality, without naming values (values are represented by their position in the domain, starting at 0). If a negative domain size is given, the variable is an interval variable instead of a finite domain variable and it has domain {[}0,\sphinxhyphen{}domainsize\sphinxhyphen{}1{]}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iv1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
defines 3 variables, two finite domain variables and 1 interval variable. The first domain variable has 3 values, \sphinxcode{\sphinxupquote{"a"}} \sphinxcode{\sphinxupquote{"b"}} and \sphinxcode{\sphinxupquote{"c"}}. the second has two anonymous values and the interval variable has domain {[}0,99{]}.

\sphinxAtStartPar
As an extra freedom, it is possible to give no name to variables. This can be achieved using an array instead of an object. The example above can therefore be written:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{n}{a} \PYG{n}{b} \PYG{n}{c}\PYG{p}{]} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
or even just

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
in a dense non JSON\sphinxhyphen{}compatible format.

\sphinxAtStartPar
\sphinxstylestrong{Functions:}

\sphinxAtStartPar
An object with as many fields as functions. Every function is an object with different possible fields. All functions have a \sphinxcode{\sphinxupquote{scope}} which is an array of variables (names or indices). The rest of the fields depends on the type of the cost function: table cost function or global (including arithmetic functions).

\sphinxAtStartPar
\sphinxstylestrong{Table cost functions:}

\sphinxAtStartPar
Sparse functions format:* useful for functions that are dominantly constant. A numerical \sphinxcode{\sphinxupquote{defaultcost}} must be given after the scope. The \sphinxcode{\sphinxupquote{costs}} table must be an array of tuple.costs: a sequence of value names or indices followed by a numeric cost. The \sphinxcode{\sphinxupquote{defaultcost}} is used to define the cost of any missing tuple.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{defaultcost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.234}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{6.2}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.21}\PYG{p}{]} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
is a possible sparse function definition. Here only 3 tuples are defined with their costs. All 3 remaining tuples will have cost \sphinxcode{\sphinxupquote{0.234}}.

\sphinxAtStartPar
\sphinxstyleemphasis{Dense function format:} if the \sphinxcode{\sphinxupquote{defaultcost}} tag is absent, a complete lexicographically ordered list of costs is expected instead.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{4.2}\PYG{p}{,} \PYG{l+m+mf}{3.67}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+m+mf}{7.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.1}\PYG{p}{,} \PYG{l+m+mf}{100.2}\PYG{p}{]} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
describes the 6 costs of the 6 tuples insides the cartesian product of the two variables \sphinxcode{\sphinxupquote{"fdv1"}} and \sphinxcode{\sphinxupquote{"fdv2"}}. To assign costs to tuples, all possible tuples of the cartesian product are lexicographically ordered using the declared value order in the domain of each variable.  In the example above, the order over the six pairs will be \sphinxcode{\sphinxupquote{("a",0) ("a",1) ("b",0) ("b",1) ("c",0) ("c",1)}} that will be associated to the costs \sphinxcode{\sphinxupquote{4.2, 3.67, \sphinxhyphen{}12.1, 7.1, \sphinxhyphen{}3.1}} and \sphinxcode{\sphinxupquote{100.2}} in this order. This lexicographic ordering is used for all arities.

\sphinxAtStartPar
\sphinxstyleemphasis{Shared function format:} If instead of an array, a string is given for the cost table, then this string must be the name of a yet undefined function. The actual function will have the same cost table as the future indicated function (on the specified scope). The domain sizes of the two functions must match.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f12}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
defines a function on variables \sphinxcode{\sphinxupquote{v1}} and \sphinxcode{\sphinxupquote{v3}} that will have the same cost table as the function i:code:\sphinxtitleref{f12} that must be defined later in the file.

\sphinxAtStartPar
\sphinxstylestrong{Global and arithmetic cost functions}

\sphinxAtStartPar
These functions are defined by a \sphinxcode{\sphinxupquote{scope}}, a \sphinxcode{\sphinxupquote{type}} and \sphinxcode{\sphinxupquote{parameters}}. The \sphinxcode{\sphinxupquote{type}} is a string that defines the specific function to use, the \sphinxcode{\sphinxupquote{parameters}} is an array of objects. The composition of the \sphinxcode{\sphinxupquote{parameters}} depends on the \sphinxcode{\sphinxupquote{type}} of the function.

\sphinxAtStartPar
At this point, in maximization mode, most of the global cost functions have restricted usage (with the exception of wregular).

\sphinxAtStartPar
\sphinxstyleemphasis{Arithmetic functions:}

\sphinxAtStartPar
These functions have all arity 2 and it is assumed here that these variables are called x and y . The values are considered as representing their index in the domain and are therefore integer. The \sphinxcode{\sphinxupquote{type}} can be either:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}="}} : with \sphinxcode{\sphinxupquote{parameters}} array \([ cst , \delta ]\)
where \(cst\) and \(\delta\) are two costs, to express cost
function \(max(0, y + cst - x \leq \delta ? y + cst - x : upperbound)\). This is a soft inequality with hard threshold \(\delta\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}"}}: similar with a strict inequality and semantics
\(max(0, y + 1 + cst - x \leq \delta ? y + 1 + cst - x : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}="}}: similar with an inverted inequality and semantics:
\(max(0, x - cst - y \leq \delta ? x - cst - y : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}"}}: similar with a strict inequality and semantics
\(max(0, x - cst + 1 - y \leq \delta ? x - cst + 1 - y : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"="}}: similar with an equality and semantics: similar with a strict
inequality and semantics
\(\left| y + cst - x \right| \leq \delta ? \left|y + cst - x \right| : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"disj"}}: takes a \sphinxcode{\sphinxupquote{parameters}} array \([ cstx, csty, w]\)
to express soft binary disjunctive cost function with semantics \(( (x \geq y + csty) \lor ( y \geq x + cstx)) ? 0 : w)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sdisj"}}: takes a \sphinxcode{\sphinxupquote{parameters}} array \([ cstx, csty, xmax, ymax wx wy]\) to express a special disjunctive cost function with three implicit constraints \(x \leq xmax\), \(y \leq ymax\) and \(( x < xmax \land y < ymax) \Rightarrow ( x \geq y + csty \lor  y \geq x + cstx)\) and an additional cost function \(( (x = xmax) ? wx : 0) + ( (y = y max? wy : 0)\).

\end{itemize}

\sphinxAtStartPar
example : arithmetic function with \sphinxcode{\sphinxupquote{\textgreater{}=}} operator :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arith0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Global cost functions:}

\sphinxAtStartPar
We use an informal syntactical description of each global cost function below. the \sphinxcode{\sphinxupquote{"|"}} is used for alternative keywords and parentheses together with \sphinxcode{\sphinxupquote{?}}, \sphinxcode{\sphinxupquote{*}} and \sphinxcode{\sphinxupquote{+}} to denote optional or repeated groups of items (+ requires that at least one repetition exists). For more details on
semantics and implementation, see:
\begin{quote}

\sphinxAtStartPar
1. Lee, J. H. M., \& Leung, K. L. (2012). Consistency techniques for flow\sphinxhyphen{}based projection\sphinxhyphen{}safe global cost functions in weighted constraint satisfaction. \sphinxstyleemphasis{Journal of Artificial Intelligence Research}, 43, 257\sphinxhyphen{}292.
\sphinxstyleemphasis{Artificial Intelligence}, 238, 166\sphinxhyphen{}189. 2. Allouche, D., Bessiere, C., Boizumault, P., De Givry, S., Gutierrez, P., Lee, J. H., … \& Wu, Y. (2016). Tractability\sphinxhyphen{}preserving transformations of global cost functions. \sphinxstyleemphasis{Artificial Intelligence}, 238, 166\sphinxhyphen{}189.
\end{quote}

\sphinxAtStartPar
Using a flow\sphinxhyphen{}based propagator:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salldiff"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"dec"|"decbi" cost: cost{]}}} expresses a soft alldifferent with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{dec}} and \sphinxcode{\sphinxupquote{decbi}} keywords) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation (\sphinxcode{\sphinxupquote{decbi}} decomposes into a complete binary cost function network).
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{salldiff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.7}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
generates a cost of 0.7 per variable assignment that needs to be
changed for all variables to take a different value.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgcc"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric:"var"|"dec"|"wdec" cost: cost bounds: {[}{[}value lower\_bound upper\_bound (shortage\_weight excess\_weight)?{]}*{]}}} expresses a soft global cardinality constraint with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{dec}} keyword) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation and for each value its \sphinxcode{\sphinxupquote{lower}} and \sphinxcode{\sphinxupquote{upper}} bound (\sphinxcode{\sphinxupquote{value shortage}} and \sphinxcode{\sphinxupquote{excess weights}} penalties must be given iff \sphinxcode{\sphinxupquote{wdec}} is used).
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{sgcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{wdec}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.5}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.2}\PYG{p}{]}
                   \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"ssame"}} with parameters array \sphinxcode{\sphinxupquote{{[}cost: cost vars1: {[}(variable)*{]} vars2: {[}(variable)*{]}{]}}} to express a permutation constraint on two lists of variables of equal size with implicit variable\sphinxhyphen{}based cost semantic
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{ssame}
       \PYG{n}{params} \PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{6.2}
          \PYG{n}{vars1} \PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2}\PYG{p}{]}
          \PYG{n}{vars2} \PYG{p}{:} \PYG{p}{[}\PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sregular"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"edit" cost: cost starts: {[}(state)*{]} ends: {[}(state)*{]} transitions: {[}(start\sphinxhyphen{}state symbol\_value end\_state)*{]}}} to express a soft regular constraint with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or edit distance\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{edit}} keyword) cost semantics with a given \sphinxcode{\sphinxupquote{cost}} per violation followed by the definition of a deterministic finite automaton with arrays of initial and final states, and an array of state transitions where symbols are domain values indices.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{sregular}
       \PYG{n}{params} \PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n}{nb\PYGZus{}states}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{starts}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{n}{ends}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}
          \PYG{n}{transitions}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Global cost functions using a dynamic programming DAG\sphinxhyphen{}based propagator:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sregulardp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost nb\_states: nb\_states starts: {[}(state)*{]} ends: {[}(state)*{]} transitions: {[}(start\_state value\_index end\_state)*{]}}} to express a soft regular constraint with a variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation followed by the definition of a deterministic finite automaton with arrays of initial and final states, and an array of state transitions where symbols are domain value indices.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example: see sregular above.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgrammar"|"sgrammardp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"weight" cost: cost nb\_symbols: nb\_symbols nb\_values: nb\_values start: start\_symbol terminals: {[}(terminal\_symbol value (cost)?)*{]} non\_terminals: {[}(nonterminal\_in nonterminal\_out\_left nonterminal\_out\_right (cost)?)*{]}}} to express a soft/weighted grammar in Chomsky normal form. The costs inside the rules and terminals should be used only with the \sphinxcode{\sphinxupquote{weight}} metric.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{sgrammardp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric} \PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{1.012}
          \PYG{n}{nb\PYGZus{}symbols} \PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{n}{nb\PYGZus{}values} \PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{start} \PYG{p}{:} \PYG{l+m+mi}{0}
          \PYG{n}{terminals} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{non\PYGZus{}terminals} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"samong"|"samongdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost min: lower\_bound max: upper\_bound values: {[}(value)*{]}{]}}} to express a soft among constraint to restrict the number of variables taking their value into a given set of value indices
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{samong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric} \PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"salldiffdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost{]}}} to express a soft alldifferent constraint with variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{"var"}} keyword) cost semantic with a given cost per violation (decomposes into \sphinxcode{\sphinxupquote{samongdp}} cost functions)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{salldiffdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.7}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgccdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: "cost" bounds: {[}(value lower\_bound upper\_bound)*{]}{]}}} to express a soft global cardinality constraint with variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{"var"}} keyword) cost semantic with a given cost per violation and for each value its lower and upper bound (decomposes into \sphinxcode{\sphinxupquote{samongdp}} cost functions)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{sgccdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.1}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"max|smaxdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}defaultcost: defcost tuples: {[}(variable value cost)*{]}{]}}} to express a weighted max cost function to find the maximum cost over a set of unary cost functions associated to a set of variables (by default, \sphinxcode{\sphinxupquote{defCost}} if unspecified)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{smaxdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{defaultcost}\PYG{p}{:} \PYG{l+m+mi}{3}
          \PYG{n}{tuples}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"MST"|"smstdp"}} with empty parameters expresses a hard spanning tree constraint where each variable is assigned to its parent variable index in order to build a spanning tree (the root being assigned to itself)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
        \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{MST} \PYG{n}{params}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Global cost functions using a cost function network\sphinxhyphen{}based propagator (decompose to bounded arity table cost functions):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wregular"}} with parameters \sphinxcode{\sphinxupquote{nb\_states: nbstates starts: {[}{[}state cost{]}*{]} ends: {[}{[}state cost{]}*{]} transitions: {[}{[}state value\_index state cost{]}*{]}}} to express a weighted regular constraint with weights on initial states, final states, and transitions, followed by the definition of a deterministic finite automaton with number of states, list of initial and final states with their costs, and list of weighted state transitions where symbols are domain value indices
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v4} \PYG{n}{v3}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wregular}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{nb\PYGZus{}states}\PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{n}{starts} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{ends} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{transitions} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.0}\PYG{p}{]}
                         \PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"walldiff"}} with parameters array \sphinxcode{\sphinxupquote{{[}hard|lin|quad{]}}} cost to express a soft alldifferent constraint as a set of wamong hard constraint (\sphinxcode{\sphinxupquote{hard}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{lin}} and \sphinxcode{\sphinxupquote{quad}} keywords) cost semantic with a given cost per violation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{walldiff}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.8}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wgcc"}} with parameters metric: \sphinxcode{\sphinxupquote{hard|lin|quad cost: cost bounds: {[}{[}value lower\_bound upper\_bound{]}*{]}}} to express a soft global cardinality constraint as either a hard constraint (\sphinxcode{\sphinxupquote{hard}} keyword) or with decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{lin}} and \sphinxcode{\sphinxupquote{quad}} keyword) cost semantic with a given cost per violation and for each value its lower and upper bound
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wgcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsame"}} with parameters a \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost}} to express a permutation constraint on two lists of variables of equal size (implicitly concatenated in the scope) using implicit decomposition\sphinxhyphen{}based cost semantic
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
        \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wsame}
        \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
           \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
           \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
           \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsamegcc"}} with parameters array \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost bounds: {[}{[}value lower\_bound upper\_bound{]}*{]}}} to express the combination of a soft global cardinality constraint and a permutation constraint.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wsamegcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wamong"}} with parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost values: {[}(value)*{]} min: lower\_bound max: upper\_bound}} to express a soft among constraint to restrict the number of variables taking their value into a given set of values.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wamong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wvaramong"}} with parameters array \sphinxcode{\sphinxupquote{metric: hard cost: cost values: {[}(value)*{]}}} to express a hard among constraint to restrict the number of variables taking their value into a given set of values to be equal to the last variable in the scope.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4} \PYG{n}{v5}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wvaramong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{12.0}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"woverlap"}} with parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost comparator: comparator to: righthandside{]}}} overlaps between two sequences of variables X, Y (i.e. set the fact that Xi and Yi take the same value (not equal to zero))
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{woverlap}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{2.01}\PYG{n}{comparator}\PYG{p}{:} \PYG{o}{\PYGZgt{}}
          \PYG{n}{to}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsum"}} parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost comparator: comparator to: righthandside}} to express a soft sum constraint with unit coefficients to test if the sum of a set of variables matches with a given comparator and right\sphinxhyphen{}hand\sphinxhyphen{}side value.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wsum}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{quad}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n}{comparator}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}=}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{n}{to}\PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wvarsum"}} with parameters \sphinxcode{\sphinxupquote{metric: hard cost: cost comparator: comparator}} to express a hard sum constraint to restrict the sum to be comparator to the value of the last variable in the scope.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mywsum}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
         \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wvarsum}
         \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
            \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
            \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mi}{3}
            \PYG{n}{comparator}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{==}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
Comparators: let us note \textless{}\textgreater{} the comparator, K the right\sphinxhyphen{}hand\sphinxhyphen{}side (to:) value associated to the comparator, and Sum the result of the sum over the variables. For each comparator, the gap is defined according to the distance as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is == : gap = abs(K \sphinxhyphen{} Sum)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{}= : gap = max(0,Sum \sphinxhyphen{} K)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{} : gap = max(0,Sum \sphinxhyphen{} K \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is != : gap = 1 if Sum != K and gap = 0 otherwise

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{} : gap = max(0,K \sphinxhyphen{} Sum + 1);

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{}= : gap = max(0,K \sphinxhyphen{} Sum);

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Warning: the decomposition of \sphinxcode{\sphinxupquote{wsum}} and \sphinxcode{\sphinxupquote{wvarsum}} may use an exponential size (sum of domain sizes). list\_size1 and list\_size2 must be equal in \sphinxcode{\sphinxupquote{ssame}}.

\sphinxstepscope


\subsubsection{Weighted Constraint Satisfaction Problem file format (wcsp)}
\label{\detokenize{formats/wcspformat:weighted-constraint-satisfaction-problem-file-format-wcsp}}\label{\detokenize{formats/wcspformat:wcsp-format}}\label{\detokenize{formats/wcspformat::doc}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{formats/wcspformat:group__wcspformat}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{wcspformat}}}
\pysigstopsignatures
\sphinxAtStartPar
It is a text format composed of a list of numerical and string terms separated by spaces. Instead of using names for making reference to variables, variable indexes are employed. The same for domain values. All indexes start at zero.

\sphinxAtStartPar
Cost functions can be defined in intention (see below) or in extension, by their list of tuples. A default cost value is defined per function in order to reduce the size of the list. Only tuples with a different cost value should be given (not mandatory). All the cost values must be positive. The arity of a cost function in extension may be equal to zero. In this case, there is no tuples and the default cost value is added to the cost of any solution. This can be used to represent a global lower bound constant of the problem.

\sphinxAtStartPar
The wcsp file format is composed of three parts: a problem header, the list of variable domain sizes, and the list of cost functions.

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Header definition for a given problem: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Problem} \PYG{n}{name}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{variables} \PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Maximum} \PYG{n}{domain} \PYG{n}{size}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{cost} \PYG{n}{functions}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Initial} \PYG{k}{global} \PYG{n}{upper} \PYG{n}{bound} \PYG{n}{of} \PYG{n}{the} \PYG{n}{problem} \PYG{p}{(}\PYG{n}{UB}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
 The goal is to find an assignment of all the variables with minimum total cost, strictly lower than UB. Tuples with a cost greater than or equal to UB are forbidden (hard constraint).

\item {} 
\sphinxAtStartPar
Definition of domain sizes 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Domain} \PYG{n}{size} \PYG{n}{of} \PYG{n}{variable} \PYG{k}{with} \PYG{n}{index} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Domain} \PYG{n}{size} \PYG{n}{of} \PYG{n}{variable} \PYG{k}{with} \PYG{n}{index} \PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Note : domain values range from zero to \sphinxstyleemphasis{size\sphinxhyphen{}1} 

\sphinxAtStartPar
Note : a negative domain size is interpreted as a variable with an interval domain in \([0,-size-1]\)

\sphinxAtStartPar
Warning : variables with interval domains are restricted to arithmetic and disjunctive cost functions in intention (see below)

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
General definition of cost functions\begin{itemize}
\item {} 
\sphinxAtStartPar
Definition of a cost function in extension 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Arity} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Default} \PYG{n}{cost} \PYG{n}{value}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{tuples} \PYG{k}{with} \PYG{n}{a} \PYG{n}{cost} \PYG{n}{different} \PYG{n}{than} \PYG{n}{the} \PYG{n}{default} \PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
 followed by for every tuple with a cost different than the default cost: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{value} \PYG{n}{assigned} \PYG{n}{to} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{value} \PYG{n}{assigned} \PYG{n}{to} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Cost} \PYG{n}{of} \PYG{n}{the} \PYG{n+nb}{tuple}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\end{itemize}


\sphinxAtStartPar
Note : Shared cost function: A cost function in extension can be shared by several cost functions with the same arity (and same domain sizes) but different scopes. In order to do that, the cost function to be shared must start by a negative scope size. Each shared cost function implicitly receives an occurrence number starting from 1 and incremented at each new shared definition. New cost functions in extension can reuse some previously defined shared cost functions in extension by using a negative number of tuples representing the occurrence number of the desired shared cost function. Note that default costs should be the same in the shared and new cost functions. Here is an example of 4 variables with domain size 4 and one AllDifferent hard constraint decomposed into 6 binary constraints.

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shared CF used inside a small example in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AllDifferentDecomposedIntoBinaryConstraints} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{6} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
Definition of a cost function in intension by replacing the default cost value by \sphinxhyphen{}1 and by giving its keyword name and its K parameters 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Arity} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{o}{\PYGZlt{}}\PYG{n}{keyword}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter1}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameterK}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Possible keywords of cost functions defined in intension followed by their specific parameters:\begin{itemize}
\item {} 
\sphinxAtStartPar
\textgreater{}= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x \geq y + cst\) with associated cost function \(max( (y + cst - x \leq delta)?(y + cst - x):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textgreater{} \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x > y + cst\) with associated cost function \(max( (y + cst + 1 - x \leq delta)?(y + cst + 1 - x):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textless{}= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x \leq y + cst\) with associated cost function \(max( (x - cst - y \leq delta)?(x - cst - y):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textless{} \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x < y + cst\) with associated cost function \(max( (x - cst + 1 - y \leq delta)?(x - cst + 1 - y):UB , 0 )\)

\item {} 
\sphinxAtStartPar
= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x = y + cst\) with associated cost function \((|y + cst - x| \leq delta)?|y + cst - x|:UB\)

\item {} 
\sphinxAtStartPar
disj \sphinxstyleemphasis{cstx} \sphinxstyleemphasis{csty} \sphinxstyleemphasis{penalty} to express soft binary disjunctive constraint \(x \geq y + csty \vee y \geq x + cstx\) with associated cost function \((x \geq y + csty \vee y \geq x + cstx)?0:penalty\)

\item {} 
\sphinxAtStartPar
sdisj \sphinxstyleemphasis{cstx} \sphinxstyleemphasis{csty} \sphinxstyleemphasis{xinfty} \sphinxstyleemphasis{yinfty} \sphinxstyleemphasis{costx} \sphinxstyleemphasis{costy} to express a special disjunctive constraint with three implicit hard constraints \(x \leq xinfty\) and \(y \leq yinfty\) and \(x < xinfty \wedge y < yinfty \Rightarrow (x \geq y + csty \vee y \geq x + cstx)\) and an additional cost function \(((x = xinfty)?costx:0) + ((y= yinfty)?costy:0)\)

\item {} 
\sphinxAtStartPar
Global cost functions using a dedicated propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
clique \sphinxstyleemphasis{1} (\sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})*)* to express a hard clique cut to restrict the number of variables taking their value into a given set of values (per variable) to at most \sphinxstyleemphasis{1} occurrence for all the variables (warning! it assumes also a clique of binary constraints already exists to forbid any two variables using both the restricted values)

\item {} 
\sphinxAtStartPar
knapsack \sphinxstyleemphasis{capacity} (\sphinxstyleemphasis{weight})* to express a reverse knapsack constraint (i.e., a linear constraint on 0/1 variables with \textgreater{}= operator) with capacity and weights are positive or negative integer coefficients (use negative numbers to express a linear constraint with \textless{}= operator)

\item {} 
\sphinxAtStartPar
knapsackp \sphinxstyleemphasis{capacity} (\sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{weight})*)* to express a reverse knapsack constraint with for each variable the list of values to select the item in the knapsack with their corresponding weight

\end{itemize}


\item {} 
\sphinxAtStartPar
Global cost functions using a flow\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
salldiff var|dec|decbi \sphinxstyleemphasis{cost} to express a soft alldifferent constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{dec} and \sphinxstyleemphasis{decbi} keywords) cost semantic with a given \sphinxstyleemphasis{cost} per violation (\sphinxstyleemphasis{decbi} decomposes into a binary cost function complete network)

\item {} 
\sphinxAtStartPar
sgcc var|dec|wdec \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} (\sphinxstyleemphasis{shortage\_weight} \sphinxstyleemphasis{excess\_weight})?)* to express a soft global cardinality constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{dec} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound (if \sphinxstyleemphasis{wdec} then violation cost depends on each value shortage or excess weights)

\item {} 
\sphinxAtStartPar
ssame \sphinxstyleemphasis{cost} \sphinxstyleemphasis{list\_size1} \sphinxstyleemphasis{list\_size2} (\sphinxstyleemphasis{variable\_index})* (\sphinxstyleemphasis{variable\_index})* to express a permutation constraint on two lists of variables of equal size (implicit variable\sphinxhyphen{}based cost semantic)

\item {} 
\sphinxAtStartPar
sregular var|edit \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state})* to express a soft regular constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or edit distance\sphinxhyphen{}based (\sphinxstyleemphasis{edit} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation followed by the definition of a deterministic finite automaton with number of states, list of initial and final states, and list of state transitions where symbols are domain values

\end{itemize}


\end{itemize}


\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Global cost functions using a dynamic programming DAG\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
sregulardp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state})* to express a soft regular constraint with a variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation followed by the definition of a deterministic finite automaton with number of states, list of initial and final states, and list of state transitions where symbols are domain values

\item {} 
\sphinxAtStartPar
sgrammar|sgrammardp var|weight \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_symbols} \sphinxstyleemphasis{nb\_values} \sphinxstyleemphasis{start\_symbol} \sphinxstyleemphasis{nb\_rules} ((0 \sphinxstyleemphasis{terminal\_symbol} \sphinxstyleemphasis{value})|(1 \sphinxstyleemphasis{nonterminal\_in} \sphinxstyleemphasis{nonterminal\_out\_left} \sphinxstyleemphasis{nonterminal\_out\_right})|(2 \sphinxstyleemphasis{terminal\_symbol} \sphinxstyleemphasis{value} \sphinxstyleemphasis{weight})|(3 \sphinxstyleemphasis{nonterminal\_in} \sphinxstyleemphasis{nonterminal\_out\_left} \sphinxstyleemphasis{nonterminal\_out\_right} \sphinxstyleemphasis{weight}))* to express a soft/weighted grammar in Chomsky normal form

\item {} 
\sphinxAtStartPar
samong|samongdp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* to express a soft among constraint to restrict the number of variables taking their value into a given set of values

\item {} 
\sphinxAtStartPar
salldiffdp var \sphinxstyleemphasis{cost} to express a soft alldifferent constraint with variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation (decomposes into samongdp cost functions)

\item {} 
\sphinxAtStartPar
sgccdp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express a soft global cardinality constraint with variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound (decomposes into samongdp cost functions)

\item {} 
\sphinxAtStartPar
max|smaxdp \sphinxstyleemphasis{defCost} \sphinxstyleemphasis{nbtuples} (\sphinxstyleemphasis{variable} \sphinxstyleemphasis{value} \sphinxstyleemphasis{cost})* to express a weighted max cost function to find the maximum cost over a set of unary cost functions associated to a set of variables (by default, \sphinxstyleemphasis{defCost} if unspecified)

\item {} 
\sphinxAtStartPar
MST|smstdp to express a spanning tree hard constraint where each variable is assigned to its parent variable index in order to build a spanning tree (the root being assigned to itself)

\end{itemize}


\end{itemize}


\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Global cost functions using a cost function network\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
wregular \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state} and cost)* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state} and cost)* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state} \sphinxstyleemphasis{cost})* to express a weighted regular constraint with weights on initial states, final states, and transitions, followed by the definition of a deterministic finite automaton with number of states, list of initial and final states with their costs, and list of weighted state transitions where symbols are domain values

\item {} 
\sphinxAtStartPar
walldiff hard|lin|quad \sphinxstyleemphasis{cost} to express a soft alldifferent constraint as a set of wamong hard constraint (\sphinxstyleemphasis{hard} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{lin} and \sphinxstyleemphasis{quad} keywords) cost semantic with a given \sphinxstyleemphasis{cost} per violation

\item {} 
\sphinxAtStartPar
wgcc hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express a soft global cardinality constraint as either a hard constraint (\sphinxstyleemphasis{hard} keyword) or with decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{lin} and \sphinxstyleemphasis{quad} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound

\item {} 
\sphinxAtStartPar
wsame hard|lin|quad \sphinxstyleemphasis{cost} to express a permutation constraint on two lists of variables of equal size (implicitly concatenated in the scope) using implicit decomposition\sphinxhyphen{}based cost semantic

\item {} 
\sphinxAtStartPar
wsamegcc hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express the combination of a soft global cardinality constraint and a permutation constraint

\item {} 
\sphinxAtStartPar
wamong hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} to express a soft among constraint to restrict the number of variables taking their value into a given set of values

\item {} 
\sphinxAtStartPar
wvaramong hard \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* to express a hard among constraint to restrict the number of variables taking their value into a given set of values to be equal to the last variable in the scope

\item {} 
\sphinxAtStartPar
woverlap hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} \sphinxstyleemphasis{righthandside} overlaps between two sequences of variables X, Y (i.e. set the fact that Xi and Yi take the same value (not equal to zero))

\item {} 
\sphinxAtStartPar
wsum hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} \sphinxstyleemphasis{righthandside} to express a soft sum constraint with unit coefficients to test if the sum of a set of variables matches with a given comparator and right\sphinxhyphen{}hand\sphinxhyphen{}side value

\item {} 
\sphinxAtStartPar
wvarsum hard \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} to express a hard sum constraint to restrict the sum to be \sphinxstyleemphasis{comparator} to the value of the last variable in the scope

\item {} 
\sphinxAtStartPar
wdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a dual encoding such that there is a given minimum Hamming distance to a given variable assignment

\item {} 
\sphinxAtStartPar
whdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a hidden encoding such that there is a given minimum Hamming distance to a given variable assignment

\item {} 
\sphinxAtStartPar
wtdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a ternary encoding such that there is a given minimum Hamming distance to a given variable assignment

\sphinxAtStartPar
Let us note \textless{}\textgreater{} the comparator, K the right\sphinxhyphen{}hand\sphinxhyphen{}side value associated to the comparator, and Sum the result of the sum over the variables. For each comparator, the gap is defined according to the distance as follows:\begin{itemize}
\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is == : gap = abs(K \sphinxhyphen{} Sum)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{}= : gap = max(0,Sum \sphinxhyphen{} K)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{} : gap = max(0,Sum \sphinxhyphen{} K \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is != : gap = 1 if Sum != K and gap = 0 otherwise

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{} : gap = max(0,K \sphinxhyphen{} Sum + 1);

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{}= : gap = max(0,K \sphinxhyphen{} Sum);

\end{itemize}


\end{itemize}


\end{itemize}


\sphinxAtStartPar
Warning : The decomposition of wsum and wvarsum may use an exponential size (sum of domain sizes).

\sphinxAtStartPar
Warning : \sphinxstyleemphasis{list\_size1} and \sphinxstyleemphasis{list\_size2} must be equal in \sphinxstyleemphasis{ssame}.

\sphinxAtStartPar
Warning : Cost functions defined in intention cannot be shared.

\sphinxAtStartPar
Note More about network\sphinxhyphen{}based global cost functions can be found on ./misc/doc/DecomposableGlobalCostFunctions.html

\sphinxAtStartPar
Examples:\begin{itemize}
\item {} 
\sphinxAtStartPar
quadratic cost function \(x0 * x1\) in extension with variable domains \(\{0,1\}\) (equivalent to a soft clause \(\neg x0 \vee \neg x1\)):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
simple arithmetic hard constraint \(x1 < x2\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
hard temporal disjunction \(x1 \geq x2 + 2 \vee x2 \geq x1 + 1\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{disj} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{n}{UB} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
clique cut (\{x0,x1,x2,x3\}) on Boolean variables such that value 1 is used at most once:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{clique} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
knapsack constraint ( \(2 * x0 + 3 * x1 + 4 * x2 + 5 * x3 >= 10\)) on four Boolean 0/1 variables:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{knapsack} \PYG{l+m+mi}{10} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
knapsackp constraint ( \(2 * (x0=0) + 3 * (x1=1) + 4 * (x2=2) + 5 * (x3=0 \vee x3=1) >= 10\)) on four \{0,1,2\}\sphinxhyphen{}domain variables:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{knapsackp} \PYG{l+m+mi}{10} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_alldifferent(\{x0,x1,x2,x3\}):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_gcc(\{x1,x2,x3,x4\}) with each value \sphinxstyleemphasis{v} from 1 to 4 only appearing at least v\sphinxhyphen{}1 and at most v+1 times:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sgcc} \PYG{n}{var} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_same(\{x0,x1,x2,x3\},\{x4,x5,x6,x7\}):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{ssame} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_regular(\{x1,x2,x3,x4\}) with DFA (3*)+(4*):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sregular} \PYG{n}{var} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_grammar(\{x0,x1,x2,x3\}) with hard cost (1000) producing well\sphinxhyphen{}formed parenthesis expressions:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sgrammardp} \PYG{n}{var} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_among(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i \in \{1,2\}) < 1\) or \(\sum_{i=1}^4(x_i \in \{1,2\}) > 3\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{samongdp} \PYG{n}{var} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft max(\{x0,x1,x2,x3\}) with cost equal to \(\max_{i=0}^3((x_i!=i)?1000:(4-i))\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{smaxdp} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wregular(\{x0,x1,x2,x3\}) with DFA (0(10)*2*):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wregular} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{9} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wamong(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i \in \{1,2\}) < 1\) or \(\sum_{i=1}^4(x_i \in \{1,2\}) > 3\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wamong} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wvaramong(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^3(x_i \in \{1,2\}) \neq x_4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wvaramong} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
woverlap(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^2(x_i = x_{i+2}) \geq 1\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{woverlap} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wsum(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i) \neq 4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wsum} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{==} \PYG{l+m+mi}{4} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wvarsum(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^3(x_i) \neq x_4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wvarsum} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{==} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wdiverse(\{x0,x1,x2,x3\}) hard constraint on four variables with minimum Hamming distance of 2 to the value assignment (1,1,0,0):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wdiverse} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Latin Square 4 x 4 crisp CSP example in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{latin4} \PYG{l+m+mi}{16} \PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9} \PYG{l+m+mi}{10} \PYG{l+m+mi}{11} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{12} \PYG{l+m+mi}{13} \PYG{l+m+mi}{14} \PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{12} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5} \PYG{l+m+mi}{9} \PYG{l+m+mi}{13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{6} \PYG{l+m+mi}{10} \PYG{l+m+mi}{14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{3} \PYG{l+m+mi}{7} \PYG{l+m+mi}{11} \PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\sphinxAtStartPar
4\sphinxhyphen{}queens binary weighted CSP example with random unary costs in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{n}{WQUEENS} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{10} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}
 

\end{fulllineitems}


\sphinxstepscope


\subsubsection{UAI and LG formats (.uai, .LG)}
\label{\detokenize{formats/uailgformat:uai-and-lg-formats-uai-lg}}\label{\detokenize{formats/uailgformat:uai-lg-format}}\label{\detokenize{formats/uailgformat::doc}}
\sphinxAtStartPar
It is a simple text file format specified below to describe probabilistic graphical model instances. The format is a generalization of the Ergo file format initially developed by Noetic Systems Inc. for their Ergo software.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Structure}

\sphinxAtStartPar
A file in the UAI format consists of the following two parts, in that order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Preamble}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{Function} \PYG{n}{tables}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The contents of each section (denoted \(<...>\) above) are described in the following:

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Preamble}

\sphinxAtStartPar
The preamble starts with one line denoting the type of network. This will be either BAYES (if the network is a Bayesian network) or MARKOV (in case of a Markov network). This is followed by a line containing the number of variables. The next line specifies each variable’s domain size, one at a time, separated by whitespace (note that this implies an order on the variables which will be used throughout the file).

\sphinxAtStartPar
The fourth line contains only one integer, denoting the number of functions in the problem (conditional probability tables for Bayesian networks, general factors for Markov networks). Then, one function per line, the scope of each function is given as follows: The first integer in each line specifies the size of the function’s scope, followed by the actual indexes of the variables in the scope. The order of this list is not restricted, except when specifying a conditional probability table (CPT) in a Bayesian network, where the child variable has to come last. Also note that variables are indexed starting with 0.

\sphinxAtStartPar
For instance, a general function over variables 0, 5 and 11 would have this entry:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5} \PYG{l+m+mi}{11}
\end{sphinxVerbatim}

\sphinxAtStartPar
A simple Markov network preamble with three variables and two functions might for instance look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MARKOV}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line denotes the Markov network, the second line tells us the problem consists of three variables, let’s refer to them as X, Y, and Z. Their domain size is 2, 2, and 3 respectively (from the third line). Line four specifies that there are 2 functions. The scope of the first function is X,Y, while the second function is defined over X,Y,Z.

\sphinxAtStartPar
An example preamble for a Belief network over three variables (and therefore with three functions) might be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BAYES}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line signals a Bayesian network. This example has three variables, let’s call them X, Y, and Z, with domain size 2, 2, and 3, respectively (from lines two and three). Line four says that there are 3 functions (CPTs in this case). The scope of the first function is given in line five as just X (the probability P(X)), the second one is defined over X and Y (this is (Y | X)). The third function, from line seven, is the CPT P(Z | Y). We can therefore deduce that the joint probability for this problem factors as P(X,Y,Z) = P(X).P(Y | X).P(Z | Y).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Function tables}

\sphinxAtStartPar
In this section each function is specified by giving its full table (i.e, specifying the function value for each tuple). The order of the functions is identical to the one in which they were introduced in the preamble.

\sphinxAtStartPar
For each function table, first the number of entries is given (this should be equal to the product of the domain sizes of the variables in the scope). Then, one by one, separated by whitespace, the values for each assignment to the variables in the function’s scope are enumerated. Tuples are implicitly assumed in ascending order, with the last variable in the scope as the ‘least significant’.

\sphinxAtStartPar
To illustrate, we continue with our Bayesian network example from above, let’s assume the following conditional probability tables:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X}      \PYG{n}{P}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}
\PYG{l+m+mi}{0}      \PYG{l+m+mf}{0.436}
\PYG{l+m+mi}{1}      \PYG{l+m+mf}{0.564}

\PYG{n}{X}      \PYG{n}{Y}         \PYG{n}{P}\PYG{p}{(}\PYG{n}{Y} \PYG{o}{|} \PYG{n}{X}\PYG{p}{)}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.128}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.872}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.920}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.080}

\PYG{n}{Y}      \PYG{n}{Z}         \PYG{n}{P}\PYG{p}{(}\PYG{n}{Z} \PYG{o}{|} \PYG{n}{Y}\PYG{p}{)}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.210}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.333}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{2}         \PYG{l+m+mf}{0.457}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.811}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{2}         \PYG{l+m+mf}{0.189}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
The corresponding function tables in the file would then look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
 \PYG{l+m+mf}{0.436} \PYG{l+m+mf}{0.564}

\PYG{l+m+mi}{4}
 \PYG{l+m+mf}{0.128} \PYG{l+m+mf}{0.872}
 \PYG{l+m+mf}{0.920} \PYG{l+m+mf}{0.080}

\PYG{l+m+mi}{6}
 \PYG{l+m+mf}{0.210} \PYG{l+m+mf}{0.333} \PYG{l+m+mf}{0.457}
 \PYG{l+m+mf}{0.811} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.189}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Note that line breaks and empty lines are effectively just whitespace, exactly like plain spaces ” “. They are used here to improve readability.)

\sphinxAtStartPar
In the LG format, probabilities are replaced by their logarithm.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Summary}

\sphinxAtStartPar
To sum up, a problem file consists of 2 sections: the preamble and the full the function tables, the names and the labels.

\sphinxAtStartPar
For our Markov network example above, the full file could be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MARKOV}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}

\PYG{l+m+mi}{4}
 \PYG{l+m+mf}{4.000} \PYG{l+m+mf}{2.400}
 \PYG{l+m+mf}{1.000} \PYG{l+m+mf}{0.000}

\PYG{l+m+mi}{12}
 \PYG{l+m+mf}{2.2500} \PYG{l+m+mf}{3.2500} \PYG{l+m+mf}{3.7500}
 \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{10.0000}
 \PYG{l+m+mf}{1.8750} \PYG{l+m+mf}{4.0000} \PYG{l+m+mf}{3.3330}
 \PYG{l+m+mf}{2.0000} \PYG{l+m+mf}{2.0000} \PYG{l+m+mf}{3.4000}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
Here is the full Bayesian network example from above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BAYES}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}

\PYG{l+m+mi}{2}
 \PYG{l+m+mf}{0.436} \PYG{l+m+mf}{0.564}

\PYG{l+m+mi}{4}
 \PYG{l+m+mf}{0.128} \PYG{l+m+mf}{0.872}
 \PYG{l+m+mf}{0.920} \PYG{l+m+mf}{0.080}

\PYG{l+m+mi}{6}
 \PYG{l+m+mf}{0.210} \PYG{l+m+mf}{0.333} \PYG{l+m+mf}{0.457}
 \PYG{l+m+mf}{0.811} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.189}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Expressing evidence}

\sphinxAtStartPar
Evidence is specified in a separate file. This file has the same name as the original problems file but an added .evid extension at the end. For instance, problem.uai will have evidence in problem.uai.evid.

\sphinxAtStartPar
The file simply starts with a line specifying the number of evidence variables. This is followed by the pairs of variable and value indexes for each observed variable, one pair per line. The indexes correspond to the ones implied by the original problem file.

\sphinxAtStartPar
If, for our above example, we want to specify that variable Y has been observed as having its first value and Z with its second value, the file example.uai.evid would contain the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
 \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
 \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{itemize}

\sphinxstepscope


\subsubsection{Partial Weighted MaxSAT format}
\label{\detokenize{formats/cnfwcnfformat:partial-weighted-maxsat-format}}\label{\detokenize{formats/cnfwcnfformat:cnfwcnf-format}}\label{\detokenize{formats/cnfwcnfformat::doc}}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Max\sphinxhyphen{}SAT input format (.cnf)\}}

\sphinxAtStartPar
The input file format for Max\sphinxhyphen{}SAT will be in DIMACS format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{cnf} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The file can start with comments, that is lines beginning with the character ‘c’.

\item {} 
\sphinxAtStartPar
Right after the comments, there is the line “p cnf nbvar nbclauses” indicating that the instance is in CNF format; nbvar is the number of variables appearing in the file; nbclauses is the exact number of clauses contained in the file.

\item {} 
\sphinxAtStartPar
Then the clauses follow. Each clause is a sequence of distinct non\sphinxhyphen{}null numbers between \sphinxhyphen{}nbvar and nbvar ending with 0 on the same line. Positive numbers denote the corresponding variables. Negative numbers denote the negations of the corresponding variables.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Weighted Max\sphinxhyphen{}SAT input format (.wcnf)}

\sphinxAtStartPar
In Weighted Max\sphinxhyphen{}SAT, the parameters line is “p wcnf nbvar nbclauses”. The weights of each clause will be identified by the first integer in each clause line. The weight of each clause is an integer greater than or equal to 1.

\sphinxAtStartPar
Example of Weighted Max\sphinxhyphen{}SAT formula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Weighted} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{wcnf} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{10} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{5} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Partial Max\sphinxhyphen{}SAT input format (.wcnf)}

\sphinxAtStartPar
In Partial Max\sphinxhyphen{}SAT, the parameters line is “p wcnf nbvar nbclauses top”. We associate a weight with each clause, which is the first integer in the clause. Weights must be greater than or equal to 1. Hard clauses have weight top and soft clauses have weight 1. We assume that top is a weight always greater than the sum of the weights of violated soft clauses.

\sphinxAtStartPar
Example of Partial Max\sphinxhyphen{}SAT formula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Partial} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{wcnf} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{15}
\PYG{l+m+mi}{15} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Weighted Partial Max\sphinxhyphen{}SAT input format (.wcnf)}

\sphinxAtStartPar
In Weighted Partial Max\sphinxhyphen{}SAT, the parameters line is “p wcnf nbvar nbclauses top”. We associate a weight with each clause, which is the first integer in the clause. Weights must be greater than or equal to 1. Hard clauses have weight top and soft clauses have a weight smaller than top. We assume that top is a weight always greater than the sum of the weights of violated soft clauses.

\sphinxAtStartPar
Example of Weighted Partial Max\sphinxhyphen{}SAT formula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Weighted} \PYG{n}{Partial} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{wcnf} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{16}
\PYG{l+m+mi}{16} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{16} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}
\end{quote}

\sphinxstepscope


\subsubsection{QPBO format (.qpbo)}
\label{\detokenize{formats/qpboformat:qpbo-format-qpbo}}\label{\detokenize{formats/qpboformat:qpbo-format}}\label{\detokenize{formats/qpboformat::doc}}
\sphinxAtStartPar
In the quadratic pseudo\sphinxhyphen{}Boolean optimization (unconstrained quadratic programming) format, the goal is to minimize or maximize the quadratic function:

\sphinxAtStartPar
\(X' * W * X = \sum_{i=1}^N \sum_{j=1}^N  W_{ij} * X_i * X_j\)

\sphinxAtStartPar
where \(W\) is a symmetric squared \(N \times N\) matrix expressed by all its non\sphinxhyphen{}zero half (\(i \leq j\)) squared matrix coefficients, \(X\) is a vector of \(N\) binary variables with domain values in \(\{0,1\}\) or \(\{1,-1\}\), and \(X'\) is the transposed vector of \(X\).

\sphinxAtStartPar
Note that for two indices \(i \neq j\), coefficient \(W_{ij} = W_{ji}\) (symmetric matrix) and it appears twice in the previous sum.
It can be controled by the option \{tt \sphinxhyphen{}qpmult={[}double{]}\} which defines a coefficient multiplier for quadratic terms (default value is 2).

\sphinxAtStartPar
Note also that coefficients can be positive or negative and are real float numbers. They are converted to fixed\sphinxhyphen{}point real numbers by multiplying them by \(10^{precision}\) (see option \{em \sphinxhyphen{}precision\} to modify it, default value is 7).  Infinite coefficients are forbidden.

\sphinxAtStartPar
Notice that depending on the sign of the number of variables in the first text line, the domain of all variables is either \(\{0,1\}\) or \(\{1,-1\}\).

\sphinxAtStartPar
Warning! The encoding in Weighted CSP of variable domain \(\{1,-1\}\) associates for each variable value the following index: value 1 has index 0 and value \sphinxhyphen{}1 has index 1 in the solutions found by toulbar2.
The encoding  of variable domain \(\{0,1\}\) is direct.

\sphinxAtStartPar
Qpbo is a file text format:
\begin{itemize}
\item {} 
\sphinxAtStartPar
First line contains the number of variables \(N\) and the number of non\sphinxhyphen{}zero coefficients \(M\).

\sphinxAtStartPar
If \(N\) is negative then domain values are in \(\{1, -1\}\), otherwise \(\{0, 1\}\).
If \(M\) is negative then it will maximize the quadratic function, otherwise it will minimize it.

\item {} 
\sphinxAtStartPar
Followed by \(|M|\) lines where each text line contains three values separated by spaces:
position index \(i\) (integer belonging to \([1,|N|]\)),
position index \(j\) (integer belonging to \([1,|N|]\)),
coefficient \(W_{ij}\) (float number)
such that \(i \leq j\) and \(W_{ij} \neq 0\).

\end{itemize}

\sphinxstepscope


\subsubsection{OPB format (.opb)}
\label{\detokenize{formats/opbformat:opb-format-opb}}\label{\detokenize{formats/opbformat:opb-format}}\label{\detokenize{formats/opbformat::doc}}
\sphinxAtStartPar
The OPB file format is used to express pseudo\sphinxhyphen{}Boolean satisfaction and optimization models.
These models may only contain \(0/1\) Boolean variables. The format is defined by an optional objective function followed by a set of linear constraints.
Variables may be multiplied together in the objective function, but currently not in the constraints due to some restriction in the reader.
The objective function must start with the \sphinxstylestrong{min:} or \sphinxstylestrong{max:} keyword followed by \sphinxstylestrong{coef\_1 varname\_1\_1 varname\_1\_2 … coef2 varname\_2\_1 …} and end with a \sphinxstylestrong{;}.
Linear constraints are composed in the same way, ended by a comparison operator (\sphinxstylestrong{\textless{}=}, \sphinxstylestrong{\textgreater{}=}, or \sphinxstylestrong{!=}) followed by the right\sphinxhyphen{}hand side coefficient and \sphinxstylestrong{;}.
Each coefficient must be an integer beginning with its sign (\sphinxstylestrong{+} or \sphinxstylestrong{\sphinxhyphen{}} with no extra space).
Comment lines start with a *.

\sphinxAtStartPar
An example with a quadratic objective and 7 linear constraints is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{max}\PYG{p}{:} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{n}{x2} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x3} \PYG{n}{x4}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x2} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x3} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x4} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x3} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x2} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x4} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x2} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x4} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x3} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x1} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x2} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x3} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Internally, all integer costs are multiplied by a power of ten depending on the \sphinxhyphen{}precision option.
For problems with big integers, try to reduce the precision (\sphinxstyleemphasis{e.g.}, use option \sphinxhyphen{}precision 0).

\sphinxstepscope


\subsubsection{XCSP2.1 format (.xml)}
\label{\detokenize{formats/xmlformat:xcsp2-1-format-xml}}\label{\detokenize{formats/xmlformat:xml-format}}\label{\detokenize{formats/xmlformat::doc}}
\sphinxAtStartPar
CSP and weighted CSP in XML format XCSP 2.1, with constraints in extension only, can be read. See a description of this deprecated format here \sphinxurl{http://www.cril.univ-artois.fr/CPAI08/XCSP2\_1.pdf}.

\sphinxAtStartPar
Warning, toulbar2 must be compiled with a specific option XML in the cmake.


\subsubsection{XCSP3 format (.xml)}
\label{\detokenize{formats/xmlformat:xcsp3-format-xml}}
\sphinxAtStartPar
CSP and COP format in XML format XCSP3 core can be read (still on\sphinxhyphen{}going work for including globals). See a description of this format here \sphinxurl{http://xcsp.org}.

\sphinxAtStartPar
Warning, toulbar2 must be compiled with specific options XML and XCSP3 in the cmake.

\sphinxstepscope


\subsubsection{Linkage format (.pre)}
\label{\detokenize{formats/preformat:linkage-format-pre}}\label{\detokenize{formats/preformat:pre-format}}\label{\detokenize{formats/preformat::doc}}
\sphinxAtStartPar
See \sphinxstylestrong{mendelsoft} companion software at \sphinxurl{http://miat.inrae.fr/MendelSoft} for pedigree correction. See also \sphinxurl{https://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/HaplotypeInference} for haplotype inference in half\sphinxhyphen{}sib families.


\section{How do I use it ?}
\label{\detokenize{userdoc:how-do-i-use-it}}

\subsection{Using it as a C++ library}
\label{\detokenize{userdoc:using-it-as-a-c-library}}
\sphinxAtStartPar
See {\hyperref[\detokenize{refman:refman}]{\sphinxcrossref{\DUrole{std,std-ref}{toulbar2 Reference Manual}}}} which describes the libtb2.so C++ library API.


\subsection{Using it from Python}
\label{\detokenize{userdoc:using-it-from-python}}
\sphinxAtStartPar
A Python interface is now available. Compile toulbar2 with cmake option PYTB2 (and without MPI options) to generate a Python module \sphinxstylestrong{pytoulbar2} (in lib directory). See examples in \sphinxcode{\sphinxupquote{src/pytoulbar2.cpp}}
and \DUrole{xref,std,std-ref}{web/TUTORIALS} directory.

\sphinxAtStartPar
An older version of toulbar2 was integrated inside Numberjack. See \sphinxurl{https://github.com/eomahony/Numberjack}.


\section{References}
\label{\detokenize{userdoc:references}}
\sphinxAtStartPar
See ‘BIBLIOGRAPHY’ at the end of the document.

\sphinxstepscope


\chapter{Reference Manual}
\label{\detokenize{refman:reference-manual}}\label{\detokenize{refman:refman}}\label{\detokenize{refman::doc}}
\sphinxstepscope


\section{Introduction}
\label{\detokenize{ref/ref_intro:introduction}}\label{\detokenize{ref/ref_intro:ref-intro}}\label{\detokenize{ref/ref_intro::doc}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{Cost Function Network Solver}
&
\sphinxAtStartPar
toulbar2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Copyright}
&
\sphinxAtStartPar
toulbar2 team
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Source}
&
\sphinxAtStartPar
\sphinxurl{https://github.com/toulbar2/toulbar2}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
toulbar2 can be used as a stand\sphinxhyphen{}alone solver reading various problem file formats (wcsp, uai, wcnf, qpbo) or as a C++ library.

\sphinxAtStartPar
This document describes the WCSP native file format and the toulbar2 C++ library API.
\begin{description}
\sphinxlineitem{Note}
\sphinxAtStartPar
Use cmake flags LIBTB2=ON and TOULBAR2\_ONLY=OFF to get the toulbar2 C++
library libtb2.so and toulbar2test executable example.

\end{description}

\sphinxAtStartPar
\sphinxstylestrong{See also} : \sphinxcode{\sphinxupquote{src/toulbar2test.cpp}}.

\sphinxstepscope


\section{Exact optimization for cost function networks and additive graphical models}
\label{\detokenize{_files/README:exact-optimization-for-cost-function-networks-and-additive-graphical-models}}\label{\detokenize{_files/README::doc}}

\subsection{What is toulbar2?}
\label{\detokenize{_files/README:what-is-toulbar2}}\label{\detokenize{_files/README:readme-1}}
\sphinxAtStartPar
toulbar2 is an open\sphinxhyphen{}source black\sphinxhyphen{}box C++ optimizer for cost function
networks and discrete additive graphical models. It can read a variety
of formats. The optimized criteria and feasibility should be provided
factorized in local cost functions on discrete variables. Constraints
are represented as functions that produce costs that exceed a
user\sphinxhyphen{}provided primal bound. toulbar2 looks for a non\sphinxhyphen{}forbidden assignment
of all variables that optimizes the sum of all functions (a decision
NP\sphinxhyphen{}complete problem).

\sphinxAtStartPar
toulbar2 won several competitions on deterministic and probabilistic
graphical models:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Max\sphinxhyphen{}CSP 2008 Competition \sphinxhref{http://www.cril.univ-artois.fr/CPAI08/}{CPAI08} (winner on 2\sphinxhyphen{}ARY\sphinxhyphen{}EXT and N\sphinxhyphen{}ARY\sphinxhyphen{}EXT)

\item {} 
\sphinxAtStartPar
Probabilistic Inference Evaluation \sphinxhref{http://graphmod.ics.uci.edu/uai08/Evaluation/Report}{UAI 2008} (winner on several MPE tasks, inra entries)

\item {} 
\sphinxAtStartPar
2010 UAI APPROXIMATE INFERENCE CHALLENGE \sphinxhref{http://www.cs.huji.ac.il/project/UAI10/summary.php}{UAI 2010} (winner on 1200\sphinxhyphen{}second MPE task)

\item {} 
\sphinxAtStartPar
The Probabilistic Inference Challenge \sphinxhref{http://www.cs.huji.ac.il/project/PASCAL/board.php}{PIC 2011} (second place by ficolofo on 1\sphinxhyphen{}hour MAP task)

\item {} 
\sphinxAtStartPar
UAI 2014 Inference Competition \sphinxhref{http://www.hlt.utdallas.edu/~vgogate/uai14-competition/leaders.html}{UAI 2014} (winner on all MAP task categories, see Proteus, Robin, and IncTb entries)

\end{itemize}

\sphinxAtStartPar
toulbar2 is now also able to collaborate with ML code that can learn
an additive graphical model (with constraints) from data (see the
associated
\sphinxhref{https://miat.inrae.fr/schiex/Export/Pushing\_Data\_in\_your\_CP\_model.pdf}{paper},
\sphinxhref{https://miat.inrae.fr/schiex/Export/Pushing\_Data\_in\_your\_CP\_model-Slides.pdf}{slides}
and \sphinxhref{https://www.youtube.com/watch?v=IpUr6KIEjMs}{video} where it is
shown how it can learn user preferences or how to play the Sudoku
without knowing the rules). The current CFN learning code is available
on \sphinxhref{https://github.com/toulbar2/CFN-learn}{GitHub}.


\subsection{Installation from binaries}
\label{\detokenize{_files/README:installation-from-binaries}}\label{\detokenize{_files/README:readme-2}}
\sphinxAtStartPar
You can install toulbar2 directly using the package manager in Debian
and Debian derived Linux distributions (Ubuntu, Mint,…):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get update
sudo apt\PYGZhy{}get install toulbar2 toulbar2\PYGZhy{}doc
\end{sphinxVerbatim}

\sphinxAtStartPar
For the most recent binary or the Python API, compile from source.


\subsection{Python interface}
\label{\detokenize{_files/README:python-interface}}\label{\detokenize{_files/README:readme-3}}
\sphinxAtStartPar
An alpha\sphinxhyphen{}release Python interface can be tested through pip on Linux and MacOS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pip install \PYGZhy{}\PYGZhy{}upgrade pip
python3 \PYGZhy{}m pip install pytoulbar2
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line is only useful for Linux distributions that ship “old” versions of pip.

\sphinxAtStartPar
Commands for compiling the Python API on Linux/MacOS with cmake (Python module in lib/*/pytb2.cpython*.so):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir build
cd build
cmake \PYGZhy{}DPYTB2=ON ..
make
\end{sphinxVerbatim}

\sphinxAtStartPar
Move the cpython library and the experimental \sphinxhref{https://github.com/toulbar2/toulbar2/raw/master/pytoulbar2/pytoulbar2.py}{pytoulbar2.py} python class wrapper in the folder of the python script that does “import pytoulbar2”.


\subsection{Download}
\label{\detokenize{_files/README:download}}\label{\detokenize{_files/README:readme-4}}
\sphinxAtStartPar
Download the latest release from GitHub
(https://github.com/toulbar2/toulbar2) or similarly use tag versions,
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone \PYGZhy{}\PYGZhy{}branch 1.2.0 https://github.com/toulbar2/toulbar2.git
\end{sphinxVerbatim}


\subsection{Installation from sources}
\label{\detokenize{_files/README:installation-from-sources}}\label{\detokenize{_files/README:readme-5}}
\sphinxAtStartPar
Compilation requires git, cmake and a C++\sphinxhyphen{}11 capable compiler (in C++11 mode).

\sphinxAtStartPar
Required library:
\begin{itemize}
\item {} 
\sphinxAtStartPar
libgmp\sphinxhyphen{}dev

\end{itemize}

\sphinxAtStartPar
Recommended libraries (default use):
\begin{itemize}
\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}graph\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}iostreams\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}serialization\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
zlib1g\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
liblzma\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libbz2\sphinxhyphen{}dev

\end{itemize}

\sphinxAtStartPar
Optional libraries:
\begin{itemize}
\item {} 
\sphinxAtStartPar
libjemalloc\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libopenmpi\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}mpi\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libicuuc

\item {} 
\sphinxAtStartPar
libicui18n

\item {} 
\sphinxAtStartPar
libicudata

\item {} 
\sphinxAtStartPar
libxml2\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libxcsp3parser

\end{itemize}

\sphinxAtStartPar
On MacOS, run ./misc/script/MacOS\sphinxhyphen{}requirements\sphinxhyphen{}install.sh to install the recommended libraries.

\sphinxAtStartPar
Commands for compiling toulbar2 on Linux/MacOS with cmake (binary in build/bin/*/toulbar2):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir build
cd build
cmake ..
make
\end{sphinxVerbatim}

\sphinxAtStartPar
Commands for statically compiling toulbar2 on Linux in directory toulbar2/src without cmake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash
cd src
echo \PYGZsq{}\PYGZsh{}define Toulbar\PYGZus{}VERSION \PYGZdq{}1.2.0\PYGZdq{}\PYGZsq{} \PYGZgt{} ToulbarVersion.hpp
g++ \PYGZhy{}o toulbar2 \PYGZhy{}std=c++17 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}static \PYGZhy{}static\PYGZhy{}libgcc \PYGZhy{}static\PYGZhy{}libstdc++ \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DWCSPFORMATONLY \PYGZbs{}
 \PYGZhy{}I. \PYGZhy{}I./pils/src tb2*.cpp applis/*.cpp core/*.cpp globals/*.cpp incop/*.cpp pils/src/exe/*.cpp search/*.cpp utils/*.cpp vns/*.cpp ToulbarVersion.cpp \PYGZbs{}
 \PYGZhy{}lboost\PYGZus{}graph \PYGZhy{}lboost\PYGZus{}iostreams \PYGZhy{}lboost\PYGZus{}serialization \PYGZhy{}lgmp \PYGZhy{}lz \PYGZhy{}lbz2 \PYGZhy{}llzma
\end{sphinxVerbatim}

\sphinxAtStartPar
Use OPENMPI flag and MPI compiler for a parallel version of toulbar2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash
cd src
echo \PYGZsq{}\PYGZsh{}define Toulbar\PYGZus{}VERSION \PYGZdq{}1.2.0\PYGZdq{}\PYGZsq{} \PYGZgt{} ToulbarVersion.hpp
mpicxx \PYGZhy{}o toulbar2 \PYGZhy{}std=c++17 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DWCSPFORMATONLY \PYGZhy{}DOPENMPI \PYGZbs{}
 \PYGZhy{}I. \PYGZhy{}I./pils/src tb2*.cpp applis/*.cpp core/*.cpp globals/*.cpp incop/*.cpp pils/src/exe/*.cpp search/*.cpp utils/*.cpp vns/*.cpp ToulbarVersion.cpp \PYGZbs{}
 \PYGZhy{}lboost\PYGZus{}graph \PYGZhy{}lboost\PYGZus{}iostreams \PYGZhy{}lboost\PYGZus{}serialization \PYGZhy{}lboost\PYGZus{}mpi \PYGZhy{}lgmp \PYGZhy{}lz \PYGZhy{}lbz2 \PYGZhy{}llzma
\end{sphinxVerbatim}

\sphinxAtStartPar
Replace LONGLONG\_COST by INT\_COST to reduce memory usage by two and reduced cost range (costs must be smaller than 10\textasciicircum{}8).

\sphinxAtStartPar
Replace WCSPFORMATONLY by XMLFLAG3 and add libxcsp3parser.a from xcsp.org in your current directory for reading XCSP3 files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash
cd src
echo \PYGZsq{}\PYGZsh{}define Toulbar\PYGZus{}VERSION \PYGZdq{}1.2.0\PYGZdq{}\PYGZsq{} \PYGZgt{} ToulbarVersion.hpp
mpicxx \PYGZhy{}o toulbar2 \PYGZhy{}std=c++17 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DXMLFLAG3 \PYGZhy{}DOPENMPI \PYGZbs{}
 \PYGZhy{}I/usr/include/libxml2 \PYGZhy{}I. \PYGZhy{}I./pils/src \PYGZhy{}I./xmlcsp3 tb2*.cpp applis/*.cpp core/*.cpp globals/*.cpp incop/*.cpp pils/src/exe/*.cpp search/*.cpp utils/*.cpp vns/*.cpp ToulbarVersion.cpp \PYGZbs{}
 \PYGZhy{}lboost\PYGZus{}graph \PYGZhy{}lboost\PYGZus{}iostreams \PYGZhy{}lboost\PYGZus{}serialization \PYGZhy{}lboost\PYGZus{}mpi \PYGZhy{}lxml2 \PYGZhy{}licuuc \PYGZhy{}licui18n \PYGZhy{}licudata libxcsp3parser.a \PYGZhy{}lgmp \PYGZhy{}lz \PYGZhy{}lbz2 \PYGZhy{}llzma \PYGZhy{}lm \PYGZhy{}lpthread \PYGZhy{}ldl
\end{sphinxVerbatim}

\sphinxAtStartPar
Copyright (C) 2006\sphinxhyphen{}2022, toulbar2 team.
toulbar2 is currently maintained by Simon de Givry, INRAE \sphinxhyphen{} MIAT, Toulouse, France (simon.de\sphinxhyphen{}givry@inrae.fr)


\subsection{Convex Combination of multiple Criteria branch}
\label{\detokenize{_files/README:convex-combination-of-multiple-criteria-branch}}\label{\detokenize{_files/README:readme-6}}

\subsubsection{changes regarding the master toulbar2 c++/python API}
\label{\detokenize{_files/README:changes-regarding-the-master-toulbar2-c-python-api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
one new class: multiwcsp to create a wcsp as the linear combination of wcsp’s given as input

\item {} 
\sphinxAtStartPar
makeWeightedCSPSolver: possibility to give a wcsp as input, which will be used as the instance solved by the solver (works only with the base Solver class, otherwise, a new weightedCSP is created withinin the solver object)

\item {} 
\sphinxAtStartPar
adding a function for the python API for weightedCSP to read an instance independently from the solver

\item {} 
\sphinxAtStartPar
adding the multiwcsp object and methods in the python API

\item {} 
\sphinxAtStartPar
modification of the python API in makeWeightedCSPSolver to take a weightedCSP as input

\item {} 
\sphinxAtStartPar
modification of the python API to create a weightedCSP object without solvers

\item {} 
\sphinxAtStartPar
modification of the python API to read an instance file directly from a weightedCSP object

\end{itemize}

\sphinxstepscope


\section{Modules}
\label{\detokenize{ref/ref_modules:modules}}\label{\detokenize{ref/ref_modules:ref-modules}}\label{\detokenize{ref/ref_modules::doc}}

\subsection{Variable and cost function modeling}
\label{\detokenize{ref/ref_modules:variable-and-cost-function-modeling}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__modeling}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{modeling}}}
\pysigstopsignatures
\sphinxAtStartPar

\sphinxAtStartPar
Modeling a Weighted CSP consists in creating variables and cost functions.

\sphinxAtStartPar
Domains of variables can be of two different types:
\begin{itemize}
\item {} 
\sphinxAtStartPar
enumerated domain allowing direct access to each value (array) and iteration on current domain in times proportional to the current number of values (double\sphinxhyphen{}linked list)

\item {} 
\sphinxAtStartPar
interval domain represented by a lower value and an upper value only (useful for large domains)

\end{itemize}

Warning : Current implementation of toulbar2 has limited modeling and solving facilities for interval domains. There is no cost functions accepting both interval and enumerated variables for the moment, which means all the variables should have the same type.

\sphinxAtStartPar

\sphinxAtStartPar
Cost functions can be defined in extension (table or maps) or having a specific semantic.

\sphinxAtStartPar
Cost functions in extension depend on their arity:
\begin{itemize}
\item {} 
\sphinxAtStartPar
unary cost function (directly associated to an enumerated variable)

\item {} 
\sphinxAtStartPar
binary and ternary cost functions (table of costs)

\item {} 
\sphinxAtStartPar
n\sphinxhyphen{}ary cost functions (n \textgreater{}= 4) defined by a list of tuples with associated costs and a default cost for missing tuples (allows for a compact representation)

\end{itemize}

Cost functions having a specific semantic (see {\hyperref[\detokenize{formats/wcspformat:group__wcspformat}]{\sphinxcrossref{\DUrole{std,std-ref}{Weighted Constraint Satisfaction Problem file format (wcsp)}}}}) are:\begin{itemize}
\item {} 
\sphinxAtStartPar
simple arithmetic and scheduling (temporal disjunction) cost functions on interval variables

\item {} 
\sphinxAtStartPar
global cost functions (\sphinxstyleemphasis{eg} soft alldifferent, soft global cardinality constraint, soft same, soft regular, etc) with three different propagator keywords:\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{flow} propagator based on flow algorithms with “s” prefix in the keyword (\sphinxstyleemphasis{salldiff}, \sphinxstyleemphasis{sgcc}, \sphinxstyleemphasis{ssame}, \sphinxstyleemphasis{sregular})

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{DAG} propagator based on dynamic programming algorithms with “s” prefix and “dp” postfix (\sphinxstyleemphasis{samongdp}, salldiffdp, sgccdp, sregulardp, sgrammardp, smstdp, smaxdp)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{network} propagator based on cost function network decomposition with “w” prefix (\sphinxstyleemphasis{wsum}, \sphinxstyleemphasis{wvarsum}, \sphinxstyleemphasis{walldiff}, \sphinxstyleemphasis{wgcc}, \sphinxstyleemphasis{wsame}, \sphinxstyleemphasis{wsamegcc}, \sphinxstyleemphasis{wregular}, \sphinxstyleemphasis{wamong}, \sphinxstyleemphasis{wvaramong}, \sphinxstyleemphasis{woverlap})

\end{itemize}


\end{itemize}

Note : The default semantics (using \sphinxstyleemphasis{var} keyword) of monolithic (flow and DAG\sphinxhyphen{}based propagators) global cost functions is to count the number of variables to change in order to restore consistency and to multiply it by the basecost. Other particular semantics may be used in conjunction with the flow\sphinxhyphen{}based propagator

\sphinxAtStartPar
Note : The semantics of the network\sphinxhyphen{}based propagator approach is either a hard constraint (“hard” keyword) or a soft constraint by multiplying the number of changes by the basecost (“lin” or “var” keyword) or by multiplying the square value of the number of changes by the basecost (“quad” keyword)

\sphinxAtStartPar
Note : A decomposable version exists for each monolithic global cost function, except grammar and MST. The decomposable ones may propagate less than their monolithic counterpart and they introduce extra variables but they can be much faster in practice

\sphinxAtStartPar
Warning : Each global cost function may have less than three propagators implemented

\sphinxAtStartPar
Warning : Current implementation of toulbar2 has limited solving facilities for monolithic global cost functions (no BTD\sphinxhyphen{}like methods nor variable elimination)

\sphinxAtStartPar
Warning : Current implementation of toulbar2 disallows global cost functions with less than or equal to three variables in their scope (use cost functions in extension instead)

\sphinxAtStartPar
Warning : Before modeling the problem using make and post, call ::tb2init method to initialize toulbar2 global variables

\sphinxAtStartPar
Warning : After modeling the problem using make and post, call {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSP_1a31a9384d3dabf5388fe610710f2f19e0}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSP::sortConstraints}}}} method to initialize correctly the model before solving it 

\end{fulllineitems}



\subsection{Solving cost function networks}
\label{\detokenize{ref/ref_modules:solving-cost-function-networks}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__solving}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{solving}}}
\pysigstopsignatures
\sphinxAtStartPar
After creating a Weighted CSP, it can be solved using a local search method like INCOP or PILS (see {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSPSolver_1af481cf37ff94238ab1e15bff34026209}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSPSolver::narycsp}}}} or {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSPSolver_1a94898d20bff27abdb156ed2e248a8004}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSPSolver::pils}}}}) and/or an exact search method (see {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSPSolver_1ab1f9d2c018bf050a6b010680a2008171}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSPSolver::solve}}}}).

\sphinxAtStartPar

\sphinxAtStartPar
Various options of the solving methods are controlled by ::Toulbar2 static class members (see files ./src/core/tb2types.hpp and ./src/tb2main.cpp).

\sphinxAtStartPar
A brief code example reading a wcsp problem given as a single command\sphinxhyphen{}line parameter and solving it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZdq{}toulbar2lib.hpp\PYGZdq{}
\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}
int main(int argc, char **argv) \PYGZob{}

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

    // Create a solver object
    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data\PYGZhy{}type
    WeightedCSPSolver *solver = WeightedCSPSolver::makeWeightedCSPSolver(MAX\PYGZus{}COST);

    // Read a problem file in wcsp format
    solver\PYGZhy{}\PYGZgt{}read\PYGZus{}wcsp(argv[1]);

    ToulBar2::verbose = \PYGZhy{}1;  // change to 0 or higher values to see more trace information

    // Uncomment if solved using INCOP local search followed by a partial Limited Discrepancy Search with a maximum discrepancy of one
    //  ToulBar2::incop\PYGZus{}cmd = \PYGZdq{}0 1 3 idwa 100000 cv v 0 200 1 0 0\PYGZdq{};
    //  ToulBar2::lds = \PYGZhy{}1;  // remove it or change to a positive value then the search continues by a complete B\PYGZam{}B search method
    // Uncomment the following lines if solved using Decomposition Guided Variable Neighborhood Search with min\PYGZhy{}fill cluster decomposition and absorption
    // ToulBar2::lds = 4;
    // ToulBar2::restart = 10000;
    // ToulBar2::searchMethod = DGVNS;
    // ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    // ToulBar2::boostingBTD = 0.7;
    // ToulBar2::varOrder = reinterpret\PYGZus{}cast\PYGZlt{}char*\PYGZgt{}(\PYGZhy{}3);

    if (solver\PYGZhy{}\PYGZgt{}solve()) \PYGZob{}
        // show (sub\PYGZhy{})optimal solution
        vector\PYGZlt{}Value\PYGZgt{} sol;
        Cost ub = solver\PYGZhy{}\PYGZgt{}getSolution(sol);
        cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Best solution found cost: \PYGZdq{} \PYGZlt{}\PYGZlt{} ub \PYGZlt{}\PYGZlt{} endl;
        cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Best solution found:\PYGZdq{};
        for (unsigned int i=0; i\PYGZlt{}sol.size(); i++) cout \PYGZlt{}\PYGZlt{} ((i\PYGZgt{}0)?\PYGZdq{},\PYGZdq{}:\PYGZdq{}\PYGZdq{}) \PYGZlt{}\PYGZlt{} \PYGZdq{} x\PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{} = \PYGZdq{} \PYGZlt{}\PYGZlt{} sol[i];
        cout \PYGZlt{}\PYGZlt{} endl;
    \PYGZcb{} else \PYGZob{}
        cout \PYGZlt{}\PYGZlt{} \PYGZdq{}No solution found!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;
    \PYGZcb{}
    delete solver;
\PYGZcb{}
\end{sphinxVerbatim}


\sphinxAtStartPar
See : another code example in ./src/toulbar2test.cpp

\sphinxAtStartPar
Warning : variable domains must start at zero, otherwise recompile libtb2.so without flag WCSPFORMATONLY 

\end{fulllineitems}


\sphinxAtStartPar
\sphinxstylestrong{toulbar2test.cpp}
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{toulbar2test.cpp}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

/**
 * Test toulbar2 API
 */

\PYGZsh{}include \PYGZdq{}toulbar2lib.hpp\PYGZdq{}

\PYGZsh{}include \PYGZdq{}core/tb2wcsp.hpp\PYGZdq{}
\PYGZsh{}include \PYGZdq{}vns/tb2vnsutils.hpp\PYGZdq{}
\PYGZsh{}include \PYGZdq{}vns/tb2dgvns.hpp\PYGZdq{}
\PYGZsh{}ifdef OPENMPI
\PYGZsh{}include \PYGZdq{}vns/tb2cpdgvns.hpp\PYGZdq{}
\PYGZsh{}include \PYGZdq{}vns/tb2rpdgvns.hpp\PYGZdq{}
\PYGZsh{}endif
\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}

// INCOP default command line option
const string Incop\PYGZus{}cmd = \PYGZdq{}0 1 3 idwa 100000 cv v 0 200 1 0 0\PYGZdq{};

int main(int argc, char* argv[])
\PYGZob{}
\PYGZsh{}ifdef OPENMPI
    mpi::environment env; // equivalent to MPI\PYGZus{}Init via the constructor and MPI\PYGZus{}finalize via the destructor
    mpi::communicator world;
\PYGZsh{}endif

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

\PYGZsh{}ifdef OPENMPI
    if (world.rank() == WeightedCSPSolver::MASTER)
        ToulBar2::verbose = \PYGZhy{}1; // change to 0 or higher values to see more trace information
    else
        ToulBar2::verbose = \PYGZhy{}1;
\PYGZsh{}else
    ToulBar2::verbose = \PYGZhy{}1; // change to 0 or higher values to see more trace information
\PYGZsh{}endif

    // uncomment if Virtual Arc Consistency (equivalent to Augmented DAG algorithm) enable
    //	ToulBar2::vac = 1; // option \PYGZhy{}A
    //	ToulBar2::vacValueHeuristic = true; // option \PYGZhy{}V
    // uncomment if partial Limited Discrepancy Search enable
    //	ToulBar2::lds = 1;  // option \PYGZhy{}l=1
    // uncomment if INCOP local search enable
    //	ToulBar2::incop\PYGZus{}cmd = Incop\PYGZus{}cmd; // option \PYGZhy{}i
    // uncomment the following lines if variable neighborhood search enable
    //ToulBar2::lds = 4;
    //ToulBar2::restart = 10000;
    //\PYGZsh{}ifdef OPENMPI
    //     if (world.size() \PYGZgt{} 1) \PYGZob{}
    //    	 ToulBar2::searchMethod = RPDGVNS;
    //    	 ToulBar2::vnsParallel = true;
    //    	 ToulBar2::vnsNeighborVarHeur = MASTERCLUSTERRAND;
    //    	 ToulBar2::vnsParallelSync = false;
    //     \PYGZcb{} else \PYGZob{}
    //    	 ToulBar2::searchMethod = DGVNS;
    //    	 ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    //     \PYGZcb{}
    //\PYGZsh{}else
    //	ToulBar2::searchMethod = DGVNS;
    //	ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    //**or**
    //  ToulBar2::searchMethod = VNS;
    //  ToulBar2::vnsNeighborVarHeur = RANDOMVAR;
    //\PYGZsh{}endif

    // create a problem with three 0/1 variables
    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data\PYGZhy{}type
    WeightedCSPSolver* solver = WeightedCSPSolver::makeWeightedCSPSolver(MAX\PYGZus{}COST);
    int x = solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}x\PYGZdq{}, 0, 1); // note that for efficiency issue, I assume domain values start at zero (otherwise remove flag \PYGZhy{}DWCSPFORMATONLY in Makefile)
    int y = solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}y\PYGZdq{}, 0, 1);
    int z = solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}z\PYGZdq{}, 0, 1);

    // add random unary cost functions on each variable
    mysrand(getpid());
    \PYGZob{}
        vector\PYGZlt{}Cost\PYGZgt{} costs(2, 0);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postUnary(x, costs);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postUnary(y, costs);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postUnary(z, costs);
    \PYGZcb{}

    // add binary cost functions (Ising) on each pair of variables
    \PYGZob{}
        vector\PYGZlt{}Cost\PYGZgt{} costs;
        for (unsigned int i = 0; i \PYGZlt{} 2; i++) \PYGZob{}
            for (unsigned int j = 0; j \PYGZlt{} 2; j++) \PYGZob{}
                costs.push\PYGZus{}back((solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(x, i) == solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(y, j)) ? 0 : 30); // penalizes by a cost=30 if variables are assigned to different values
            \PYGZcb{}
        \PYGZcb{}
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(x, y, costs);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(x, z, costs);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(y, z, costs);
    \PYGZcb{}

    // add a ternary hard constraint (x+y=z)
    \PYGZob{}
        vector\PYGZlt{}Cost\PYGZgt{} costs;
        for (unsigned int i = 0; i \PYGZlt{} 2; i++) \PYGZob{}
            for (unsigned int j = 0; j \PYGZlt{} 2; j++) \PYGZob{}
                for (unsigned int k = 0; k \PYGZlt{} 2; k++) \PYGZob{}
                    costs.push\PYGZus{}back((solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(x, i) + solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(y, j) == solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(z, k)) ? 0 : MAX\PYGZus{}COST);
                \PYGZcb{}
            \PYGZcb{}
        \PYGZcb{}
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postTernaryConstraint(x, y, z, costs);
    \PYGZcb{}

    solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}sortConstraints(); // must be done before the search

    //	int verbose = ToulBar2::verbose;
    //	ToulBar2::verbose = 5;  // high verbosity to see the cost functions
    //	solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}print(cout);
    //	ToulBar2::verbose = verbose;

    //tb2checkOptions();
    if (solver\PYGZhy{}\PYGZgt{}solve()) \PYGZob{}
\PYGZsh{}ifdef OPENMPI
        if (world.rank() == WeightedCSPSolver::MASTER) \PYGZob{}
\PYGZsh{}endif
            // show optimal solution
            vector\PYGZlt{}Value\PYGZgt{} sol;
            Cost optimum = solver\PYGZhy{}\PYGZgt{}getSolution(sol);
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Optimum=\PYGZdq{} \PYGZlt{}\PYGZlt{} optimum \PYGZlt{}\PYGZlt{} endl;
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Solution: x=\PYGZdq{} \PYGZlt{}\PYGZlt{} sol[x] \PYGZlt{}\PYGZlt{} \PYGZdq{} ,y=\PYGZdq{} \PYGZlt{}\PYGZlt{} sol[y] \PYGZlt{}\PYGZlt{} \PYGZdq{} ,z=\PYGZdq{} \PYGZlt{}\PYGZlt{} sol[z] \PYGZlt{}\PYGZlt{} endl;
\PYGZsh{}ifdef OPENMPI
        \PYGZcb{}
\PYGZsh{}endif
    \PYGZcb{} else \PYGZob{}
\PYGZsh{}ifdef OPENMPI
        if (world.rank() == WeightedCSPSolver::MASTER) \PYGZob{}
\PYGZsh{}endif
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}No solution found!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;
\PYGZsh{}ifdef OPENMPI
        \PYGZcb{}
\PYGZsh{}endif
    \PYGZcb{}
    // cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Problem lower bound: \PYGZdq{} \PYGZlt{}\PYGZlt{} solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}getLb() \PYGZlt{}\PYGZlt{} endl; // initial problem lower bound possibly enhanced by value removals at the root during search

    delete solver;
    return 0;
\PYGZcb{}

/* Local Variables: */
/* c\PYGZhy{}basic\PYGZhy{}offset: 4 */
/* tab\PYGZhy{}width: 4 */
/* indent\PYGZhy{}tabs\PYGZhy{}mode: nil */
/* c\PYGZhy{}default\PYGZhy{}style: \PYGZdq{}k\PYGZam{}r\PYGZdq{} */
/* End: */
\end{sphinxVerbatim}
\end{quote}


\subsection{Output messages, verbosity options and debugging}
\label{\detokenize{ref/ref_modules:output-messages-verbosity-options-and-debugging}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__verbosity}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{verbosity}}}
\pysigstopsignatures
\sphinxAtStartPar
Depending on verbosity level given as option “\sphinxhyphen{}v=level”, \sphinxcode{\sphinxupquote{toulbar2}} will output:\begin{itemize}
\item {} 
\sphinxAtStartPar
(level=0, no verbosity) default output mode: shows version number, number of variables and cost functions read in the problem file, number of unassigned variables and cost functions after preprocessing, problem upper and lower bounds after preprocessing. Outputs current best solution cost found, ends by giving the optimum or “No solution”. Last output line should always be: “end.”

\item {} 
\sphinxAtStartPar
(level=\sphinxhyphen{}1, no verbosity) restricted output mode: do not print current best solution cost found

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
(level=1) shows also search choices (“{[}”\sphinxstyleemphasis{search\_depth} \sphinxstyleemphasis{problem\_lower\_bound} \sphinxstyleemphasis{problem\_upper\_bound} \sphinxstyleemphasis{sum\_of\_current\_domain\_sizes”{]} Try”} \sphinxstyleemphasis{variable\_index} \sphinxstyleemphasis{operator} \sphinxstyleemphasis{value}) with \sphinxstyleemphasis{operator} being assignment (“==”), value removal (“!=”), domain splitting (“\textless{}=” or “\textgreater{}=”, also showing EAC value in parenthesis)

\item {} 
\sphinxAtStartPar
(level=2) shows also current domains (\sphinxstyleemphasis{variable\_index} \sphinxstyleemphasis{list\_of\_current\_domain\_values} “/” \sphinxstyleemphasis{number\_of\_cost\_functions} (see approximate degree in {\hyperref[\detokenize{ref/ref_modules:group__varelim}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable elimination}}}}) “/” \sphinxstyleemphasis{weighted\_degree} \sphinxstyleemphasis{list\_of\_unary\_costs} “s:” \sphinxstyleemphasis{support\_value}) before each search choice and reports problem lower bound increases, NC bucket sort data (see {\hyperref[\detokenize{ref/ref_modules:group__ncbucket}]{\sphinxcrossref{\DUrole{std,std-ref}{NC bucket sort}}}}), and basic operations on domains of variables

\item {} 
\sphinxAtStartPar
(level=3) reports also basic arc EPT operations on cost functions (see {\hyperref[\detokenize{ref/ref_modules:group__softac}]{\sphinxcrossref{\DUrole{std,std-ref}{Soft arc consistency and problem reformulation}}}})

\item {} 
\sphinxAtStartPar
(level=4) shows also current list of cost functions for each variable and reports more details on arc EPT operations (showing all changes in cost functions)

\item {} 
\sphinxAtStartPar
(level=5) reports more details on cost functions defined in extension giving their content (cost table by first increasing values in the current domain of the last variable in the scope)

\end{enumerate}


\sphinxAtStartPar
For debugging purposes, another option “\sphinxhyphen{}Z=level” allows one to monitor the search:\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
(level 1) shows current search depth (number of search choices from the root of the search tree) and reports statistics on nogoods for BTD\sphinxhyphen{}like methods

\item {} 
\sphinxAtStartPar
(level 2) idem

\item {} 
\sphinxAtStartPar
(level 3) also saves current problem into a file before each search choice

\end{enumerate}


\sphinxAtStartPar
Note : \sphinxcode{\sphinxupquote{toulbar2}}, compiled in debug mode, can be more verbose and it checks a lot of assertions (pre/post conditions in the code)

\sphinxAtStartPar
Note : \sphinxcode{\sphinxupquote{toulbar2}} will output an help message giving available options if run without any parameters 

\end{fulllineitems}



\subsection{Preprocessing techniques}
\label{\detokenize{ref/ref_modules:preprocessing-techniques}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__preprocessing}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{preprocessing}}}
\pysigstopsignatures
\sphinxAtStartPar
Depending on toulbar2 options, the sequence of preprocessing techniques applied before the search is:\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{i\sphinxhyphen{}bounded} variable elimination with user\sphinxhyphen{}defined \sphinxstyleemphasis{i} bound

\item {} 
\sphinxAtStartPar
pairwise decomposition of cost functions (binary cost functions are implicitly decomposed by soft AC and empty cost function removals)

\item {} 
\sphinxAtStartPar
MinSumDiffusion propagation (see VAC)

\item {} 
\sphinxAtStartPar
projects\&substracts n\sphinxhyphen{}ary cost functions in extension on all the binary cost functions inside their scope (3 \textless{} n \textless{} max, see toulbar2 options)

\item {} 
\sphinxAtStartPar
functional variable elimination (see {\hyperref[\detokenize{ref/ref_modules:group__varelim}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable elimination}}}})

\item {} 
\sphinxAtStartPar
projects\&substracts ternary cost functions in extension on their three binary cost functions inside their scope (before that, extends the existing binary cost functions to the ternary cost function and applies pairwise decomposition)

\item {} 
\sphinxAtStartPar
creates new ternary cost functions for all triangles (\sphinxstyleemphasis{ie} occurences of three binary cost functions \sphinxstyleemphasis{xy}, \sphinxstyleemphasis{yz}, \sphinxstyleemphasis{zx})

\item {} 
\sphinxAtStartPar
removes empty cost functions while repeating \#1 and \#2 until no new cost functions can be removed

\end{enumerate}


\sphinxAtStartPar
Note : the propagation loop is called after each preprocessing technique (see WCSP::propagate) 

\end{fulllineitems}



\subsection{Variable and value search ordering heuristics}
\label{\detokenize{ref/ref_modules:variable-and-value-search-ordering-heuristics}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__heuristics}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{heuristics}}}
\pysigstopsignatures
\sphinxAtStartPar
See : \sphinxstyleemphasis{ Boosting Systematic Search by Weighting Constraints }. Frederic Boussemart, Fred Hemery, Christophe Lecoutre, Lakhdar Sais. Proc. of ECAI 2004, pages 146\sphinxhyphen{}150. Valencia, Spain, 2004.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Last Conflict Based Reasoning }. Christophe Lecoutre, Lakhdar Sais, Sebastien Tabary, Vincent Vidal. Proc. of ECAI 2006, pages 133\sphinxhyphen{}137. Trentino, Italy, 2006.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Solution\sphinxhyphen{}based phase saving for CP: A value\sphinxhyphen{}selection heuristic to simulate local search behavior in complete solvers }. Emir Demirovic, Geoffrey Chu, and Peter Stuckey. Proc. of CP\sphinxhyphen{}18, pages 99\textendash{}108. Lille, France, 2018. 

\end{fulllineitems}



\subsection{Soft arc consistency and problem reformulation}
\label{\detokenize{ref/ref_modules:soft-arc-consistency-and-problem-reformulation}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__softac}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{softac}}}
\pysigstopsignatures
\sphinxAtStartPar
Soft arc consistency is an incremental lower bound technique for optimization problems. Its goal is to move costs from high\sphinxhyphen{}order (typically arity two or three) cost functions towards the problem lower bound and unary cost functions. This is achieved by applying iteratively local equivalence\sphinxhyphen{}preserving problem transformations (EPTs) until some terminating conditions are met.

\sphinxAtStartPar
Note : \sphinxstyleemphasis{eg} an EPT can move costs between a binary cost function and a unary cost function such that the sum of the two functions remains the same for any complete assignment.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Arc consistency for Soft Constraints. } T. Schiex. Proc. of CP’2000. Singapour, 2000.

\sphinxAtStartPar
Note : Soft Arc Consistency in toulbar2 is limited to binary and ternary and some global cost functions (\sphinxstyleemphasis{eg} alldifferent, gcc, regular, same). Other n\sphinxhyphen{}ary cost functions are delayed for propagation until their number of unassigned variables is three or less.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction. } Jimmy Ho\sphinxhyphen{}Man Lee, Ka Lun Leung. Proc. of IJCAI 2009, pages 559\sphinxhyphen{}565. Pasadena, USA, 2009. 

\end{fulllineitems}



\subsection{Virtual Arc Consistency enforcing}
\label{\detokenize{ref/ref_modules:virtual-arc-consistency-enforcing}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__VAC}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{VAC}}}
\pysigstopsignatures
\sphinxAtStartPar
The three phases of VAC are enforced in three different “Pass”. Bool(P) is never built. Instead specific functions (getVACCost) booleanize the WCSP on the fly. The domain variables of Bool(P) are the original variable domains (saved and restored using trailing at each iteration). All the counter data\sphinxhyphen{}structures (k) are timestamped to avoid clearing them at each iteration.

\sphinxAtStartPar
Note : Simultaneously AC (and potentially DAC, EAC) are maintained by proper queuing.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Soft Arc Consistency Revisited. } Cooper et al. Artificial Intelligence. 2010. 

\end{fulllineitems}



\subsection{NC bucket sort}
\label{\detokenize{ref/ref_modules:nc-bucket-sort}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__ncbucket}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{ncbucket}}}
\pysigstopsignatures
\sphinxAtStartPar
maintains a sorted list of variables having non\sphinxhyphen{}zero unary costs in order to make NC propagation incremental.\begin{itemize}
\item {} 
\sphinxAtStartPar
variables are sorted into buckets

\item {} 
\sphinxAtStartPar
each bucket is associated to a single interval of non\sphinxhyphen{}zero costs (using a power\sphinxhyphen{}of\sphinxhyphen{}two scaling, first bucket interval is {[}1,2{[}, second interval is {[}2,4{[}, etc.)

\item {} 
\sphinxAtStartPar
each variable is inserted into the bucket corresponding to its largest unary cost in its domain

\item {} 
\sphinxAtStartPar
variables having all unary costs equal to zero do not belong to any bucket

\end{itemize}


\sphinxAtStartPar
NC propagation will revise only variables in the buckets associated to costs sufficiently large wrt current objective bounds. 

\end{fulllineitems}



\subsection{Variable elimination}
\label{\detokenize{ref/ref_modules:variable-elimination}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__varelim}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{varelim}}}
\pysigstopsignatures
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{i\sphinxhyphen{}bounded} variable elimination eliminates all variables with a degree less than or equal to \sphinxstyleemphasis{i}. It can be done with arbitrary i\sphinxhyphen{}bound in preprocessing only and iff all their cost functions are in extension.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{i\sphinxhyphen{}bounded} variable elimination with i\sphinxhyphen{}bound less than or equal to two can be done during the search.

\item {} 
\sphinxAtStartPar
functional variable elimination eliminates all variables which have a bijective or functional binary hard constraint (\sphinxstyleemphasis{ie} ensuring a one\sphinxhyphen{}to\sphinxhyphen{}one or several\sphinxhyphen{}to\sphinxhyphen{}one value mapping) and iff all their cost functions are in extension. It can be done without limit on their degree, in preprocessing only.

\end{itemize}


\sphinxAtStartPar
Note : Variable elimination order used in preprocessing is either lexicographic or given by an external file *.order (see toulbar2 options)

\sphinxAtStartPar
Note : 2\sphinxhyphen{}bounded variable elimination during search is optimal in the sense that any elimination order should result in the same final graph

\sphinxAtStartPar
Warning : It is not possible to display/save solutions when bounded variable elimination is applied in preprocessing

\sphinxAtStartPar
Warning : toulbar2 maintains a list of current cost functions for each variable. It uses the size of these lists as an approximation of variable degrees. During the search, if variable \sphinxstyleemphasis{x} has three cost functions \sphinxstyleemphasis{xy}, \sphinxstyleemphasis{xz}, \sphinxstyleemphasis{xyz}, its true degree is two but its approximate degree is three. In toulbar2 options, it is the approximate degree which is given by the user for variable elimination during the search (thus, a value at most three). But it is the true degree which is given by the user for variable elimination in preprocessing. 

\end{fulllineitems}



\subsection{Propagation loop}
\label{\detokenize{ref/ref_modules:propagation-loop}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__propagation}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{propagation}}}
\pysigstopsignatures
\sphinxAtStartPar

\sphinxAtStartPar
Propagates soft local consistencies and bounded variable elimination until all the propagation queues are empty or a contradiction occurs.

\sphinxAtStartPar
While (queues are not empty or current objective bounds have changed):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
queue for bounded variable elimination of degree at most two (except at preprocessing)

\item {} 
\sphinxAtStartPar
BAC queue

\item {} 
\sphinxAtStartPar
EAC queue

\item {} 
\sphinxAtStartPar
DAC queue

\item {} 
\sphinxAtStartPar
AC queue

\item {} 
\sphinxAtStartPar
monolithic (flow\sphinxhyphen{}based and DAG\sphinxhyphen{}based) global cost function propagation (partly incremental)

\item {} 
\sphinxAtStartPar
NC queue

\item {} 
\sphinxAtStartPar
returns to \#1 until all the previous queues are empty

\item {} 
\sphinxAtStartPar
DEE queue

\item {} 
\sphinxAtStartPar
returns to \#1 until all the previous queues are empty

\item {} 
\sphinxAtStartPar
VAC propagation (not incremental)

\item {} 
\sphinxAtStartPar
returns to \#1 until all the previous queues are empty (and problem is VAC if enable)

\item {} 
\sphinxAtStartPar
exploits goods in pending separators for BTD\sphinxhyphen{}like methods

\end{enumerate}


\sphinxAtStartPar
Queues are first\sphinxhyphen{}in / first\sphinxhyphen{}out lists of variables (avoiding multiple insertions). In case of a contradiction, queues are explicitly emptied by WCSP::whenContradiction 

\end{fulllineitems}



\subsection{Backtrack management}
\label{\detokenize{ref/ref_modules:backtrack-management}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__backtrack}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{backtrack}}}
\pysigstopsignatures
\sphinxAtStartPar
Used by backtrack search methods. Allows to copy / restore the current state using Store::store and Store::restore methods. All storable data modifications are trailed into specific stacks.

\sphinxAtStartPar
Trailing stacks are associated to each storable type:\begin{itemize}
\item {} 
\sphinxAtStartPar
Store::storeValue for storable domain values ::StoreValue (value supports, etc)

\item {} 
\sphinxAtStartPar
Store::storeInt for storable integer values ::StoreInt (number of non assigned variables in nary cost functions, etc)

\item {} 
\sphinxAtStartPar
Store::storeCost for storable costs ::StoreCost (inside cost functions, etc)

\item {} 
\sphinxAtStartPar
Store::storeDomain for enumerated domains (to manage holes inside domains)

\item {} 
\sphinxAtStartPar
Store::storeIndexList for integer lists (to manage edge connections in global cost functions)

\item {} 
\sphinxAtStartPar
Store::storeConstraint for backtrackable lists of constraints

\item {} 
\sphinxAtStartPar
Store::storeVariable for backtrackable lists of variables

\item {} 
\sphinxAtStartPar
Store::storeSeparator for backtrackable lists of separators (see tree decomposition methods)

\item {} 
\sphinxAtStartPar
Store::storeBigInteger for very large integers ::StoreBigInteger used in solution counting methods

\end{itemize}


\sphinxAtStartPar
Memory for each stack is dynamically allocated by part of \(2^x\) with \sphinxstyleemphasis{x} initialized to ::STORE\_SIZE and increased when needed.

\sphinxAtStartPar
Note : storable data are not trailed at depth 0.

\sphinxAtStartPar
Warning : Current storable data management is not multi\sphinxhyphen{}threading safe! (Store is a static virtual class relying on StoreBasic\textless{}T\textgreater{} static members) 

\end{fulllineitems}


\sphinxstepscope


\section{Libraries}
\label{\detokenize{ref/ref_lib:libraries}}\label{\detokenize{ref/ref_lib:ref-lib}}\label{\detokenize{ref/ref_lib::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
C++ Library : see “C++ Library of toulbar2” document.

\item {} 
\sphinxAtStartPar
Python Library : see “Python Library of toulbar2” document.

\end{itemize}

\sphinxstepscope


\chapter{Documentation in pdf}
\label{\detokenize{pdfmanuals:documentation-in-pdf}}\label{\detokenize{pdfmanuals:pdf-manuals}}\label{\detokenize{pdfmanuals::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Main documentation :
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{toulbar2}}
\end{quote}

\item {} 
\sphinxAtStartPar
API Reference :
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Class Diagram}} |
\sphinxcode{\sphinxupquote{C++ Library of toulbar2}} |
\sphinxcode{\sphinxupquote{Python Library of toulbar2}}
\end{quote}

\item {} 
\sphinxAtStartPar
Some extracts :
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{User manual}} |
\sphinxcode{\sphinxupquote{Reference manual}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{WCSP format}} |
\sphinxcode{\sphinxupquote{CFN format}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Tutorials}} |
\sphinxcode{\sphinxupquote{Use cases}}
\end{quote}

\end{itemize}

\sphinxstepscope


\chapter{Publications}
\label{\detokenize{publications:publications}}\label{\detokenize{publications:id1}}\label{\detokenize{publications::doc}}

\section{Conference talks}
\label{\detokenize{publications:conference-talks}}\begin{itemize}
\item {} 
\sphinxAtStartPar
ANITI webinar on toulbar2 for industrial applications :
\sphinxhref{https://miat.inrae.fr/degivry/GivryANITI2021.pdf}{slides} in English |
\sphinxhref{https://youtu.be/lH04asuheo8}{talk} in French

\item {} 
\sphinxAtStartPar
talk on toulbar2 latest algorithmic features at \sphinxhref{http://miat.inrae.fr/degivry/GivryISMP2018.pdf}{ISMP 2018}, Bordeaux, France, July 6, 2018.

\item {} 
\sphinxAtStartPar
toulbar2 projects meeting at \sphinxhref{https://cp2016.sched.org/event/89xl}{CP 2016}, Toulouse, France, September 5, 2016.

\end{itemize}


\section{Related publications}
\label{\detokenize{publications:related-publications}}

\subsection{What are the algorithms inside toulbar2 ?}
\label{\detokenize{publications:what-are-the-algorithms-inside-toulbar2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Soft arc consistencies (NC, AC, DAC, FDAC)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/schiex/Doc/Export/IJCAI03.pdf}{In the quest of the best form of local consistency for Weighted CSP},
J. Larrosa \& T. Schiex,
In Proc. of IJCAI\sphinxhyphen{}03. Acapulco, Mexico, 2003.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Soft existential arc consistency (EDAC)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Heras05.pdf}{Existential arc consistency: Getting closer to full arc consistency in weighted csps},
S. de Givry, M. Zytnicki, F. Heras, and J. Larrosa,
In Proc. of IJCAI\sphinxhyphen{}05, Edinburgh, Scotland, 2005.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Depth\sphinxhyphen{}first Branch and Bound exploiting a tree decomposition (BTD)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Schiex06a.pdf}{Exploiting Tree Decomposition and Soft Local Consistency in Weighted CSP},
S. de Givry, T. Schiex, and G. Verfaillie,
In Proc. of AAAI\sphinxhyphen{}06, Boston, MA, 2006 .

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Virtual arc consistency (VAC)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Cooper08.pdf}{Virtual arc consistency for weighted csp},
M. Cooper, S. de Givry, M. Sanchez, T. Schiex, and M. Zytnicki
In Proc. of AAAI\sphinxhyphen{}08, Chicago, IL, 2008.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Soft generalized arc consistencies (GAC, FDGAC)}

\sphinxAtStartPar
\sphinxhref{http://www.cse.cuhk.edu.hk/~jlee/publ/09/globalWcspIJCAI09.pdf}{Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction},
J. H. M. Lee and K. L. Leung,
In Proc. of IJCAI\sphinxhyphen{}09, Pasadena (CA), USA, 2009.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Russian doll search exploiting a tree decomposition (RDS\sphinxhyphen{}BTD)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Sanchez09a.pdf}{Russian doll search with tree decomposition},
M Sanchez, D Allouche, S de Givry, and T Schiex,
In Proc. of IJCAI\sphinxhyphen{}09, Pasadena (CA), USA, 2009.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Soft bounds arc consistency (BAC)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Zytnicki09a.pdf}{Bounds Arc Consistency for Weighted CSPs},
M. Zytnicki, C. Gaspin, S. de Givry, and T. Schiex,
Journal of Artificial Intelligence Research, 35:593\sphinxhyphen{}621, 2009.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Counting solutions in satisfaction (\#BTD, Approx\_\#BTD)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Favier09a.pdf}{Exploiting problem structure for solution counting},
A. Favier, S. de Givry, and P. Jégou,
In Proc. of CP\sphinxhyphen{}09, Lisbon, Portugal, 2009.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Soft existential generalized arc consistency (EDGAC)}

\sphinxAtStartPar
\sphinxhref{https://www.aaai.org/ocs/index.php/AAAI/AAAI10/paper/download/1797/1939}{A Stronger Consistency for Soft Global Constraints in Weighted Constraint Satisfaction},
J. H. M. Lee and K. L. Leung,
In Proc. of AAAI\sphinxhyphen{}10, Boston, MA, 2010 .

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Preprocessing techniques (combines variable elimination and cost function decomposition)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Favier11a.pdf}{Pairwise decomposition for combinatorial optimization in graphical models},
A Favier, S de Givry, A Legarra, and T Schiex,
In Proc. of IJCAI\sphinxhyphen{}11, Barcelona, Spain, 2011.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Decomposable global cost functions (wregular, wamong, wsum)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Ficolofo2012.pdf}{Decomposing global cost functions},
D Allouche, C Bessiere, P Boizumault, S de Givry, P Gutierrez, S Loudni, JP Métivier, and T Schiex,
In Proc. of AAAI\sphinxhyphen{}12, Toronto, Canada, 2012.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pruning by dominance (DEE)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Givry13a.pdf}{Dead\sphinxhyphen{}End Elimination for Weighted CSP},
S de Givry, S Prestwich, and B O’Sullivan,
In Proc. of CP\sphinxhyphen{}13, pages 263\sphinxhyphen{}272, Uppsala, Sweden, 2013.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Hybrid best\sphinxhyphen{}first search exploiting a tree decomposition (HBFS)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Katsirelos15a.pdf}{Anytime Hybrid Best\sphinxhyphen{}First Search with Tree Decomposition for Weighted CSP},
D Allouche, S de Givry, G Katsirelos, T Schiex, and M Zytnicki,
In Proc. of CP\sphinxhyphen{}15, Cork, Ireland, 2015.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Unified parallel decomposition guided variable neighborhood search (UDGVNS/UPDGVNS)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Ouali17.pdf}{Iterative Decomposition Guided Variable Neighborhood Search for Graphical Model Energy Minimization},
A Ouali, D Allouche, S de Givry, S Loudni, Y Lebbah, F Eckhardt, and L Loukil,
In Proc. of UAI\sphinxhyphen{}17, pages 550\sphinxhyphen{}559, Sydney, Australia, 2017.

\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Ouali19a.pdf}{Variable Neighborhood Search for Graphical Model Energy Minimization},
A Ouali, D Allouche, S de Givry, S Loudni, Y Lebbah, L Loukil, and P Boizumault,
Artificial Intelligence, 2020.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Clique cut global cost function (clique)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Katsirelos17a.pdf}{Clique Cuts in Weighted Constraint Satisfaction},
S de Givry and G Katsirelos,
In Proc. of CP\sphinxhyphen{}17, pages 97\sphinxhyphen{}113, Melbourne, Australia, 2017.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Greedy sequence of diverse solutions (div)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Ruffini19a.pdf}{Guaranteed diversity \& quality for the Weighted CSP},
M Ruffini, J Vucinic, S de Givry, G Katsirelos, S Barbe, and T Schiex,
In Proc. of ICTAI\sphinxhyphen{}19, pages 18\sphinxhyphen{}25, Portland, OR, USA, 2019.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{VAC\sphinxhyphen{}integrality based variable heuristics and initial upper\sphinxhyphen{}bound probing (vacint and rasps)}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Trosser20a.pdf}{Relaxation\sphinxhyphen{}Aware Heuristics for Exact Optimization in Graphical Models},
F Trösser, S de Givry and G Katsirelos,
In Proc. of CPAIOR\sphinxhyphen{}20, Vienna, Austria, 2020.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Partition crossover iterative local search (pils)}

\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Beuvin21a.pdf}{Iterated local search with partition crossover for computational protein design},
François Beuvin, Simon de Givry, Thomas Schiex, Sébastien Verel, and David Simoncini,
Proteins: Structure, Function, and Bioinformatics, 2021.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Knapsack/generalized linear global constraint (knapsack/knapsackp)}

\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Montalbano22a.pdf}{Multiple\sphinxhyphen{}choice knapsack constraint in graphical models},
P Montalbano, S de Givry, and G Katsirelos,
In Proc. of CP\sphinxhyphen{}AI\sphinxhyphen{}OR’2022, Los Angeles, CA, 2022.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Parallel hybrid best\sphinxhyphen{}first search (parallel HBFS)}

\sphinxAtStartPar
\sphinxhref{https://miat.inrae.fr/degivry/Beldjilali22a.pdf}{Parallel Hybrid Best\sphinxhyphen{}First Search},
A Beldjilali, P Montalbano, D Allouche, G Katsirelos, and S de Givry,
In Proc. of CP\sphinxhyphen{}22, volume 235, pages 7:1\sphinxhyphen{}7:10, Haifa, Israel, 2022.

\end{itemize}


\subsection{toulbar2 for Combinatorial Optimization in Life Sciences}
\label{\detokenize{publications:toulbar2-for-combinatorial-optimization-in-life-sciences}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Computational Protein Design}

\sphinxAtStartPar
Designing Peptides on a Quantum Computer,
Vikram Khipple Mulligan, Hans Melo, Haley Irene Merritt, Stewart Slocum, Brian D. Weitzner, Andrew M. Watkins, P. Douglas Renfrew, Craig Pelissier, Paramjit S. Arora, and Richard Bonneau,
bioRxiv, 2019.

\sphinxAtStartPar
Computational design of symmetrical eight\sphinxhyphen{}bladed \(\beta\)\sphinxhyphen{}propeller proteins,
Noguchi, H., Addy, C., Simoncini, D., Wouters, S., Mylemans, B., Van Meervelt, L., Schiex, T., Zhang, K., Tameb, J., and Voet, A.,
IUCrJ, 6(1), 2019.

\sphinxAtStartPar
Positive Multi\sphinxhyphen{}State Protein Design,
Jelena Vučinić, David Simoncini, Manon Ruffini, Sophie Barbe, Thomas Schiex,
Bioinformatics, 2019.

\sphinxAtStartPar
Cost function network\sphinxhyphen{}based design of protein\sphinxhyphen{}protein interactions: predicting changes in binding affinity,
Clément Viricel, Simon de Givry, Thomas Schiex, and Sophie Barbe,
Bioinformatics, 2018.

\sphinxAtStartPar
Algorithms for protein design,
Pablo Gainza, Hunter M Nisonoff, Bruce R Donald,
Current Opinion in Structural Biology, 39:6\sphinxhyphen{}26, 2016.

\sphinxAtStartPar
Fast search algorithms for computational protein design,
Seydou Traoré, Kyle E Roberts, David Allouche, Bruce R Donald, Isabelle André, Thomas Schiex, and Sophie Barbe,
Journal of computational chemistry, 2016.

\sphinxAtStartPar
Comparing three stochastic search algorithms for computational protein design: Monte Carlo, replica exchange Monte Carlo, and a multistart, steepest\sphinxhyphen{}descent heuristic,
David Mignon, Thomas Simonson,
Journal of computational chemistry, 2016.

\sphinxAtStartPar
Protein sidechain conformation predictions with an mmgbsa energy function,
Thomas Gaillard, Nicolas Panel, and Thomas Simonson,
Proteins: Structure, Function, and Bioinformatics, 2016.

\sphinxAtStartPar
Improved energy bound accuracy enhances the efficiency of continuous protein design,
Kyle E Roberts and Bruce R Donald,
Proteins: Structure, Function, and Bioinformatics, 83(6):1151\sphinxhyphen{}1164, 2015.

\sphinxAtStartPar
Guaranteed discrete energy optimization on large protein design problems,
D. Simoncini, D. Allouche, S. de Givry, C. Delmas, S. Barbe, and T. Schiex,
Journal of Chemical Theory and Computation, 2015.

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Schiex14a.pdf}{Computational protein design as an optimization problem},
David Allouche, Isabelle André, Sophie Barbe, Jessica Davies, Simon de Givry, George Katsirelos, Barry O’Sullivan, Steve Prestwich, Thomas Schiex, and Seydou Traoré,
Journal of Artificial Intelligence, 212:59\sphinxhyphen{}79, 2014.

\sphinxAtStartPar
A new framework for computational protein design through cost function network optimization,
Seydou Traoré, David Allouche, Isabelle André, Simon de Givry, George Katsirelos, Thomas Schiex, and Sophie Barbe,
Bioinformatics, 29(17):2129\sphinxhyphen{}2136, 2013.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Genetics}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Favier10a.pdf}{Optimal haplotype reconstruction in half\sphinxhyphen{}sib families},
Aurélie Favier, Jean\sphinxhyphen{}Michel Elsen, Simon de Givry, and Andrès Legarra,
ICLP\sphinxhyphen{}10 workshop on Constraint Based Methods for Bioinformatics, Edinburgh, UK, 2010.

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Sanchez07a.pdf}{Mendelian error detection in complex pedigrees using weighted constraint satisfaction techniques},
Marti Sanchez, Simon de Givry, and Thomas Schiex,
Constraints, 13(1\sphinxhyphen{}2):130\sphinxhyphen{}154, 2008.
See also \sphinxhref{http://miat.inrae.fr/MendelSoft}{Mendelsoft} integrated in the \sphinxhref{https://forge-dga.jouy.inra.fr/projects/qtlmap}{QTLmap} Quantitative Genetics platform from INRA GA dept.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{RNA motif search}

\sphinxAtStartPar
Darn! a weighted constraint solver for RNA motif localization,
Matthias Zytnicki, Christine Gaspin, and Thomas Schiex,
Constraints, 13(1\sphinxhyphen{}2):91\sphinxhyphen{}109, 2008.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Agronomy}

\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Akplogan13.pdf}{Solving the crop allocation problem using hard and soft constraints},
Mahuna Akplogan, Simon de Givry, Jean\sphinxhyphen{}Philippe Métivier, Gauthier Quesnel, Alexandre Joannon, and Frédérick Garcia,
RAIRO \sphinxhyphen{} Operations Research, 47:151\sphinxhyphen{}172, 2013.

\end{itemize}


\subsection{Other publications mentioning toulbar2}
\label{\detokenize{publications:other-publications-mentioning-toulbar2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Constraint Satisfaction, Distributed Constraint Optimization}

\sphinxAtStartPar
Graph Based Optimization For Multiagent Cooperation,
Arambam James Singh, Akshat Kumar, In Proc. of AAMAS, 2019.

\sphinxAtStartPar
Probabilistic Inference Based Message\sphinxhyphen{}Passing for Resource Constrained DCOPs,
Supriyo Ghosh, Akshat Kumar, Pradeep Varakantham, In Proc. of IJCAI, 2015.

\sphinxAtStartPar
SAT\sphinxhyphen{}based MaxSAT algorithms,
Carlos Ansótegui and Maria Luisa Bonet and Jordi Levy,
Artificial Intelligence, 196:77\sphinxhyphen{}105, 2013.

\sphinxAtStartPar
Local Consistency and SAT\sphinxhyphen{}Solvers, P. Jeavons and J. Petke, Journal of Artificial Intelligence Research, 43:329\sphinxhyphen{}351, 2012.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Data Mining and Machine Learning}

\sphinxAtStartPar
Pushing Data in CP Models Using Graphical Model Learning and Solving,
Céline Brouard, Simon de Givry, and Thomas Schiex,
In Proc. of CP\sphinxhyphen{}20, Louvain\sphinxhyphen{}la\sphinxhyphen{}neuve, Belgium, 2020.

\sphinxAtStartPar
A constraint programming approach for mining sequential patterns in a sequence database,
Jean\sphinxhyphen{}Philippe Métivier, Samir Loudni, and Thierry Charnois,
In Proc. of the ECML/PKDD Workshop on Languages for Data Mining and Machine Learning, Praha, Czech republic, 2013.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Timetabling, planning and POMDP}

\sphinxAtStartPar
Solving a Judge Assignment Problem Using Conjunctions of Global Cost Functions,
S de Givry, J.H.M. Lee, K.L. Leung, and Y.W. Shum,
In Proc. of CP\sphinxhyphen{}14, pages 797\sphinxhyphen{}812, Lyon, France, 2014.

\sphinxAtStartPar
Optimally solving Dec\sphinxhyphen{}POMDPs as continuous\sphinxhyphen{}state MDPs,
Jilles Steeve Dibangoye, Christopher Amato, Olivier Buffet, and François Charpillet,
In Proc. of IJCAI, pages 90\sphinxhyphen{}96, 2013.

\sphinxAtStartPar
A weighted csp approach to cost\sphinxhyphen{}optimal planning,
Martin C Cooper, Marie de Roquemaurel, and Pierre Régnier,
Ai Communications, 24(1):1\sphinxhyphen{}29, 2011.

\sphinxAtStartPar
Point\sphinxhyphen{}based backup for decentralized POMDPs: Complexity and new algorithms,
Akshat Kumar and Shlomo Zilberstein,
In Proceedings of the 9th International Conference on Autonomous Agents and Multiagent Systems, 1:1315\sphinxhyphen{}1322, 2010.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Inference, Sampling, and Diagnostic}

\sphinxAtStartPar
Mohamed\sphinxhyphen{}Hamza Ibrahim, Christopher Pal and Gilles Pesant,
Leveraging cluster backbones for improving MAP inference in statistical relational models,
In Ann. Math. Artif. Intell. 88, No. 8, 907\sphinxhyphen{}949, 2020.

\sphinxAtStartPar
C. Viricel, D. Simoncini, D. Allouche, S. de Givry, S. Barbe, and T. Schiex,
Approximate counting with deterministic guarantees for affinity computations,
In Proc. of Modeling, Computation and Optimization in Information Systems and Management Sciences \sphinxhyphen{} MCO’15, Metz, France, 2015.

\sphinxAtStartPar
Discrete sampling with universal hashing,
Stefano Ermon, Carla P Gomes, Ashish Sabharwal, and Bart Selman,
In Proc. of NIPS, pages 2085\sphinxhyphen{}2093, 2013.

\sphinxAtStartPar
Compiling ai engineering models for probabilistic inference,
Paul Maier, Dominik Jain, and Martin Sachenbacher,
In KI 2011: Advances in Artifcial Intelligence, pages 191\sphinxhyphen{}203, 2011.

\sphinxAtStartPar
Diagnostic hypothesis enumeration vs. probabilistic inference for hierarchical automata models,
Paul Maier, Dominik Jain, and Martin Sachenbacher,
In Proc. of the International Workshop on Principles of Diagnosis, Murnau, Germany, 2011.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Computer Vision and Energy Minimization}

\sphinxAtStartPar
Exact MAP\sphinxhyphen{}inference by Confining Combinatorial Search with LP Relaxation,
Stefan Haller, Paul Swoboda, Bogdan Savchynskyy,
In Proc. of AAAI, 2018.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Computer Music}

\sphinxAtStartPar
Exploiting structural relationships in audio music signals using markov logic networks,
Hélène Papadopoulos and George Tzanetakis,
In Proc. of 38th International Conference on Acoustics, Speech, and Signal Processing (ICASSP), pages 4493\sphinxhyphen{}4497, Canada, 2013.

\sphinxAtStartPar
Modeling chord and key structure with markov logic,
Hélène Papadopoulos and George Tzanetakis,
In Proc. of the Society for Music Information Retrieval (ISMIR), pages 121\sphinxhyphen{}126, 2012.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Inductive Logic Programming}

\sphinxAtStartPar
Extension of the top\sphinxhyphen{}down data\sphinxhyphen{}driven strategy to ILP,
Erick Alphonse and Céline Rouveirol,
In Proc. of Inductive Logic Programming, pages 49\sphinxhyphen{}63, 2007.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Other domains}

\sphinxAtStartPar
An automated model abstraction operator implemented in the multiple modeling environment MOM,
Peter Struss, Alessandro Fraracci, and D Nyga,
In Proc. of the 25th International Workshop on Qualitative Reasoning, Barcelona, Spain, 2011.

\sphinxAtStartPar
Modeling Flowchart Structure Recognition as a Max\sphinxhyphen{}Sum Problem,
Martin Bresler, Daniel Prusa, Václav Hlavác,
In Proc. of International Conference on Document Analysis and Recognition, Washington, DC, USA, 1215\sphinxhyphen{}1219, 2013.

\end{itemize}

\begin{sphinxthebibliography}{Katsirel}
\bibitem[Beldjilali22]{userdoc:beldjilali22}
\sphinxAtStartPar
A Beldjilali, P Montalbano, D Allouche, G Katsirelos and S de Givry.
Parallel Hybrid Best\sphinxhyphen{}First Search.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}22}, Haifa, Israel, 2022.
\bibitem[Schiex2020b]{userdoc:schiex2020b}
\sphinxAtStartPar
Céline Brouard and Simon de Givry and Thomas Schiex.
Pushing Data in CP Models Using Graphical Model Learning and Solving.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}20}, Louvain\sphinxhyphen{}la\sphinxhyphen{}neuve, Belgium, 2020.
\bibitem[Trosser2020a]{userdoc:trosser2020a}
\sphinxAtStartPar
Fulya Trösser, Simon de Givry and George Katsirelos.
Relaxation\sphinxhyphen{}Aware Heuristics for Exact Optimization in Graphical Models.
In \sphinxstyleemphasis{Proc.of CP\sphinxhyphen{}AI\sphinxhyphen{}OR’2020}, Vienna, Austria, 2020.
\bibitem[Ruffini2019a]{userdoc:ruffini2019a}
\sphinxAtStartPar
M. Ruffini, J. Vucinic, S. de Givry, G. Katsirelos, S. Barbe and T. Schiex.
Guaranteed Diversity \& Quality for the Weighted CSP.
In \sphinxstyleemphasis{Proc. of ICTAI\sphinxhyphen{}19}, pages 18\sphinxhyphen{}25, Portland, OR, USA, 2019.
\bibitem[Ouali2017]{userdoc:ouali2017}
\sphinxAtStartPar
Abdelkader Ouali, David Allouche, Simon de Givry, Samir Loudni, Yahia Lebbah, Francisco Eckhardt, Lakhdar Loukil.
Iterative Decomposition Guided Variable Neighborhood Search for Graphical Model Energy Minimization.
In \sphinxstyleemphasis{Proc. of UAI\sphinxhyphen{}17}, pages 550\sphinxhyphen{}559, Sydney, Australia, 2017.
\bibitem[Schiex2016a]{userdoc:schiex2016a}
\sphinxAtStartPar
David Allouche, Christian Bessière, Patrice Boizumault, Simon de Givry, Patricia Gutierrez, Jimmy H.M. Lee, Ka Lun Leung, Samir Loudni, Jean\sphinxhyphen{}Philippe Métivier, Thomas Schiex and Yi Wu.
Tractability\sphinxhyphen{}preserving transformations of global cost functions.
\sphinxstyleemphasis{Artificial Intelligence}, 238:166\sphinxhyphen{}189, 2016.
\bibitem[Hurley2016b]{userdoc:hurley2016b}
\sphinxAtStartPar
B Hurley, B O’Sullivan, D Allouche, G Katsirelos, T Schiex, M Zytnicki and S de Givry.
Multi\sphinxhyphen{}Language Evaluation of Exact Solvers in Graphical Model Discrete Optimization.
\sphinxstyleemphasis{Constraints}, 21(3):413\sphinxhyphen{}434, 2016.
Presentation at CPAIOR’16, Banff, Canada,
\sphinxurl{http://www.inra.fr/mia/T/degivry/cpaior16sdg.pdf}.
\bibitem[Katsirelos2015a]{userdoc:katsirelos2015a}
\sphinxAtStartPar
D Allouche, S de Givry, G Katsirelos, T Schiex and M Zytnicki.
Anytime Hybrid Best\sphinxhyphen{}First Search with Tree Decomposition for Weighted CSP.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}15}, pages 12\sphinxhyphen{}28, Cork, Ireland, 2015.
\bibitem[Schiex2014a]{userdoc:schiex2014a}
\sphinxAtStartPar
David Allouche, Jessica Davies, Simon de Givry, George Katsirelos, Thomas Schiex, Seydou Traoré, Isabelle André, Sophie Barbe, Steve Prestwich and Barry O’Sullivan.
Computational Protein Design as an Optimization Problem.
\sphinxstyleemphasis{Artificial Intelligence}, 212:59\sphinxhyphen{}79, 2014.
\bibitem[Givry2013a]{userdoc:givry2013a}
\sphinxAtStartPar
S de Givry, S Prestwich and B O’Sullivan.
Dead\sphinxhyphen{}End Elimination for Weighted CSP.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}13}, pages 263\sphinxhyphen{}272, Uppsala, Sweden, 2013.
\bibitem[Ficolofo2012]{userdoc:ficolofo2012}
\sphinxAtStartPar
D Allouche, C Bessiere, P Boizumault, S de Givry, P Gutierrez, S Loudni, JP Métivier and T Schiex.
Decomposing Global Cost Functions.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}12}, Toronto, Canada, 2012.
\sphinxurl{http://www.inra.fr/mia/T/degivry/Ficolofo2012poster.pdf} (poster).
\bibitem[Favier2011a]{userdoc:favier2011a}
\sphinxAtStartPar
A Favier, S de Givry, A Legarra and T Schiex.
Pairwise decomposition for combinatorial optimization in graphical models.
In \sphinxstyleemphasis{Proc. of IJCAI\sphinxhyphen{}11}, Barcelona, Spain, 2011.
Video demonstration at \sphinxurl{http://www.inra.fr/mia/T/degivry/Favier11.mov}.
\bibitem[Cooper2010a]{userdoc:cooper2010a}
\sphinxAtStartPar
M. Cooper, S. de Givry, M. Sanchez, T. Schiex, M. Zytnicki and T. Werner.
Soft arc consistency revisited.
\sphinxstyleemphasis{Artificial Intelligence}, 174(7\sphinxhyphen{}8):449\sphinxhyphen{}478, 2010.
\bibitem[Favier2009a]{userdoc:favier2009a}
\sphinxAtStartPar
A. Favier, S. de Givry and P. Jégou.
Exploiting Problem Structure for Solution Counting.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}09}, pages 335\sphinxhyphen{}343, Lisbon, Portugal, 2009.
\bibitem[Sanchez2009a]{userdoc:sanchez2009a}
\sphinxAtStartPar
M Sanchez, D Allouche, S de Givry and T Schiex.
Russian Doll Search with Tree Decomposition.
In \sphinxstyleemphasis{Proc. of IJCAI’09}, Pasadena (CA), USA, 2009.
\sphinxhref{http://www.inra.fr/mia/T/degivry/rdsbtd\_ijcai09\_sdg.ppt}{http://www.inra.fr/mia/T/degivry/rdsbtd\_ijcai09\_sdg.ppt}.
\bibitem[Cooper2008]{userdoc:cooper2008}
\sphinxAtStartPar
M. Cooper, S. de Givry, M. Sanchez, T. Schiex and M. Zytnicki.
Virtual Arc Consistency for Weighted CSP.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}08}, Chicago, IL, 2008.
\bibitem[Schiex2006a]{userdoc:schiex2006a}
\sphinxAtStartPar
S. de Givry, T. Schiex and G. Verfaillie.
Exploiting Tree Decomposition and Soft Local Consistency in Weighted CSP.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}06}, Boston, MA, 2006.
\sphinxurl{http://www.inra.fr/mia/T/degivry/VerfaillieAAAI06pres.pdf} (slides).
\bibitem[Heras2005]{userdoc:heras2005}
\sphinxAtStartPar
S. de Givry, M. Zytnicki, F. Heras and J. Larrosa.
Existential arc consistency: Getting closer to full arc consistency in weighted CSPs.
In \sphinxstyleemphasis{Proc. of IJCAI\sphinxhyphen{}05}, pages 84\sphinxhyphen{}89, Edinburgh, Scotland, 2005.
\bibitem[Larrosa2000]{userdoc:larrosa2000}
\sphinxAtStartPar
J. Larrosa.
Boosting search with variable elimination.
In \sphinxstyleemphasis{Principles and Practice of Constraint Programming \sphinxhyphen{} CP 2000},
volume 1894 of LNCS, pages 291\sphinxhyphen{}305, Singapore, September 2000.
\bibitem[koller2009]{userdoc:koller2009}
\sphinxAtStartPar
D Koller and N Friedman.
Probabilistic graphical models: principles and techniques.
The MIT Press, 2009.
\bibitem[Ginsberg1995]{userdoc:ginsberg1995}
\sphinxAtStartPar
W. D. Harvey and M. L. Ginsberg.
Limited Discrepency Search.
In \sphinxstyleemphasis{Proc. of IJCAI\sphinxhyphen{}95}, Montréal, Canada, 1995.
\bibitem[Lecoutre2009]{userdoc:lecoutre2009}
\sphinxAtStartPar
C. Lecoutre, L. Saïs, S. Tabary and V. Vidal.
Reasoning from last conflict(s) in constraint programming.
\sphinxstyleemphasis{Artificial Intelligence}, 173:1592,1614, 2009.
\bibitem[boussemart2004]{userdoc:boussemart2004}
\sphinxAtStartPar
Frédéric Boussemart, Fred Hemery, Christophe Lecoutre and Lakhdar Sais.
Boosting systematic search by weighting constraints.
In \sphinxstyleemphasis{ECAI}, volume 16, page 146, 2004.
\bibitem[idwalk:cp04]{userdoc:idwalk-cp04}
\sphinxAtStartPar
Bertrand Neveu, Gilles Trombettoni and Fred Glover.
ID Walk: A Candidate List Strategy with a Simple Diversification Device.
In \sphinxstyleemphasis{Proc. of CP}, pages 423\sphinxhyphen{}437, Toronto, Canada, 2004.
\bibitem[Verfaillie1996]{userdoc:verfaillie1996}
\sphinxAtStartPar
G. Verfaillie, M. Lemaître and T. Schiex.
Russian Doll Search.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}96}, pages 181\sphinxhyphen{}187, Portland, OR, 1996.
\bibitem[LL2009]{userdoc:ll2009}
\sphinxAtStartPar
J. H. M. Lee and K. L. Leung.
Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction.
In \sphinxstyleemphasis{Proceedings of IJCAI’09}, pages 559\sphinxhyphen{}565, 2009.
\bibitem[LL2010]{userdoc:ll2010}
\sphinxAtStartPar
J. H. M. Lee and K. L. Leung.
A Stronger Consistency for Soft Global Constraints in Weighted Constraint Satisfaction.
In \sphinxstyleemphasis{Proceedings of AAAI’10}, pages 121\sphinxhyphen{}127, 2010.
\bibitem[LL2012asa]{userdoc:ll2012asa}
\sphinxAtStartPar
J. H. M. Lee and K. L. Leung.
Consistency Techniques for Global Cost Functions in Weighted Constraint Satisfaction.
\sphinxstyleemphasis{Journal of Artificial Intelligence Research}, 43:257\sphinxhyphen{}292, 2012.
\bibitem[Larrosa2002]{userdoc:larrosa2002}
\sphinxAtStartPar
J. Larrosa.
On Arc and Node Consistency in weighted \{CSP\}.
In \sphinxstyleemphasis{Proc. AAAI’02}, pages 48\sphinxhyphen{}53, Edmondton, (CA), 2002.
\bibitem[Larrosa2003]{userdoc:larrosa2003}
\sphinxAtStartPar
J. Larrosa and T. Schiex.
In the quest of the best form of local consistency for Weighted CSP.
In \sphinxstyleemphasis{Proc. of the 18th IJCAI}, pages 239\sphinxhyphen{}244, Acapulco, Mexico, August 2003.
\bibitem[Schiex2000b]{userdoc:schiex2000b}
\sphinxAtStartPar
T. Schiex.
Arc consistency for soft constraints.
In \sphinxstyleemphasis{Principles and Practice of Constraint Programming \sphinxhyphen{} CP 2000},
volume 1894 of \sphinxstyleemphasis{LNCS}, pages 411\sphinxhyphen{}424, Singapore, September 2000.
\bibitem[CooperFCSP]{userdoc:cooperfcsp}
\sphinxAtStartPar
M.C. Cooper.
Reduction operations in fuzzy or valued constraint satisfaction.
\sphinxstyleemphasis{Fuzzy Sets and Systems}, 134(3):311\sphinxhyphen{}342, 2003.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}