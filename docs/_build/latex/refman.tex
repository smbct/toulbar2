%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{toulbar2 Reference Manual}
\date{Nov 30, 2022}
\release{1.0.0}
\author{INRAE}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{refman::doc}}


\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{ref/ref_intro:introduction}}\label{\detokenize{ref/ref_intro:ref-intro}}\label{\detokenize{ref/ref_intro::doc}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
\sphinxstylestrong{Cost Function Network Solver}
&
\sphinxAtStartPar
toulbar2
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Copyright}
&
\sphinxAtStartPar
toulbar2 team
\\
\sphinxhline
\sphinxAtStartPar
\sphinxstylestrong{Source}
&
\sphinxAtStartPar
\sphinxurl{https://github.com/toulbar2/toulbar2}
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
toulbar2 can be used as a stand\sphinxhyphen{}alone solver reading various problem file formats (wcsp, uai, wcnf, qpbo) or as a C++ library.

\sphinxAtStartPar
This document describes the WCSP native file format and the toulbar2 C++ library API.
\begin{description}
\sphinxlineitem{Note}
\sphinxAtStartPar
Use cmake flags LIBTB2=ON and TOULBAR2\_ONLY=OFF to get the toulbar2 C++
library libtb2.so and toulbar2test executable example.

\end{description}

\sphinxAtStartPar
\sphinxstylestrong{See also} : \sphinxcode{\sphinxupquote{src/toulbar2test.cpp}}.

\sphinxstepscope


\chapter{Exact optimization for cost function networks and additive graphical models}
\label{\detokenize{_files/README:exact-optimization-for-cost-function-networks-and-additive-graphical-models}}\label{\detokenize{_files/README::doc}}

\section{What is toulbar2?}
\label{\detokenize{_files/README:what-is-toulbar2}}\label{\detokenize{_files/README:readme-1}}
\sphinxAtStartPar
toulbar2 is an open\sphinxhyphen{}source black\sphinxhyphen{}box C++ optimizer for cost function
networks and discrete additive graphical models. It can read a variety
of formats. The optimized criteria and feasibility should be provided
factorized in local cost functions on discrete variables. Constraints
are represented as functions that produce costs that exceed a
user\sphinxhyphen{}provided primal bound. toulbar2 looks for a non\sphinxhyphen{}forbidden assignment
of all variables that optimizes the sum of all functions (a decision
NP\sphinxhyphen{}complete problem).

\sphinxAtStartPar
toulbar2 won several competitions on deterministic and probabilistic
graphical models:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Max\sphinxhyphen{}CSP 2008 Competition \sphinxhref{http://www.cril.univ-artois.fr/CPAI08/}{CPAI08} (winner on 2\sphinxhyphen{}ARY\sphinxhyphen{}EXT and N\sphinxhyphen{}ARY\sphinxhyphen{}EXT)

\item {} 
\sphinxAtStartPar
Probabilistic Inference Evaluation \sphinxhref{http://graphmod.ics.uci.edu/uai08/Evaluation/Report}{UAI 2008} (winner on several MPE tasks, inra entries)

\item {} 
\sphinxAtStartPar
2010 UAI APPROXIMATE INFERENCE CHALLENGE \sphinxhref{http://www.cs.huji.ac.il/project/UAI10/summary.php}{UAI 2010} (winner on 1200\sphinxhyphen{}second MPE task)

\item {} 
\sphinxAtStartPar
The Probabilistic Inference Challenge \sphinxhref{http://www.cs.huji.ac.il/project/PASCAL/board.php}{PIC 2011} (second place by ficolofo on 1\sphinxhyphen{}hour MAP task)

\item {} 
\sphinxAtStartPar
UAI 2014 Inference Competition \sphinxhref{http://www.hlt.utdallas.edu/~vgogate/uai14-competition/leaders.html}{UAI 2014} (winner on all MAP task categories, see Proteus, Robin, and IncTb entries)

\end{itemize}

\sphinxAtStartPar
toulbar2 is now also able to collaborate with ML code that can learn
an additive graphical model (with constraints) from data (see the
associated
\sphinxhref{https://miat.inrae.fr/schiex/Export/Pushing\_Data\_in\_your\_CP\_model.pdf}{paper},
\sphinxhref{https://miat.inrae.fr/schiex/Export/Pushing\_Data\_in\_your\_CP\_model-Slides.pdf}{slides}
and \sphinxhref{https://www.youtube.com/watch?v=IpUr6KIEjMs}{video} where it is
shown how it can learn user preferences or how to play the Sudoku
without knowing the rules). The current CFN learning code is available
on \sphinxhref{https://github.com/toulbar2/CFN-learn}{GitHub}.


\section{Installation from binaries}
\label{\detokenize{_files/README:installation-from-binaries}}\label{\detokenize{_files/README:readme-2}}
\sphinxAtStartPar
You can install toulbar2 directly using the package manager in Debian
and Debian derived Linux distributions (Ubuntu, Mint,…):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
sudo apt\PYGZhy{}get update
sudo apt\PYGZhy{}get install toulbar2 toulbar2\PYGZhy{}doc
\end{sphinxVerbatim}

\sphinxAtStartPar
For the most recent binary or the Python API, compile from source.


\section{Python interface}
\label{\detokenize{_files/README:python-interface}}\label{\detokenize{_files/README:readme-3}}
\sphinxAtStartPar
An alpha\sphinxhyphen{}release Python interface can be tested through pip on Linux and MacOS:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pip install \PYGZhy{}\PYGZhy{}upgrade pip
python3 \PYGZhy{}m pip install pytoulbar2
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line is only useful for Linux distributions that ship “old” versions of pip.

\sphinxAtStartPar
Commands for compiling the Python API on Linux/MacOS with cmake (Python module in lib/*/pytb2.cpython*.so):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir build
cd build
cmake \PYGZhy{}DPYTB2=ON ..
make
\end{sphinxVerbatim}

\sphinxAtStartPar
Move the cpython library and the experimental \sphinxhref{https://github.com/toulbar2/toulbar2/raw/master/pytoulbar2/pytoulbar2.py}{pytoulbar2.py} python class wrapper in the folder of the python script that does “import pytoulbar2”.


\section{Download}
\label{\detokenize{_files/README:download}}\label{\detokenize{_files/README:readme-4}}
\sphinxAtStartPar
Download the latest release from GitHub
(https://github.com/toulbar2/toulbar2) or similarly use tag versions,
e.g.:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
git clone \PYGZhy{}\PYGZhy{}branch 1.2.0 https://github.com/toulbar2/toulbar2.git
\end{sphinxVerbatim}


\section{Installation from sources}
\label{\detokenize{_files/README:installation-from-sources}}\label{\detokenize{_files/README:readme-5}}
\sphinxAtStartPar
Compilation requires git, cmake and a C++\sphinxhyphen{}11 capable compiler (in C++11 mode).

\sphinxAtStartPar
Required library:
\begin{itemize}
\item {} 
\sphinxAtStartPar
libgmp\sphinxhyphen{}dev

\end{itemize}

\sphinxAtStartPar
Recommended libraries (default use):
\begin{itemize}
\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}graph\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}iostreams\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}serialization\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
zlib1g\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
liblzma\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libbz2\sphinxhyphen{}dev

\end{itemize}

\sphinxAtStartPar
Optional libraries:
\begin{itemize}
\item {} 
\sphinxAtStartPar
libjemalloc\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libopenmpi\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libboost\sphinxhyphen{}mpi\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libicuuc

\item {} 
\sphinxAtStartPar
libicui18n

\item {} 
\sphinxAtStartPar
libicudata

\item {} 
\sphinxAtStartPar
libxml2\sphinxhyphen{}dev

\item {} 
\sphinxAtStartPar
libxcsp3parser

\end{itemize}

\sphinxAtStartPar
On MacOS, run ./misc/script/MacOS\sphinxhyphen{}requirements\sphinxhyphen{}install.sh to install the recommended libraries.

\sphinxAtStartPar
Commands for compiling toulbar2 on Linux/MacOS with cmake (binary in build/bin/*/toulbar2):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir build
cd build
cmake ..
make
\end{sphinxVerbatim}

\sphinxAtStartPar
Commands for statically compiling toulbar2 on Linux in directory toulbar2/src without cmake:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash
cd src
echo \PYGZsq{}\PYGZsh{}define Toulbar\PYGZus{}VERSION \PYGZdq{}1.2.0\PYGZdq{}\PYGZsq{} \PYGZgt{} ToulbarVersion.hpp
g++ \PYGZhy{}o toulbar2 \PYGZhy{}std=c++17 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}static \PYGZhy{}static\PYGZhy{}libgcc \PYGZhy{}static\PYGZhy{}libstdc++ \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DWCSPFORMATONLY \PYGZbs{}
 \PYGZhy{}I. \PYGZhy{}I./pils/src tb2*.cpp applis/*.cpp core/*.cpp globals/*.cpp incop/*.cpp pils/src/exe/*.cpp search/*.cpp utils/*.cpp vns/*.cpp ToulbarVersion.cpp \PYGZbs{}
 \PYGZhy{}lboost\PYGZus{}graph \PYGZhy{}lboost\PYGZus{}iostreams \PYGZhy{}lboost\PYGZus{}serialization \PYGZhy{}lgmp \PYGZhy{}lz \PYGZhy{}lbz2 \PYGZhy{}llzma
\end{sphinxVerbatim}

\sphinxAtStartPar
Use OPENMPI flag and MPI compiler for a parallel version of toulbar2:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash
cd src
echo \PYGZsq{}\PYGZsh{}define Toulbar\PYGZus{}VERSION \PYGZdq{}1.2.0\PYGZdq{}\PYGZsq{} \PYGZgt{} ToulbarVersion.hpp
mpicxx \PYGZhy{}o toulbar2 \PYGZhy{}std=c++17 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DWCSPFORMATONLY \PYGZhy{}DOPENMPI \PYGZbs{}
 \PYGZhy{}I. \PYGZhy{}I./pils/src tb2*.cpp applis/*.cpp core/*.cpp globals/*.cpp incop/*.cpp pils/src/exe/*.cpp search/*.cpp utils/*.cpp vns/*.cpp ToulbarVersion.cpp \PYGZbs{}
 \PYGZhy{}lboost\PYGZus{}graph \PYGZhy{}lboost\PYGZus{}iostreams \PYGZhy{}lboost\PYGZus{}serialization \PYGZhy{}lboost\PYGZus{}mpi \PYGZhy{}lgmp \PYGZhy{}lz \PYGZhy{}lbz2 \PYGZhy{}llzma
\end{sphinxVerbatim}

\sphinxAtStartPar
Replace LONGLONG\_COST by INT\_COST to reduce memory usage by two and reduced cost range (costs must be smaller than 10\textasciicircum{}8).

\sphinxAtStartPar
Replace WCSPFORMATONLY by XMLFLAG3 and add libxcsp3parser.a from xcsp.org in your current directory for reading XCSP3 files:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bash
cd src
echo \PYGZsq{}\PYGZsh{}define Toulbar\PYGZus{}VERSION \PYGZdq{}1.2.0\PYGZdq{}\PYGZsq{} \PYGZgt{} ToulbarVersion.hpp
mpicxx \PYGZhy{}o toulbar2 \PYGZhy{}std=c++17 \PYGZhy{}O3 \PYGZhy{}DNDEBUG \PYGZhy{}DBOOST \PYGZhy{}DLONGDOUBLE\PYGZus{}PROB \PYGZhy{}DLONGLONG\PYGZus{}COST \PYGZhy{}DXMLFLAG3 \PYGZhy{}DOPENMPI \PYGZbs{}
 \PYGZhy{}I/usr/include/libxml2 \PYGZhy{}I. \PYGZhy{}I./pils/src \PYGZhy{}I./xmlcsp3 tb2*.cpp applis/*.cpp core/*.cpp globals/*.cpp incop/*.cpp pils/src/exe/*.cpp search/*.cpp utils/*.cpp vns/*.cpp ToulbarVersion.cpp \PYGZbs{}
 \PYGZhy{}lboost\PYGZus{}graph \PYGZhy{}lboost\PYGZus{}iostreams \PYGZhy{}lboost\PYGZus{}serialization \PYGZhy{}lboost\PYGZus{}mpi \PYGZhy{}lxml2 \PYGZhy{}licuuc \PYGZhy{}licui18n \PYGZhy{}licudata libxcsp3parser.a \PYGZhy{}lgmp \PYGZhy{}lz \PYGZhy{}lbz2 \PYGZhy{}llzma \PYGZhy{}lm \PYGZhy{}lpthread \PYGZhy{}ldl
\end{sphinxVerbatim}

\sphinxAtStartPar
Copyright (C) 2006\sphinxhyphen{}2022, toulbar2 team.
toulbar2 is currently maintained by Simon de Givry, INRAE \sphinxhyphen{} MIAT, Toulouse, France (simon.de\sphinxhyphen{}givry@inrae.fr)


\section{Convex Combination of multiple Criteria branch}
\label{\detokenize{_files/README:convex-combination-of-multiple-criteria-branch}}\label{\detokenize{_files/README:readme-6}}

\subsection{changes regarding the master toulbar2 c++/python API}
\label{\detokenize{_files/README:changes-regarding-the-master-toulbar2-c-python-api}}\begin{itemize}
\item {} 
\sphinxAtStartPar
one new class: multiwcsp to create a wcsp as the linear combination of wcsp’s given as input

\item {} 
\sphinxAtStartPar
makeWeightedCSPSolver: possibility to give a wcsp as input, which will be used as the instance solved by the solver (works only with the base Solver class, otherwise, a new weightedCSP is created withinin the solver object)

\item {} 
\sphinxAtStartPar
adding a function for the python API for weightedCSP to read an instance independently from the solver

\item {} 
\sphinxAtStartPar
adding the multiwcsp object and methods in the python API

\item {} 
\sphinxAtStartPar
modification of the python API in makeWeightedCSPSolver to take a weightedCSP as input

\item {} 
\sphinxAtStartPar
modification of the python API to create a weightedCSP object without solvers

\item {} 
\sphinxAtStartPar
modification of the python API to read an instance file directly from a weightedCSP object

\end{itemize}

\sphinxstepscope


\chapter{Modules}
\label{\detokenize{ref/ref_modules:modules}}\label{\detokenize{ref/ref_modules:ref-modules}}\label{\detokenize{ref/ref_modules::doc}}

\section{Variable and cost function modeling}
\label{\detokenize{ref/ref_modules:variable-and-cost-function-modeling}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__modeling}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{modeling}}}
\pysigstopsignatures
\sphinxAtStartPar

\sphinxAtStartPar
Modeling a Weighted CSP consists in creating variables and cost functions.

\sphinxAtStartPar
Domains of variables can be of two different types:
\begin{itemize}
\item {} 
\sphinxAtStartPar
enumerated domain allowing direct access to each value (array) and iteration on current domain in times proportional to the current number of values (double\sphinxhyphen{}linked list)

\item {} 
\sphinxAtStartPar
interval domain represented by a lower value and an upper value only (useful for large domains)

\end{itemize}

Warning : Current implementation of toulbar2 has limited modeling and solving facilities for interval domains. There is no cost functions accepting both interval and enumerated variables for the moment, which means all the variables should have the same type.

\sphinxAtStartPar

\sphinxAtStartPar
Cost functions can be defined in extension (table or maps) or having a specific semantic.

\sphinxAtStartPar
Cost functions in extension depend on their arity:
\begin{itemize}
\item {} 
\sphinxAtStartPar
unary cost function (directly associated to an enumerated variable)

\item {} 
\sphinxAtStartPar
binary and ternary cost functions (table of costs)

\item {} 
\sphinxAtStartPar
n\sphinxhyphen{}ary cost functions (n \textgreater{}= 4) defined by a list of tuples with associated costs and a default cost for missing tuples (allows for a compact representation)

\end{itemize}

Cost functions having a specific semantic (see Weighted Constraint Satisfaction Problem file format (wcsp)) are:\begin{itemize}
\item {} 
\sphinxAtStartPar
simple arithmetic and scheduling (temporal disjunction) cost functions on interval variables

\item {} 
\sphinxAtStartPar
global cost functions (\sphinxstyleemphasis{eg} soft alldifferent, soft global cardinality constraint, soft same, soft regular, etc) with three different propagator keywords:\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{flow} propagator based on flow algorithms with “s” prefix in the keyword (\sphinxstyleemphasis{salldiff}, \sphinxstyleemphasis{sgcc}, \sphinxstyleemphasis{ssame}, \sphinxstyleemphasis{sregular})

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{DAG} propagator based on dynamic programming algorithms with “s” prefix and “dp” postfix (\sphinxstyleemphasis{samongdp}, salldiffdp, sgccdp, sregulardp, sgrammardp, smstdp, smaxdp)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{network} propagator based on cost function network decomposition with “w” prefix (\sphinxstyleemphasis{wsum}, \sphinxstyleemphasis{wvarsum}, \sphinxstyleemphasis{walldiff}, \sphinxstyleemphasis{wgcc}, \sphinxstyleemphasis{wsame}, \sphinxstyleemphasis{wsamegcc}, \sphinxstyleemphasis{wregular}, \sphinxstyleemphasis{wamong}, \sphinxstyleemphasis{wvaramong}, \sphinxstyleemphasis{woverlap})

\end{itemize}


\end{itemize}

Note : The default semantics (using \sphinxstyleemphasis{var} keyword) of monolithic (flow and DAG\sphinxhyphen{}based propagators) global cost functions is to count the number of variables to change in order to restore consistency and to multiply it by the basecost. Other particular semantics may be used in conjunction with the flow\sphinxhyphen{}based propagator

\sphinxAtStartPar
Note : The semantics of the network\sphinxhyphen{}based propagator approach is either a hard constraint (“hard” keyword) or a soft constraint by multiplying the number of changes by the basecost (“lin” or “var” keyword) or by multiplying the square value of the number of changes by the basecost (“quad” keyword)

\sphinxAtStartPar
Note : A decomposable version exists for each monolithic global cost function, except grammar and MST. The decomposable ones may propagate less than their monolithic counterpart and they introduce extra variables but they can be much faster in practice

\sphinxAtStartPar
Warning : Each global cost function may have less than three propagators implemented

\sphinxAtStartPar
Warning : Current implementation of toulbar2 has limited solving facilities for monolithic global cost functions (no BTD\sphinxhyphen{}like methods nor variable elimination)

\sphinxAtStartPar
Warning : Current implementation of toulbar2 disallows global cost functions with less than or equal to three variables in their scope (use cost functions in extension instead)

\sphinxAtStartPar
Warning : Before modeling the problem using make and post, call ::tb2init method to initialize toulbar2 global variables

\sphinxAtStartPar
Warning : After modeling the problem using make and post, call {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSP_1a31a9384d3dabf5388fe610710f2f19e0}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSP::sortConstraints}}}} method to initialize correctly the model before solving it 

\end{fulllineitems}



\section{Solving cost function networks}
\label{\detokenize{ref/ref_modules:solving-cost-function-networks}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__solving}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{solving}}}
\pysigstopsignatures
\sphinxAtStartPar
After creating a Weighted CSP, it can be solved using a local search method like INCOP or PILS (see {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSPSolver_1af481cf37ff94238ab1e15bff34026209}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSPSolver::narycsp}}}} or {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSPSolver_1a94898d20bff27abdb156ed2e248a8004}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSPSolver::pils}}}}) and/or an exact search method (see {\hyperref[\detokenize{ref/ref_cpp:classWeightedCSPSolver_1ab1f9d2c018bf050a6b010680a2008171}]{\sphinxcrossref{\DUrole{std,std-ref}{WeightedCSPSolver::solve}}}}).

\sphinxAtStartPar

\sphinxAtStartPar
Various options of the solving methods are controlled by ::Toulbar2 static class members (see files ./src/core/tb2types.hpp and ./src/tb2main.cpp).

\sphinxAtStartPar
A brief code example reading a wcsp problem given as a single command\sphinxhyphen{}line parameter and solving it:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZsh{}include \PYGZdq{}toulbar2lib.hpp\PYGZdq{}
\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}
int main(int argc, char **argv) \PYGZob{}

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

    // Create a solver object
    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data\PYGZhy{}type
    WeightedCSPSolver *solver = WeightedCSPSolver::makeWeightedCSPSolver(MAX\PYGZus{}COST);

    // Read a problem file in wcsp format
    solver\PYGZhy{}\PYGZgt{}read\PYGZus{}wcsp(argv[1]);

    ToulBar2::verbose = \PYGZhy{}1;  // change to 0 or higher values to see more trace information

    // Uncomment if solved using INCOP local search followed by a partial Limited Discrepancy Search with a maximum discrepancy of one
    //  ToulBar2::incop\PYGZus{}cmd = \PYGZdq{}0 1 3 idwa 100000 cv v 0 200 1 0 0\PYGZdq{};
    //  ToulBar2::lds = \PYGZhy{}1;  // remove it or change to a positive value then the search continues by a complete B\PYGZam{}B search method
    // Uncomment the following lines if solved using Decomposition Guided Variable Neighborhood Search with min\PYGZhy{}fill cluster decomposition and absorption
    // ToulBar2::lds = 4;
    // ToulBar2::restart = 10000;
    // ToulBar2::searchMethod = DGVNS;
    // ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    // ToulBar2::boostingBTD = 0.7;
    // ToulBar2::varOrder = reinterpret\PYGZus{}cast\PYGZlt{}char*\PYGZgt{}(\PYGZhy{}3);

    if (solver\PYGZhy{}\PYGZgt{}solve()) \PYGZob{}
        // show (sub\PYGZhy{})optimal solution
        vector\PYGZlt{}Value\PYGZgt{} sol;
        Cost ub = solver\PYGZhy{}\PYGZgt{}getSolution(sol);
        cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Best solution found cost: \PYGZdq{} \PYGZlt{}\PYGZlt{} ub \PYGZlt{}\PYGZlt{} endl;
        cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Best solution found:\PYGZdq{};
        for (unsigned int i=0; i\PYGZlt{}sol.size(); i++) cout \PYGZlt{}\PYGZlt{} ((i\PYGZgt{}0)?\PYGZdq{},\PYGZdq{}:\PYGZdq{}\PYGZdq{}) \PYGZlt{}\PYGZlt{} \PYGZdq{} x\PYGZdq{} \PYGZlt{}\PYGZlt{} i \PYGZlt{}\PYGZlt{} \PYGZdq{} = \PYGZdq{} \PYGZlt{}\PYGZlt{} sol[i];
        cout \PYGZlt{}\PYGZlt{} endl;
    \PYGZcb{} else \PYGZob{}
        cout \PYGZlt{}\PYGZlt{} \PYGZdq{}No solution found!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;
    \PYGZcb{}
    delete solver;
\PYGZcb{}
\end{sphinxVerbatim}


\sphinxAtStartPar
See : another code example in ./src/toulbar2test.cpp

\sphinxAtStartPar
Warning : variable domains must start at zero, otherwise recompile libtb2.so without flag WCSPFORMATONLY 

\end{fulllineitems}


\sphinxAtStartPar
\sphinxstylestrong{toulbar2test.cpp}
\begin{quote}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{toulbar2test.cpp}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

/**
 * Test toulbar2 API
 */

\PYGZsh{}include \PYGZdq{}toulbar2lib.hpp\PYGZdq{}

\PYGZsh{}include \PYGZdq{}core/tb2wcsp.hpp\PYGZdq{}
\PYGZsh{}include \PYGZdq{}vns/tb2vnsutils.hpp\PYGZdq{}
\PYGZsh{}include \PYGZdq{}vns/tb2dgvns.hpp\PYGZdq{}
\PYGZsh{}ifdef OPENMPI
\PYGZsh{}include \PYGZdq{}vns/tb2cpdgvns.hpp\PYGZdq{}
\PYGZsh{}include \PYGZdq{}vns/tb2rpdgvns.hpp\PYGZdq{}
\PYGZsh{}endif
\PYGZsh{}include \PYGZlt{}string.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}stdlib.h\PYGZgt{}
\PYGZsh{}include \PYGZlt{}unistd.h\PYGZgt{}

// INCOP default command line option
const string Incop\PYGZus{}cmd = \PYGZdq{}0 1 3 idwa 100000 cv v 0 200 1 0 0\PYGZdq{};

int main(int argc, char* argv[])
\PYGZob{}
\PYGZsh{}ifdef OPENMPI
    mpi::environment env; // equivalent to MPI\PYGZus{}Init via the constructor and MPI\PYGZus{}finalize via the destructor
    mpi::communicator world;
\PYGZsh{}endif

    tb2init(); // must be call before setting specific ToulBar2 options and creating a model

\PYGZsh{}ifdef OPENMPI
    if (world.rank() == WeightedCSPSolver::MASTER)
        ToulBar2::verbose = \PYGZhy{}1; // change to 0 or higher values to see more trace information
    else
        ToulBar2::verbose = \PYGZhy{}1;
\PYGZsh{}else
    ToulBar2::verbose = \PYGZhy{}1; // change to 0 or higher values to see more trace information
\PYGZsh{}endif

    // uncomment if Virtual Arc Consistency (equivalent to Augmented DAG algorithm) enable
    //	ToulBar2::vac = 1; // option \PYGZhy{}A
    //	ToulBar2::vacValueHeuristic = true; // option \PYGZhy{}V
    // uncomment if partial Limited Discrepancy Search enable
    //	ToulBar2::lds = 1;  // option \PYGZhy{}l=1
    // uncomment if INCOP local search enable
    //	ToulBar2::incop\PYGZus{}cmd = Incop\PYGZus{}cmd; // option \PYGZhy{}i
    // uncomment the following lines if variable neighborhood search enable
    //ToulBar2::lds = 4;
    //ToulBar2::restart = 10000;
    //\PYGZsh{}ifdef OPENMPI
    //     if (world.size() \PYGZgt{} 1) \PYGZob{}
    //    	 ToulBar2::searchMethod = RPDGVNS;
    //    	 ToulBar2::vnsParallel = true;
    //    	 ToulBar2::vnsNeighborVarHeur = MASTERCLUSTERRAND;
    //    	 ToulBar2::vnsParallelSync = false;
    //     \PYGZcb{} else \PYGZob{}
    //    	 ToulBar2::searchMethod = DGVNS;
    //    	 ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    //     \PYGZcb{}
    //\PYGZsh{}else
    //	ToulBar2::searchMethod = DGVNS;
    //	ToulBar2::vnsNeighborVarHeur = CLUSTERRAND;
    //**or**
    //  ToulBar2::searchMethod = VNS;
    //  ToulBar2::vnsNeighborVarHeur = RANDOMVAR;
    //\PYGZsh{}endif

    // create a problem with three 0/1 variables
    initCosts(); // last check for compatibility issues between ToulBar2 options and Cost data\PYGZhy{}type
    WeightedCSPSolver* solver = WeightedCSPSolver::makeWeightedCSPSolver(MAX\PYGZus{}COST);
    int x = solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}x\PYGZdq{}, 0, 1); // note that for efficiency issue, I assume domain values start at zero (otherwise remove flag \PYGZhy{}DWCSPFORMATONLY in Makefile)
    int y = solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}y\PYGZdq{}, 0, 1);
    int z = solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}makeEnumeratedVariable(\PYGZdq{}z\PYGZdq{}, 0, 1);

    // add random unary cost functions on each variable
    mysrand(getpid());
    \PYGZob{}
        vector\PYGZlt{}Cost\PYGZgt{} costs(2, 0);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postUnary(x, costs);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postUnary(y, costs);
        costs[0] = randomCost(0, 100);
        costs[1] = randomCost(0, 100);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postUnary(z, costs);
    \PYGZcb{}

    // add binary cost functions (Ising) on each pair of variables
    \PYGZob{}
        vector\PYGZlt{}Cost\PYGZgt{} costs;
        for (unsigned int i = 0; i \PYGZlt{} 2; i++) \PYGZob{}
            for (unsigned int j = 0; j \PYGZlt{} 2; j++) \PYGZob{}
                costs.push\PYGZus{}back((solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(x, i) == solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(y, j)) ? 0 : 30); // penalizes by a cost=30 if variables are assigned to different values
            \PYGZcb{}
        \PYGZcb{}
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(x, y, costs);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(x, z, costs);
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postBinaryConstraint(y, z, costs);
    \PYGZcb{}

    // add a ternary hard constraint (x+y=z)
    \PYGZob{}
        vector\PYGZlt{}Cost\PYGZgt{} costs;
        for (unsigned int i = 0; i \PYGZlt{} 2; i++) \PYGZob{}
            for (unsigned int j = 0; j \PYGZlt{} 2; j++) \PYGZob{}
                for (unsigned int k = 0; k \PYGZlt{} 2; k++) \PYGZob{}
                    costs.push\PYGZus{}back((solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(x, i) + solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(y, j) == solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}toValue(z, k)) ? 0 : MAX\PYGZus{}COST);
                \PYGZcb{}
            \PYGZcb{}
        \PYGZcb{}
        solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}postTernaryConstraint(x, y, z, costs);
    \PYGZcb{}

    solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}sortConstraints(); // must be done before the search

    //	int verbose = ToulBar2::verbose;
    //	ToulBar2::verbose = 5;  // high verbosity to see the cost functions
    //	solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}print(cout);
    //	ToulBar2::verbose = verbose;

    //tb2checkOptions();
    if (solver\PYGZhy{}\PYGZgt{}solve()) \PYGZob{}
\PYGZsh{}ifdef OPENMPI
        if (world.rank() == WeightedCSPSolver::MASTER) \PYGZob{}
\PYGZsh{}endif
            // show optimal solution
            vector\PYGZlt{}Value\PYGZgt{} sol;
            Cost optimum = solver\PYGZhy{}\PYGZgt{}getSolution(sol);
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Optimum=\PYGZdq{} \PYGZlt{}\PYGZlt{} optimum \PYGZlt{}\PYGZlt{} endl;
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Solution: x=\PYGZdq{} \PYGZlt{}\PYGZlt{} sol[x] \PYGZlt{}\PYGZlt{} \PYGZdq{} ,y=\PYGZdq{} \PYGZlt{}\PYGZlt{} sol[y] \PYGZlt{}\PYGZlt{} \PYGZdq{} ,z=\PYGZdq{} \PYGZlt{}\PYGZlt{} sol[z] \PYGZlt{}\PYGZlt{} endl;
\PYGZsh{}ifdef OPENMPI
        \PYGZcb{}
\PYGZsh{}endif
    \PYGZcb{} else \PYGZob{}
\PYGZsh{}ifdef OPENMPI
        if (world.rank() == WeightedCSPSolver::MASTER) \PYGZob{}
\PYGZsh{}endif
            cout \PYGZlt{}\PYGZlt{} \PYGZdq{}No solution found!\PYGZdq{} \PYGZlt{}\PYGZlt{} endl;
\PYGZsh{}ifdef OPENMPI
        \PYGZcb{}
\PYGZsh{}endif
    \PYGZcb{}
    // cout \PYGZlt{}\PYGZlt{} \PYGZdq{}Problem lower bound: \PYGZdq{} \PYGZlt{}\PYGZlt{} solver\PYGZhy{}\PYGZgt{}getWCSP()\PYGZhy{}\PYGZgt{}getLb() \PYGZlt{}\PYGZlt{} endl; // initial problem lower bound possibly enhanced by value removals at the root during search

    delete solver;
    return 0;
\PYGZcb{}

/* Local Variables: */
/* c\PYGZhy{}basic\PYGZhy{}offset: 4 */
/* tab\PYGZhy{}width: 4 */
/* indent\PYGZhy{}tabs\PYGZhy{}mode: nil */
/* c\PYGZhy{}default\PYGZhy{}style: \PYGZdq{}k\PYGZam{}r\PYGZdq{} */
/* End: */
\end{sphinxVerbatim}
\end{quote}


\section{Output messages, verbosity options and debugging}
\label{\detokenize{ref/ref_modules:output-messages-verbosity-options-and-debugging}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__verbosity}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{verbosity}}}
\pysigstopsignatures
\sphinxAtStartPar
Depending on verbosity level given as option “\sphinxhyphen{}v=level”, \sphinxcode{\sphinxupquote{toulbar2}} will output:\begin{itemize}
\item {} 
\sphinxAtStartPar
(level=0, no verbosity) default output mode: shows version number, number of variables and cost functions read in the problem file, number of unassigned variables and cost functions after preprocessing, problem upper and lower bounds after preprocessing. Outputs current best solution cost found, ends by giving the optimum or “No solution”. Last output line should always be: “end.”

\item {} 
\sphinxAtStartPar
(level=\sphinxhyphen{}1, no verbosity) restricted output mode: do not print current best solution cost found

\end{itemize}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
(level=1) shows also search choices (“{[}”\sphinxstyleemphasis{search\_depth} \sphinxstyleemphasis{problem\_lower\_bound} \sphinxstyleemphasis{problem\_upper\_bound} \sphinxstyleemphasis{sum\_of\_current\_domain\_sizes”{]} Try”} \sphinxstyleemphasis{variable\_index} \sphinxstyleemphasis{operator} \sphinxstyleemphasis{value}) with \sphinxstyleemphasis{operator} being assignment (“==”), value removal (“!=”), domain splitting (“\textless{}=” or “\textgreater{}=”, also showing EAC value in parenthesis)

\item {} 
\sphinxAtStartPar
(level=2) shows also current domains (\sphinxstyleemphasis{variable\_index} \sphinxstyleemphasis{list\_of\_current\_domain\_values} “/” \sphinxstyleemphasis{number\_of\_cost\_functions} (see approximate degree in {\hyperref[\detokenize{ref/ref_modules:group__varelim}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable elimination}}}}) “/” \sphinxstyleemphasis{weighted\_degree} \sphinxstyleemphasis{list\_of\_unary\_costs} “s:” \sphinxstyleemphasis{support\_value}) before each search choice and reports problem lower bound increases, NC bucket sort data (see {\hyperref[\detokenize{ref/ref_modules:group__ncbucket}]{\sphinxcrossref{\DUrole{std,std-ref}{NC bucket sort}}}}), and basic operations on domains of variables

\item {} 
\sphinxAtStartPar
(level=3) reports also basic arc EPT operations on cost functions (see {\hyperref[\detokenize{ref/ref_modules:group__softac}]{\sphinxcrossref{\DUrole{std,std-ref}{Soft arc consistency and problem reformulation}}}})

\item {} 
\sphinxAtStartPar
(level=4) shows also current list of cost functions for each variable and reports more details on arc EPT operations (showing all changes in cost functions)

\item {} 
\sphinxAtStartPar
(level=5) reports more details on cost functions defined in extension giving their content (cost table by first increasing values in the current domain of the last variable in the scope)

\end{enumerate}


\sphinxAtStartPar
For debugging purposes, another option “\sphinxhyphen{}Z=level” allows one to monitor the search:\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
(level 1) shows current search depth (number of search choices from the root of the search tree) and reports statistics on nogoods for BTD\sphinxhyphen{}like methods

\item {} 
\sphinxAtStartPar
(level 2) idem

\item {} 
\sphinxAtStartPar
(level 3) also saves current problem into a file before each search choice

\end{enumerate}


\sphinxAtStartPar
Note : \sphinxcode{\sphinxupquote{toulbar2}}, compiled in debug mode, can be more verbose and it checks a lot of assertions (pre/post conditions in the code)

\sphinxAtStartPar
Note : \sphinxcode{\sphinxupquote{toulbar2}} will output an help message giving available options if run without any parameters 

\end{fulllineitems}



\section{Preprocessing techniques}
\label{\detokenize{ref/ref_modules:preprocessing-techniques}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__preprocessing}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{preprocessing}}}
\pysigstopsignatures
\sphinxAtStartPar
Depending on toulbar2 options, the sequence of preprocessing techniques applied before the search is:\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{i\sphinxhyphen{}bounded} variable elimination with user\sphinxhyphen{}defined \sphinxstyleemphasis{i} bound

\item {} 
\sphinxAtStartPar
pairwise decomposition of cost functions (binary cost functions are implicitly decomposed by soft AC and empty cost function removals)

\item {} 
\sphinxAtStartPar
MinSumDiffusion propagation (see VAC)

\item {} 
\sphinxAtStartPar
projects\&substracts n\sphinxhyphen{}ary cost functions in extension on all the binary cost functions inside their scope (3 \textless{} n \textless{} max, see toulbar2 options)

\item {} 
\sphinxAtStartPar
functional variable elimination (see {\hyperref[\detokenize{ref/ref_modules:group__varelim}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable elimination}}}})

\item {} 
\sphinxAtStartPar
projects\&substracts ternary cost functions in extension on their three binary cost functions inside their scope (before that, extends the existing binary cost functions to the ternary cost function and applies pairwise decomposition)

\item {} 
\sphinxAtStartPar
creates new ternary cost functions for all triangles (\sphinxstyleemphasis{ie} occurences of three binary cost functions \sphinxstyleemphasis{xy}, \sphinxstyleemphasis{yz}, \sphinxstyleemphasis{zx})

\item {} 
\sphinxAtStartPar
removes empty cost functions while repeating \#1 and \#2 until no new cost functions can be removed

\end{enumerate}


\sphinxAtStartPar
Note : the propagation loop is called after each preprocessing technique (see WCSP::propagate) 

\end{fulllineitems}



\section{Variable and value search ordering heuristics}
\label{\detokenize{ref/ref_modules:variable-and-value-search-ordering-heuristics}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__heuristics}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{heuristics}}}
\pysigstopsignatures
\sphinxAtStartPar
See : \sphinxstyleemphasis{ Boosting Systematic Search by Weighting Constraints }. Frederic Boussemart, Fred Hemery, Christophe Lecoutre, Lakhdar Sais. Proc. of ECAI 2004, pages 146\sphinxhyphen{}150. Valencia, Spain, 2004.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Last Conflict Based Reasoning }. Christophe Lecoutre, Lakhdar Sais, Sebastien Tabary, Vincent Vidal. Proc. of ECAI 2006, pages 133\sphinxhyphen{}137. Trentino, Italy, 2006.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Solution\sphinxhyphen{}based phase saving for CP: A value\sphinxhyphen{}selection heuristic to simulate local search behavior in complete solvers }. Emir Demirovic, Geoffrey Chu, and Peter Stuckey. Proc. of CP\sphinxhyphen{}18, pages 99\textendash{}108. Lille, France, 2018. 

\end{fulllineitems}



\section{Soft arc consistency and problem reformulation}
\label{\detokenize{ref/ref_modules:soft-arc-consistency-and-problem-reformulation}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__softac}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{softac}}}
\pysigstopsignatures
\sphinxAtStartPar
Soft arc consistency is an incremental lower bound technique for optimization problems. Its goal is to move costs from high\sphinxhyphen{}order (typically arity two or three) cost functions towards the problem lower bound and unary cost functions. This is achieved by applying iteratively local equivalence\sphinxhyphen{}preserving problem transformations (EPTs) until some terminating conditions are met.

\sphinxAtStartPar
Note : \sphinxstyleemphasis{eg} an EPT can move costs between a binary cost function and a unary cost function such that the sum of the two functions remains the same for any complete assignment.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Arc consistency for Soft Constraints. } T. Schiex. Proc. of CP’2000. Singapour, 2000.

\sphinxAtStartPar
Note : Soft Arc Consistency in toulbar2 is limited to binary and ternary and some global cost functions (\sphinxstyleemphasis{eg} alldifferent, gcc, regular, same). Other n\sphinxhyphen{}ary cost functions are delayed for propagation until their number of unassigned variables is three or less.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction. } Jimmy Ho\sphinxhyphen{}Man Lee, Ka Lun Leung. Proc. of IJCAI 2009, pages 559\sphinxhyphen{}565. Pasadena, USA, 2009. 

\end{fulllineitems}



\section{Virtual Arc Consistency enforcing}
\label{\detokenize{ref/ref_modules:virtual-arc-consistency-enforcing}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__VAC}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{VAC}}}
\pysigstopsignatures
\sphinxAtStartPar
The three phases of VAC are enforced in three different “Pass”. Bool(P) is never built. Instead specific functions (getVACCost) booleanize the WCSP on the fly. The domain variables of Bool(P) are the original variable domains (saved and restored using trailing at each iteration). All the counter data\sphinxhyphen{}structures (k) are timestamped to avoid clearing them at each iteration.

\sphinxAtStartPar
Note : Simultaneously AC (and potentially DAC, EAC) are maintained by proper queuing.

\sphinxAtStartPar
See : \sphinxstyleemphasis{ Soft Arc Consistency Revisited. } Cooper et al. Artificial Intelligence. 2010. 

\end{fulllineitems}



\section{NC bucket sort}
\label{\detokenize{ref/ref_modules:nc-bucket-sort}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__ncbucket}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{ncbucket}}}
\pysigstopsignatures
\sphinxAtStartPar
maintains a sorted list of variables having non\sphinxhyphen{}zero unary costs in order to make NC propagation incremental.\begin{itemize}
\item {} 
\sphinxAtStartPar
variables are sorted into buckets

\item {} 
\sphinxAtStartPar
each bucket is associated to a single interval of non\sphinxhyphen{}zero costs (using a power\sphinxhyphen{}of\sphinxhyphen{}two scaling, first bucket interval is {[}1,2{[}, second interval is {[}2,4{[}, etc.)

\item {} 
\sphinxAtStartPar
each variable is inserted into the bucket corresponding to its largest unary cost in its domain

\item {} 
\sphinxAtStartPar
variables having all unary costs equal to zero do not belong to any bucket

\end{itemize}


\sphinxAtStartPar
NC propagation will revise only variables in the buckets associated to costs sufficiently large wrt current objective bounds. 

\end{fulllineitems}



\section{Variable elimination}
\label{\detokenize{ref/ref_modules:variable-elimination}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__varelim}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{varelim}}}
\pysigstopsignatures
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{i\sphinxhyphen{}bounded} variable elimination eliminates all variables with a degree less than or equal to \sphinxstyleemphasis{i}. It can be done with arbitrary i\sphinxhyphen{}bound in preprocessing only and iff all their cost functions are in extension.

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{i\sphinxhyphen{}bounded} variable elimination with i\sphinxhyphen{}bound less than or equal to two can be done during the search.

\item {} 
\sphinxAtStartPar
functional variable elimination eliminates all variables which have a bijective or functional binary hard constraint (\sphinxstyleemphasis{ie} ensuring a one\sphinxhyphen{}to\sphinxhyphen{}one or several\sphinxhyphen{}to\sphinxhyphen{}one value mapping) and iff all their cost functions are in extension. It can be done without limit on their degree, in preprocessing only.

\end{itemize}


\sphinxAtStartPar
Note : Variable elimination order used in preprocessing is either lexicographic or given by an external file *.order (see toulbar2 options)

\sphinxAtStartPar
Note : 2\sphinxhyphen{}bounded variable elimination during search is optimal in the sense that any elimination order should result in the same final graph

\sphinxAtStartPar
Warning : It is not possible to display/save solutions when bounded variable elimination is applied in preprocessing

\sphinxAtStartPar
Warning : toulbar2 maintains a list of current cost functions for each variable. It uses the size of these lists as an approximation of variable degrees. During the search, if variable \sphinxstyleemphasis{x} has three cost functions \sphinxstyleemphasis{xy}, \sphinxstyleemphasis{xz}, \sphinxstyleemphasis{xyz}, its true degree is two but its approximate degree is three. In toulbar2 options, it is the approximate degree which is given by the user for variable elimination during the search (thus, a value at most three). But it is the true degree which is given by the user for variable elimination in preprocessing. 

\end{fulllineitems}



\section{Propagation loop}
\label{\detokenize{ref/ref_modules:propagation-loop}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__propagation}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{propagation}}}
\pysigstopsignatures
\sphinxAtStartPar

\sphinxAtStartPar
Propagates soft local consistencies and bounded variable elimination until all the propagation queues are empty or a contradiction occurs.

\sphinxAtStartPar
While (queues are not empty or current objective bounds have changed):
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
queue for bounded variable elimination of degree at most two (except at preprocessing)

\item {} 
\sphinxAtStartPar
BAC queue

\item {} 
\sphinxAtStartPar
EAC queue

\item {} 
\sphinxAtStartPar
DAC queue

\item {} 
\sphinxAtStartPar
AC queue

\item {} 
\sphinxAtStartPar
monolithic (flow\sphinxhyphen{}based and DAG\sphinxhyphen{}based) global cost function propagation (partly incremental)

\item {} 
\sphinxAtStartPar
NC queue

\item {} 
\sphinxAtStartPar
returns to \#1 until all the previous queues are empty

\item {} 
\sphinxAtStartPar
DEE queue

\item {} 
\sphinxAtStartPar
returns to \#1 until all the previous queues are empty

\item {} 
\sphinxAtStartPar
VAC propagation (not incremental)

\item {} 
\sphinxAtStartPar
returns to \#1 until all the previous queues are empty (and problem is VAC if enable)

\item {} 
\sphinxAtStartPar
exploits goods in pending separators for BTD\sphinxhyphen{}like methods

\end{enumerate}


\sphinxAtStartPar
Queues are first\sphinxhyphen{}in / first\sphinxhyphen{}out lists of variables (avoiding multiple insertions). In case of a contradiction, queues are explicitly emptied by WCSP::whenContradiction 

\end{fulllineitems}



\section{Backtrack management}
\label{\detokenize{ref/ref_modules:backtrack-management}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{ref/ref_modules:group__backtrack}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{backtrack}}}
\pysigstopsignatures
\sphinxAtStartPar
Used by backtrack search methods. Allows to copy / restore the current state using Store::store and Store::restore methods. All storable data modifications are trailed into specific stacks.

\sphinxAtStartPar
Trailing stacks are associated to each storable type:\begin{itemize}
\item {} 
\sphinxAtStartPar
Store::storeValue for storable domain values ::StoreValue (value supports, etc)

\item {} 
\sphinxAtStartPar
Store::storeInt for storable integer values ::StoreInt (number of non assigned variables in nary cost functions, etc)

\item {} 
\sphinxAtStartPar
Store::storeCost for storable costs ::StoreCost (inside cost functions, etc)

\item {} 
\sphinxAtStartPar
Store::storeDomain for enumerated domains (to manage holes inside domains)

\item {} 
\sphinxAtStartPar
Store::storeIndexList for integer lists (to manage edge connections in global cost functions)

\item {} 
\sphinxAtStartPar
Store::storeConstraint for backtrackable lists of constraints

\item {} 
\sphinxAtStartPar
Store::storeVariable for backtrackable lists of variables

\item {} 
\sphinxAtStartPar
Store::storeSeparator for backtrackable lists of separators (see tree decomposition methods)

\item {} 
\sphinxAtStartPar
Store::storeBigInteger for very large integers ::StoreBigInteger used in solution counting methods

\end{itemize}


\sphinxAtStartPar
Memory for each stack is dynamically allocated by part of \(2^x\) with \sphinxstyleemphasis{x} initialized to ::STORE\_SIZE and increased when needed.

\sphinxAtStartPar
Note : storable data are not trailed at depth 0.

\sphinxAtStartPar
Warning : Current storable data management is not multi\sphinxhyphen{}threading safe! (Store is a static virtual class relying on StoreBasic\textless{}T\textgreater{} static members) 

\end{fulllineitems}


\sphinxstepscope


\chapter{Libraries}
\label{\detokenize{ref/ref_lib:libraries}}\label{\detokenize{ref/ref_lib:ref-lib}}\label{\detokenize{ref/ref_lib::doc}}\begin{itemize}
\item {} 
\sphinxAtStartPar
C++ Library : see “C++ Library of toulbar2” document.

\item {} 
\sphinxAtStartPar
Python Library : see “Python Library of toulbar2” document.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}