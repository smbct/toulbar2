%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{Weighted Constraint Satisfaction Problem file format (wcsp)}
\date{Nov 30, 2022}
\release{1.0.0}
\author{INRAE}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{formats/wcspformat::doc}}



\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{formats/wcspformat:group__wcspformat}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{wcspformat}}}
\pysigstopsignatures
\sphinxAtStartPar
It is a text format composed of a list of numerical and string terms separated by spaces. Instead of using names for making reference to variables, variable indexes are employed. The same for domain values. All indexes start at zero.

\sphinxAtStartPar
Cost functions can be defined in intention (see below) or in extension, by their list of tuples. A default cost value is defined per function in order to reduce the size of the list. Only tuples with a different cost value should be given (not mandatory). All the cost values must be positive. The arity of a cost function in extension may be equal to zero. In this case, there is no tuples and the default cost value is added to the cost of any solution. This can be used to represent a global lower bound constant of the problem.

\sphinxAtStartPar
The wcsp file format is composed of three parts: a problem header, the list of variable domain sizes, and the list of cost functions.

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Header definition for a given problem: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Problem} \PYG{n}{name}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{variables} \PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Maximum} \PYG{n}{domain} \PYG{n}{size}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{cost} \PYG{n}{functions}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Initial} \PYG{k}{global} \PYG{n}{upper} \PYG{n}{bound} \PYG{n}{of} \PYG{n}{the} \PYG{n}{problem} \PYG{p}{(}\PYG{n}{UB}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
 The goal is to find an assignment of all the variables with minimum total cost, strictly lower than UB. Tuples with a cost greater than or equal to UB are forbidden (hard constraint).

\item {} 
\sphinxAtStartPar
Definition of domain sizes 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Domain} \PYG{n}{size} \PYG{n}{of} \PYG{n}{variable} \PYG{k}{with} \PYG{n}{index} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Domain} \PYG{n}{size} \PYG{n}{of} \PYG{n}{variable} \PYG{k}{with} \PYG{n}{index} \PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Note : domain values range from zero to \sphinxstyleemphasis{size\sphinxhyphen{}1} 

\sphinxAtStartPar
Note : a negative domain size is interpreted as a variable with an interval domain in \([0,-size-1]\)

\sphinxAtStartPar
Warning : variables with interval domains are restricted to arithmetic and disjunctive cost functions in intention (see below)

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
General definition of cost functions\begin{itemize}
\item {} 
\sphinxAtStartPar
Definition of a cost function in extension 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Arity} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Default} \PYG{n}{cost} \PYG{n}{value}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{tuples} \PYG{k}{with} \PYG{n}{a} \PYG{n}{cost} \PYG{n}{different} \PYG{n}{than} \PYG{n}{the} \PYG{n}{default} \PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
 followed by for every tuple with a cost different than the default cost: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{value} \PYG{n}{assigned} \PYG{n}{to} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{value} \PYG{n}{assigned} \PYG{n}{to} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Cost} \PYG{n}{of} \PYG{n}{the} \PYG{n+nb}{tuple}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\end{itemize}


\sphinxAtStartPar
Note : Shared cost function: A cost function in extension can be shared by several cost functions with the same arity (and same domain sizes) but different scopes. In order to do that, the cost function to be shared must start by a negative scope size. Each shared cost function implicitly receives an occurrence number starting from 1 and incremented at each new shared definition. New cost functions in extension can reuse some previously defined shared cost functions in extension by using a negative number of tuples representing the occurrence number of the desired shared cost function. Note that default costs should be the same in the shared and new cost functions. Here is an example of 4 variables with domain size 4 and one AllDifferent hard constraint decomposed into 6 binary constraints.

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shared CF used inside a small example in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AllDifferentDecomposedIntoBinaryConstraints} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{6} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
Definition of a cost function in intension by replacing the default cost value by \sphinxhyphen{}1 and by giving its keyword name and its K parameters 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Arity} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{o}{\PYGZlt{}}\PYG{n}{keyword}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter1}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameterK}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Possible keywords of cost functions defined in intension followed by their specific parameters:\begin{itemize}
\item {} 
\sphinxAtStartPar
\textgreater{}= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x \geq y + cst\) with associated cost function \(max( (y + cst - x \leq delta)?(y + cst - x):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textgreater{} \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x > y + cst\) with associated cost function \(max( (y + cst + 1 - x \leq delta)?(y + cst + 1 - x):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textless{}= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x \leq y + cst\) with associated cost function \(max( (x - cst - y \leq delta)?(x - cst - y):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textless{} \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x < y + cst\) with associated cost function \(max( (x - cst + 1 - y \leq delta)?(x - cst + 1 - y):UB , 0 )\)

\item {} 
\sphinxAtStartPar
= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x = y + cst\) with associated cost function \((|y + cst - x| \leq delta)?|y + cst - x|:UB\)

\item {} 
\sphinxAtStartPar
disj \sphinxstyleemphasis{cstx} \sphinxstyleemphasis{csty} \sphinxstyleemphasis{penalty} to express soft binary disjunctive constraint \(x \geq y + csty \vee y \geq x + cstx\) with associated cost function \((x \geq y + csty \vee y \geq x + cstx)?0:penalty\)

\item {} 
\sphinxAtStartPar
sdisj \sphinxstyleemphasis{cstx} \sphinxstyleemphasis{csty} \sphinxstyleemphasis{xinfty} \sphinxstyleemphasis{yinfty} \sphinxstyleemphasis{costx} \sphinxstyleemphasis{costy} to express a special disjunctive constraint with three implicit hard constraints \(x \leq xinfty\) and \(y \leq yinfty\) and \(x < xinfty \wedge y < yinfty \Rightarrow (x \geq y + csty \vee y \geq x + cstx)\) and an additional cost function \(((x = xinfty)?costx:0) + ((y= yinfty)?costy:0)\)

\item {} 
\sphinxAtStartPar
Global cost functions using a dedicated propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
clique \sphinxstyleemphasis{1} (\sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})*)* to express a hard clique cut to restrict the number of variables taking their value into a given set of values (per variable) to at most \sphinxstyleemphasis{1} occurrence for all the variables (warning! it assumes also a clique of binary constraints already exists to forbid any two variables using both the restricted values)

\item {} 
\sphinxAtStartPar
knapsack \sphinxstyleemphasis{capacity} (\sphinxstyleemphasis{weight})* to express a reverse knapsack constraint (i.e., a linear constraint on 0/1 variables with \textgreater{}= operator) with capacity and weights are positive or negative integer coefficients (use negative numbers to express a linear constraint with \textless{}= operator)

\item {} 
\sphinxAtStartPar
knapsackp \sphinxstyleemphasis{capacity} (\sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{weight})*)* to express a reverse knapsack constraint with for each variable the list of values to select the item in the knapsack with their corresponding weight

\end{itemize}


\item {} 
\sphinxAtStartPar
Global cost functions using a flow\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
salldiff var|dec|decbi \sphinxstyleemphasis{cost} to express a soft alldifferent constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{dec} and \sphinxstyleemphasis{decbi} keywords) cost semantic with a given \sphinxstyleemphasis{cost} per violation (\sphinxstyleemphasis{decbi} decomposes into a binary cost function complete network)

\item {} 
\sphinxAtStartPar
sgcc var|dec|wdec \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} (\sphinxstyleemphasis{shortage\_weight} \sphinxstyleemphasis{excess\_weight})?)* to express a soft global cardinality constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{dec} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound (if \sphinxstyleemphasis{wdec} then violation cost depends on each value shortage or excess weights)

\item {} 
\sphinxAtStartPar
ssame \sphinxstyleemphasis{cost} \sphinxstyleemphasis{list\_size1} \sphinxstyleemphasis{list\_size2} (\sphinxstyleemphasis{variable\_index})* (\sphinxstyleemphasis{variable\_index})* to express a permutation constraint on two lists of variables of equal size (implicit variable\sphinxhyphen{}based cost semantic)

\item {} 
\sphinxAtStartPar
sregular var|edit \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state})* to express a soft regular constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or edit distance\sphinxhyphen{}based (\sphinxstyleemphasis{edit} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation followed by the definition of a deterministic finite automaton with number of states, list of initial and final states, and list of state transitions where symbols are domain values

\end{itemize}


\end{itemize}


\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Global cost functions using a dynamic programming DAG\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
sregulardp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state})* to express a soft regular constraint with a variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation followed by the definition of a deterministic finite automaton with number of states, list of initial and final states, and list of state transitions where symbols are domain values

\item {} 
\sphinxAtStartPar
sgrammar|sgrammardp var|weight \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_symbols} \sphinxstyleemphasis{nb\_values} \sphinxstyleemphasis{start\_symbol} \sphinxstyleemphasis{nb\_rules} ((0 \sphinxstyleemphasis{terminal\_symbol} \sphinxstyleemphasis{value})|(1 \sphinxstyleemphasis{nonterminal\_in} \sphinxstyleemphasis{nonterminal\_out\_left} \sphinxstyleemphasis{nonterminal\_out\_right})|(2 \sphinxstyleemphasis{terminal\_symbol} \sphinxstyleemphasis{value} \sphinxstyleemphasis{weight})|(3 \sphinxstyleemphasis{nonterminal\_in} \sphinxstyleemphasis{nonterminal\_out\_left} \sphinxstyleemphasis{nonterminal\_out\_right} \sphinxstyleemphasis{weight}))* to express a soft/weighted grammar in Chomsky normal form

\item {} 
\sphinxAtStartPar
samong|samongdp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* to express a soft among constraint to restrict the number of variables taking their value into a given set of values

\item {} 
\sphinxAtStartPar
salldiffdp var \sphinxstyleemphasis{cost} to express a soft alldifferent constraint with variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation (decomposes into samongdp cost functions)

\item {} 
\sphinxAtStartPar
sgccdp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express a soft global cardinality constraint with variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound (decomposes into samongdp cost functions)

\item {} 
\sphinxAtStartPar
max|smaxdp \sphinxstyleemphasis{defCost} \sphinxstyleemphasis{nbtuples} (\sphinxstyleemphasis{variable} \sphinxstyleemphasis{value} \sphinxstyleemphasis{cost})* to express a weighted max cost function to find the maximum cost over a set of unary cost functions associated to a set of variables (by default, \sphinxstyleemphasis{defCost} if unspecified)

\item {} 
\sphinxAtStartPar
MST|smstdp to express a spanning tree hard constraint where each variable is assigned to its parent variable index in order to build a spanning tree (the root being assigned to itself)

\end{itemize}


\end{itemize}


\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Global cost functions using a cost function network\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
wregular \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state} and cost)* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state} and cost)* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state} \sphinxstyleemphasis{cost})* to express a weighted regular constraint with weights on initial states, final states, and transitions, followed by the definition of a deterministic finite automaton with number of states, list of initial and final states with their costs, and list of weighted state transitions where symbols are domain values

\item {} 
\sphinxAtStartPar
walldiff hard|lin|quad \sphinxstyleemphasis{cost} to express a soft alldifferent constraint as a set of wamong hard constraint (\sphinxstyleemphasis{hard} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{lin} and \sphinxstyleemphasis{quad} keywords) cost semantic with a given \sphinxstyleemphasis{cost} per violation

\item {} 
\sphinxAtStartPar
wgcc hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express a soft global cardinality constraint as either a hard constraint (\sphinxstyleemphasis{hard} keyword) or with decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{lin} and \sphinxstyleemphasis{quad} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound

\item {} 
\sphinxAtStartPar
wsame hard|lin|quad \sphinxstyleemphasis{cost} to express a permutation constraint on two lists of variables of equal size (implicitly concatenated in the scope) using implicit decomposition\sphinxhyphen{}based cost semantic

\item {} 
\sphinxAtStartPar
wsamegcc hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express the combination of a soft global cardinality constraint and a permutation constraint

\item {} 
\sphinxAtStartPar
wamong hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} to express a soft among constraint to restrict the number of variables taking their value into a given set of values

\item {} 
\sphinxAtStartPar
wvaramong hard \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* to express a hard among constraint to restrict the number of variables taking their value into a given set of values to be equal to the last variable in the scope

\item {} 
\sphinxAtStartPar
woverlap hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} \sphinxstyleemphasis{righthandside} overlaps between two sequences of variables X, Y (i.e. set the fact that Xi and Yi take the same value (not equal to zero))

\item {} 
\sphinxAtStartPar
wsum hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} \sphinxstyleemphasis{righthandside} to express a soft sum constraint with unit coefficients to test if the sum of a set of variables matches with a given comparator and right\sphinxhyphen{}hand\sphinxhyphen{}side value

\item {} 
\sphinxAtStartPar
wvarsum hard \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} to express a hard sum constraint to restrict the sum to be \sphinxstyleemphasis{comparator} to the value of the last variable in the scope

\item {} 
\sphinxAtStartPar
wdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a dual encoding such that there is a given minimum Hamming distance to a given variable assignment

\item {} 
\sphinxAtStartPar
whdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a hidden encoding such that there is a given minimum Hamming distance to a given variable assignment

\item {} 
\sphinxAtStartPar
wtdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a ternary encoding such that there is a given minimum Hamming distance to a given variable assignment

\sphinxAtStartPar
Let us note \textless{}\textgreater{} the comparator, K the right\sphinxhyphen{}hand\sphinxhyphen{}side value associated to the comparator, and Sum the result of the sum over the variables. For each comparator, the gap is defined according to the distance as follows:\begin{itemize}
\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is == : gap = abs(K \sphinxhyphen{} Sum)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{}= : gap = max(0,Sum \sphinxhyphen{} K)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{} : gap = max(0,Sum \sphinxhyphen{} K \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is != : gap = 1 if Sum != K and gap = 0 otherwise

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{} : gap = max(0,K \sphinxhyphen{} Sum + 1);

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{}= : gap = max(0,K \sphinxhyphen{} Sum);

\end{itemize}


\end{itemize}


\end{itemize}


\sphinxAtStartPar
Warning : The decomposition of wsum and wvarsum may use an exponential size (sum of domain sizes).

\sphinxAtStartPar
Warning : \sphinxstyleemphasis{list\_size1} and \sphinxstyleemphasis{list\_size2} must be equal in \sphinxstyleemphasis{ssame}.

\sphinxAtStartPar
Warning : Cost functions defined in intention cannot be shared.

\sphinxAtStartPar
Note More about network\sphinxhyphen{}based global cost functions can be found on ./misc/doc/DecomposableGlobalCostFunctions.html

\sphinxAtStartPar
Examples:\begin{itemize}
\item {} 
\sphinxAtStartPar
quadratic cost function \(x0 * x1\) in extension with variable domains \(\{0,1\}\) (equivalent to a soft clause \(\neg x0 \vee \neg x1\)):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
simple arithmetic hard constraint \(x1 < x2\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
hard temporal disjunction \(x1 \geq x2 + 2 \vee x2 \geq x1 + 1\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{disj} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{n}{UB} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
clique cut (\{x0,x1,x2,x3\}) on Boolean variables such that value 1 is used at most once:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{clique} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
knapsack constraint ( \(2 * x0 + 3 * x1 + 4 * x2 + 5 * x3 >= 10\)) on four Boolean 0/1 variables:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{knapsack} \PYG{l+m+mi}{10} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
knapsackp constraint ( \(2 * (x0=0) + 3 * (x1=1) + 4 * (x2=2) + 5 * (x3=0 \vee x3=1) >= 10\)) on four \{0,1,2\}\sphinxhyphen{}domain variables:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{knapsackp} \PYG{l+m+mi}{10} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_alldifferent(\{x0,x1,x2,x3\}):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_gcc(\{x1,x2,x3,x4\}) with each value \sphinxstyleemphasis{v} from 1 to 4 only appearing at least v\sphinxhyphen{}1 and at most v+1 times:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sgcc} \PYG{n}{var} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_same(\{x0,x1,x2,x3\},\{x4,x5,x6,x7\}):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{ssame} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_regular(\{x1,x2,x3,x4\}) with DFA (3*)+(4*):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sregular} \PYG{n}{var} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_grammar(\{x0,x1,x2,x3\}) with hard cost (1000) producing well\sphinxhyphen{}formed parenthesis expressions:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sgrammardp} \PYG{n}{var} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_among(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i \in \{1,2\}) < 1\) or \(\sum_{i=1}^4(x_i \in \{1,2\}) > 3\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{samongdp} \PYG{n}{var} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft max(\{x0,x1,x2,x3\}) with cost equal to \(\max_{i=0}^3((x_i!=i)?1000:(4-i))\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{smaxdp} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wregular(\{x0,x1,x2,x3\}) with DFA (0(10)*2*):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wregular} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{9} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wamong(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i \in \{1,2\}) < 1\) or \(\sum_{i=1}^4(x_i \in \{1,2\}) > 3\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wamong} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wvaramong(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^3(x_i \in \{1,2\}) \neq x_4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wvaramong} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
woverlap(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^2(x_i = x_{i+2}) \geq 1\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{woverlap} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wsum(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i) \neq 4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wsum} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{==} \PYG{l+m+mi}{4} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wvarsum(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^3(x_i) \neq x_4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wvarsum} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{==} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wdiverse(\{x0,x1,x2,x3\}) hard constraint on four variables with minimum Hamming distance of 2 to the value assignment (1,1,0,0):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wdiverse} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Latin Square 4 x 4 crisp CSP example in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{latin4} \PYG{l+m+mi}{16} \PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9} \PYG{l+m+mi}{10} \PYG{l+m+mi}{11} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{12} \PYG{l+m+mi}{13} \PYG{l+m+mi}{14} \PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{12} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5} \PYG{l+m+mi}{9} \PYG{l+m+mi}{13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{6} \PYG{l+m+mi}{10} \PYG{l+m+mi}{14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{3} \PYG{l+m+mi}{7} \PYG{l+m+mi}{11} \PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\sphinxAtStartPar
4\sphinxhyphen{}queens binary weighted CSP example with random unary costs in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{n}{WQUEENS} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{10} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}
 

\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}