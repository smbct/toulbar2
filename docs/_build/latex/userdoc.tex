%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{2}



\title{toulbar2 User Guide}
\date{Nov 30, 2022}
\release{1.0.0}
\author{INRAE}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{userdoc::doc}}



\chapter{What is toulbar2}
\label{\detokenize{userdoc:what-is-toulbar2}}
\sphinxAtStartPar
toulbar2 is an exact black box discrete optimization solver targeted
at solving cost function networks (CFN), thus solving the so\sphinxhyphen{}called
“weighted Constraint Satisfaction Problem” or WCSP. Cost function
networks can be simply described by a set of discrete variables each
having a specific finite domain and a set of integer cost functions,
each involving some of the variables. The WCSP is to find an
assignment of all variables such that the sum of all cost functions is
minimum and lest than a given upper bound often denoted as \(k\) or
\(\top\). Functions can be typically specified by sparse or full tables
but also more concisely as specific functions called “global cost
functions” \sphinxcite{userdoc:schiex2016a}.

\sphinxAtStartPar
Using on the fly translation, toulbar2 can also directly solve
optimization problems on other graphical models such as Maximum
probability Explanation (MPE) on Bayesian networks \sphinxcite{userdoc:koller2009}, and
Maximum A Posteriori (MAP) on Markov random field \sphinxcite{userdoc:koller2009}. It can also
read partial weighted MaxSAT problems, Quadratic Pseudo Boolean
problems (MAXCUT) as well as Linkage \sphinxstylestrong{.pre} pedigree files for
genotyping error detection and correction.

\sphinxAtStartPar
toulbar2 is exact. It will only report an optimal solution when it
has both identified the solution and proved its optimality. Because it
relies only on integer operations, addition and subtraction, it does
not suffer from rounding errors. In the general case, the WCSP,
MPE/BN, MAP/MRF, PWMaxSAT, QPBO or MAXCUT being all NP\sphinxhyphen{}hard problems
and thus toulbar2 may take exponential time to prove optimality. This
is however a worst\sphinxhyphen{}case behavior and toulbar2 has been shown to be
able to solve to optimality problems with half a million non Boolean
variables defining a search space as large as \(2^{829,440}\). It may
also fail to solve in reasonable time problems with a search space
smaller than \(2^{264}\).

\sphinxAtStartPar
toulbar2 provides and uses by default an “anytime”
algorithm \sphinxcite{userdoc:katsirelos2015a} that tries to quickly provide good solutions together
with an upper bound on the gap between the cost of each solution and
the (unknown) optimal cost. Thus, even if it is unable to prove
optimality, it will bound the quality of the solution provided.
It can also apply a variable neighborhood search algorithm exploiting a problem decomposition \sphinxcite{userdoc:ouali2017}.
This algorithm is complete (if enough CPU\sphinxhyphen{}time is given) and it can be run in parallel using OpenMPI.
A parallel version of previous algorithm also exists {[}Beldjilali2022{]}.

\sphinxAtStartPar
Beyond the service of providing optimal solutions, toulbar2 can also find a greedy sequence of diverse solutions \sphinxcite{userdoc:ruffini2019a} or
exhaustively enumerate solutions below a cost threshold and
perform guaranteed approximate weighted counting of solutions. For
stochastic graphical models, this means that toulbar2 will compute
the partition function (or the normalizing constant \(Z\)). These
problems being \#P\sphinxhyphen{}complete, toulbar2 runtimes can quickly increase
on such problems.

\sphinxAtStartPar
By exploiting the new toulbar2 python interface, with incremental solving capabilities, it is possible to learn a CFN from data and to combine it with mandatory constraints \sphinxcite{userdoc:schiex2020b}.
See examples at \sphinxurl{https://forgemia.inra.fr/thomas.schiex/cfn-learn}.


\chapter{How do I install it ?}
\label{\detokenize{userdoc:how-do-i-install-it}}
\sphinxAtStartPar
toulbar2 is an open source solver distributed under the MIT license as a set of C++ sources managed with git at \sphinxurl{http://github.com/toulbar2/toulbar2}. If you want
to use a released version, then you can download there source archives of a specific release that should be easy to compile on most Linux systems.

\sphinxAtStartPar
If you want to compile the latest sources yourself, you will need a modern C++ compiler, CMake, Gnu MP Bignum library, a recent version of boost libraries and optionally the jemalloc memory management and OpenMPI libraries (for more information, see \DUrole{xref,std,std-ref}{Installation from sources}). You can then clone toulbar2 on your machine and compile it by executing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{github}\PYG{o}{.}\PYG{n}{com}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{/}\PYG{n}{toulbar2}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{toulbar2}
\PYG{n}{mkdir} \PYG{n}{build}
\PYG{n}{cd} \PYG{n}{build}
\PYG{c+c1}{\PYGZsh{} ccmake ..}
\PYG{n}{cmake} \PYG{o}{.}\PYG{o}{.}
\PYG{n}{make}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally, toulbar2 is available in the debian\sphinxhyphen{}science section of the unstable/sid Debian version. It should therefore be directly installable using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sudo} \PYG{n}{apt}\PYG{o}{\PYGZhy{}}\PYG{n}{get} \PYG{n}{install} \PYG{n}{toulbar2}
\end{sphinxVerbatim}

\sphinxAtStartPar
If you want to try toulbar2 on crafted, random, or real problems, please look for benchmarks in the \sphinxhref{http://costfunction.org/en/benchmark}{Cost Function benchmark Section}. Other benchmarks coming from various discrete optimization languages are available at \sphinxhref{http://genoweb.toulouse.inra.fr/~degivry/evalgm}{Genotoul EvalGM} \sphinxcite{userdoc:hurley2016b}.


\chapter{How do I test it ?}
\label{\detokenize{userdoc:how-do-i-test-it}}
\sphinxAtStartPar
Some problem examples are available in the directory \sphinxstylestrong{toulbar2/validation}. After compilation with cmake, it is possible to run a series of tests using:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{make} \PYG{n}{test}
\end{sphinxVerbatim}

\sphinxAtStartPar
For debugging toulbar2 (compile with flag \sphinxcode{\sphinxupquote{CMAKE\_BUILD\_TYPE="Debug"}}), more test examples are available at \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library}{Cost Function Library}.
The following commands run toulbar2 (executable must be found on your system path) on every problems with a 1\sphinxhyphen{}hour time limit and compare their optimum with known optima (in .ub files).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{toulbar2}
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{forgemia}\PYG{o}{.}\PYG{n}{inra}\PYG{o}{.}\PYG{n}{fr}\PYG{o}{/}\PYG{n}{thomas}\PYG{o}{.}\PYG{n}{schiex}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{library}\PYG{o}{.}\PYG{n}{git}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{misc}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{runall}\PYG{o}{.}\PYG{n}{sh} \PYG{o}{.}\PYG{o}{/}\PYG{n}{cost}\PYG{o}{\PYGZhy{}}\PYG{n}{function}\PYG{o}{\PYGZhy{}}\PYG{n}{library}\PYG{o}{/}\PYG{n}{trunk}\PYG{o}{/}\PYG{n}{validation}
\end{sphinxVerbatim}

\sphinxAtStartPar
Other tests on randomly generated problems can be done where optimal solutions are verified by using an older solver \sphinxhref{https://forgemia.inra.fr/thomas.schiex/toolbar}{toolbar} (executable must be found on your system path).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{n}{toulbar2}
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{https}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{forgemia}\PYG{o}{.}\PYG{n}{inra}\PYG{o}{.}\PYG{n}{fr}\PYG{o}{/}\PYG{n}{thomas}\PYG{o}{.}\PYG{n}{schiex}\PYG{o}{/}\PYG{n}{toolbar}\PYG{o}{.}\PYG{n}{git}
\PYG{n}{cd} \PYG{n}{toolbar}\PYG{o}{/}\PYG{n}{toolbar}
\PYG{n}{make} \PYG{n}{toolbar}
\PYG{n}{cd} \PYG{o}{.}\PYG{o}{.}\PYG{o}{/}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{/}\PYG{n}{misc}\PYG{o}{/}\PYG{n}{script}\PYG{o}{/}\PYG{n}{rungenerate}\PYG{o}{.}\PYG{n}{sh}
\end{sphinxVerbatim}


\chapter{Using it as a black box}
\label{\detokenize{userdoc:using-it-as-a-black-box}}
\sphinxAtStartPar
Using toulbar2 is just a matter of having a properly formatted input
file describing the cost function network, graphical model, PWMaxSAT,
PBO or Linkage \sphinxstylestrong{.pre} file and executing:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{p}{[}\PYG{n}{option} \PYG{n}{parameters}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
and toulbar2 will start solving the optimization problem described in its file argument. By default, the extension of the file (either \sphinxstylestrong{.cfn}, \sphinxstylestrong{.cfn.gz}, \sphinxstylestrong{.cfn.bz2}, \sphinxstylestrong{.cfn.xz}, \sphinxstylestrong{.wcsp}, \sphinxstylestrong{.wcsp.gz}, \sphinxstylestrong{.wcsp.bz2}, \sphinxstylestrong{.wcsp.xz}, \sphinxstylestrong{.wcnf}, \sphinxstylestrong{.wcnf.gz}, \sphinxstylestrong{.wcnf.bz2}, \sphinxstylestrong{.wcnf.xz}, \sphinxstylestrong{.cnf}, \sphinxstylestrong{.cnf.gz}, \sphinxstylestrong{.cnf.bz2}, \sphinxstylestrong{.cnf.xz}, \sphinxstylestrong{.qpbo}, \sphinxstylestrong{.qpbo.gz}, \sphinxstylestrong{.qpbo.bz2}, \sphinxstylestrong{.qpbo.xz}, \sphinxstylestrong{.opb}, \sphinxstylestrong{.opb.gz}, \sphinxstylestrong{.opb.bz2}, \sphinxstylestrong{.opb.xz}, \sphinxstylestrong{.uai}, \sphinxstylestrong{.uai.gz}, \sphinxstylestrong{.uai.bz2}, \sphinxstylestrong{.uai.xz}, \sphinxstylestrong{.LG}, \sphinxstylestrong{.LG.gz}, \sphinxstylestrong{.LG.bz2}, \sphinxstylestrong{.LG.xz}, \sphinxstylestrong{.xml}, \sphinxstylestrong{.xml.gz}, \sphinxstylestrong{.xml.bz2}, \sphinxstylestrong{.xml.xz}, \sphinxstylestrong{.pre} or \sphinxstylestrong{.bep}) is used to determine the nature of the file (see {\hyperref[\detokenize{userdoc:input-formats}]{\sphinxcrossref{\DUrole{std,std-ref}{Input formats}}}}).
There is no specific order for the options or problem file. toulbar2 comes with decently optimized default option parameters. It is however often possible to set it up for different target than pure optimization or tune it for faster action using specific command line options.


\chapter{Quick start}
\label{\detokenize{userdoc:quick-start}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download a binary weighted constraint satisfaction problem (WCSP) file \sphinxcode{\sphinxupquote{example.wcsp.xz}}. Solve it with default options:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{68.750}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{5} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{15} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{22.222} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{18} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{18.519} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{21} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{55} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{49} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{122} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{63} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{153} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{81} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{217} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{89} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{240} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{25.417} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{89} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{240} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{460} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.006} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve a WCSP using INCOP, a local search method \sphinxcite{userdoc:idwalk-cp04} applied just after preprocessing, in order to find a good upper bound before a complete search:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{i}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{INCOP} \PYG{n}{solving} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.254} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{25.926}\PYG{o}{\PYGZpc{}}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{22.222} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{8} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{18.519} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{95} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{93} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{209} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{111} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{253} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{121} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{280} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{128} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{307} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{16.612} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{128} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{307} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{647} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.263} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve a WCSP with an initial upper bound and save its (first) optimal solution in filename “example.sol”:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{ub}\PYG{o}{=}\PYG{l+m+mi}{28} \PYG{o}{\PYGZhy{}}\PYG{n}{w}\PYG{o}{=}\PYG{n}{example}\PYG{o}{.}\PYG{n}{sol}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{]} \PYG{l+m+mf}{28.571}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{22.222} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{18.519} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{25} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{61} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{56} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{133} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{60} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{148} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{83} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{228} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{89} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{265} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{32.453} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{89} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{265} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{441} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.007} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
… and see this saved “example.sol” file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cat} \PYG{n}{example}\PYG{o}{.}\PYG{n}{sol}
\PYG{c+c1}{\PYGZsh{} each value corresponds to one variable assignment in problem file order}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a larger WCSP file \sphinxcode{\sphinxupquote{scen06.wcsp.xz}}. Solve it using a limited discrepancy search strategy \sphinxcite{userdoc:ginsberg1995} with a VAC integrality\sphinxhyphen{}based variable ordering \sphinxcite{userdoc:trosser2020a} in order to speed\sphinxhyphen{}up the search for finding good upper bounds first (by default, toulbar2 uses another diversification strategy based on hybrid best\sphinxhyphen{}first search \sphinxcite{userdoc:katsirelos2015a}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen06}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{l} \PYG{o}{\PYGZhy{}}\PYG{n}{vacint}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{44} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{1222} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000133} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.154752} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{82} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{3273} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{327} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{248338}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7771} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{101} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{101} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{c} \PYG{l+m+mi}{8388608} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5848} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{282} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5384} \PYG{p}{(}\PYG{l+m+mi}{3} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{397} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5039} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{466} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4740} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{640} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{738} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4675} \PYG{p}{(}\PYG{l+m+mi}{37} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{966} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4633} \PYG{p}{(}\PYG{l+m+mi}{44} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1113} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4509} \PYG{p}{(}\PYG{l+m+mi}{45} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1165} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4502} \PYG{p}{(}\PYG{l+m+mi}{51} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1226} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4344} \PYG{p}{(}\PYG{l+m+mi}{54} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1291} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4258} \PYG{p}{(}\PYG{l+m+mi}{135} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1864} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4118} \PYG{p}{(}\PYG{l+m+mi}{136} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1907} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4107} \PYG{p}{(}\PYG{l+m+mi}{138} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1965} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4101} \PYG{p}{(}\PYG{l+m+mi}{147} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2040} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4099} \PYG{p}{(}\PYG{l+m+mi}{150} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2057} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4037} \PYG{p}{(}\PYG{l+m+mi}{152} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2080} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3853} \PYG{p}{(}\PYG{l+m+mi}{157} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2171} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3800} \PYG{p}{(}\PYG{l+m+mi}{209} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2475} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3781} \PYG{p}{(}\PYG{l+m+mi}{222} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2539} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3769} \PYG{p}{(}\PYG{l+m+mi}{226} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2559} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3750} \PYG{p}{(}\PYG{l+m+mi}{227} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2568} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3748} \PYG{p}{(}\PYG{l+m+mi}{229} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2575} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{LDS} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{2586} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3615} \PYG{p}{(}\PYG{l+m+mi}{663} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5086} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3614} \PYG{p}{(}\PYG{l+m+mi}{698} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5269} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3599} \PYG{p}{(}\PYG{l+m+mi}{704} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5310} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3594} \PYG{p}{(}\PYG{l+m+mi}{708} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5335} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3591} \PYG{p}{(}\PYG{l+m+mi}{709} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5343} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3580} \PYG{p}{(}\PYG{l+m+mi}{710} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5354} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3578} \PYG{p}{(}\PYG{l+m+mi}{716} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5374} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3551} \PYG{p}{(}\PYG{l+m+mi}{988} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6456} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3539} \PYG{p}{(}\PYG{l+m+mi}{996} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6522} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3516} \PYG{p}{(}\PYG{l+m+mi}{1000} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6554} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3507} \PYG{p}{(}\PYG{l+m+mi}{1002} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6573} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3483} \PYG{p}{(}\PYG{l+m+mi}{1037} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6718} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3464} \PYG{p}{(}\PYG{l+m+mi}{1038} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6739} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3438} \PYG{p}{(}\PYG{l+m+mi}{1047} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3412} \PYG{p}{(}\PYG{l+m+mi}{1049} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6824} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{n}{Search} \PYG{k}{with} \PYG{n}{no} \PYG{n}{discrepancy} \PYG{n}{limit} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{l+m+mi}{9443} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3404} \PYG{p}{(}\PYG{l+m+mi}{4415} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14613} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{27}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3402} \PYG{p}{(}\PYG{l+m+mi}{4416} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14615} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3400} \PYG{p}{(}\PYG{l+m+mi}{4417} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14619} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{24}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3391} \PYG{p}{(}\PYG{l+m+mi}{4419} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14630} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{28}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3389} \PYG{p}{(}\PYG{l+m+mi}{4420} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14632} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{26}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{97.049} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{21663} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{49099} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{300}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{91.148} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{24321} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{54415} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{957}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{71.762} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{37965} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{81703} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1780}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{47.477} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{39060} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{83893} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1999}\PYG{p}{,} \PYG{l+m+mi}{3389}\PYG{p}{]} \PYG{l+m+mf}{41.015} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{39252} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{84277} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{3389} \PYG{o+ow}{in} \PYG{l+m+mi}{39276} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{84325} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{444857} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{36.293} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a cluster decomposition file \sphinxcode{\sphinxupquote{scen06.dec}} (each line corresponds to a cluster of variables, clusters may overlap). Solve the previous WCSP using a variable neighborhood search algorithm (UDGVNS) \sphinxcite{userdoc:ouali2017} during 10 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen06}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen06}\PYG{o}{.}\PYG{n}{dec} \PYG{o}{\PYGZhy{}}\PYG{n}{vns} \PYG{o}{\PYGZhy{}}\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{44} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{1222} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{9.2e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.152035} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{82} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{3273} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{327} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{248338}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{8388608} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7566} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{109} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{110}\PYG{p}{)}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{55} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{1} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{5} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{4.782} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{12}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{1} \PYG{k}{with} \PYG{l+m+mi}{1} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{7566} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{109} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7555} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{109} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7545} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{111} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7397} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{114} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7289} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7287} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{7277} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5274} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5169} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5159} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5158} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{118} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5105} \PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{120} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4767} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{140} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4667} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{140} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4655} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{164} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4588} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{171} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4543} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{172} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4541} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{172} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4424} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4423} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4411} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4401} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{174} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4367} \PYG{p}{(}\PYG{l+m+mi}{8} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{175} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4175} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4174} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4173} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4171} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4152} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{177} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4142} \PYG{p}{(}\PYG{l+m+mi}{12} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{187} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{4001} \PYG{p}{(}\PYG{l+m+mi}{43} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{562} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3900} \PYG{p}{(}\PYG{l+m+mi}{43} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{562} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3891} \PYG{p}{(}\PYG{l+m+mi}{78} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{779} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3890} \PYG{p}{(}\PYG{l+m+mi}{80} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{788} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3816} \PYG{p}{(}\PYG{l+m+mi}{130} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1192} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3768} \PYG{p}{(}\PYG{l+m+mi}{137} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1217} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3740} \PYG{p}{(}\PYG{l+m+mi}{205} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1660} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3738} \PYG{p}{(}\PYG{l+m+mi}{205} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1660} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3730} \PYG{p}{(}\PYG{l+m+mi}{229} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1780} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3723} \PYG{p}{(}\PYG{l+m+mi}{230} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1786} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3721} \PYG{p}{(}\PYG{l+m+mi}{230} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1786} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3711} \PYG{p}{(}\PYG{l+m+mi}{236} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1819} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3633} \PYG{p}{(}\PYG{l+m+mi}{239} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1850} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3628} \PYG{p}{(}\PYG{l+m+mi}{245} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1941} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3621} \PYG{p}{(}\PYG{l+m+mi}{245} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1943} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3609} \PYG{p}{(}\PYG{l+m+mi}{245} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1943} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3608} \PYG{p}{(}\PYG{l+m+mi}{411} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3079} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3600} \PYG{p}{(}\PYG{l+m+mi}{518} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3775} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3598} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3597} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3587} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3806} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3565} \PYG{p}{(}\PYG{l+m+mi}{534} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3846} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3554} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3856} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3534} \PYG{p}{(}\PYG{l+m+mi}{538} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3860} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3522} \PYG{p}{(}\PYG{l+m+mi}{538} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3861} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3507} \PYG{p}{(}\PYG{l+m+mi}{560} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3987} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3505} \PYG{p}{(}\PYG{l+m+mi}{584} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4130} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3500} \PYG{p}{(}\PYG{l+m+mi}{598} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4255} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3498} \PYG{p}{(}\PYG{l+m+mi}{600} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4281} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3493} \PYG{p}{(}\PYG{l+m+mi}{657} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4648} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{2} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{3493} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{6206} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3492} \PYG{p}{(}\PYG{l+m+mi}{1406} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9011} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{3} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{3492} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{10128} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{3389} \PYG{p}{(}\PYG{l+m+mi}{1652} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{10572} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{4} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{3389} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{11566} \PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{Time} \PYG{n}{limit} \PYG{n}{expired}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Aborting}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another difficult instance \sphinxcode{\sphinxupquote{scen07.wcsp.xz}}. Solve it using a variable neighborhood search algorithm (UDGVNS) with maximum cardinality search cluster decomposition and absorption \sphinxcite{userdoc:ouali2017} during 5 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{scen07}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{vns} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{E} \PYG{o}{\PYGZhy{}}\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{200} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{44} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{2665} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000303} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{10001} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.010}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.351} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{162} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{6481} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{44}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{764} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{10001}\PYG{p}{,} \PYG{l+m+mi}{436543501}\PYG{p}{]} \PYG{l+m+mf}{99.998}\PYG{o}{\PYGZpc{}}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{c} \PYG{l+m+mi}{8388608} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1455221} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{233}\PYG{p}{)}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.003} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{25} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{3} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{10} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{10.360} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{38}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{1} \PYG{k}{with} \PYG{l+m+mi}{1} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{1455221} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445522} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445520} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445320} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1445319} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1435218} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1425218} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1425217} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1415216} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1405218} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{232} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1405216} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{286} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1395016} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{286} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1394815} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{289} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{1394716} \PYG{p}{(}\PYG{l+m+mi}{9} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{289} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394818} \PYG{p}{(}\PYG{l+m+mi}{13} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{300} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394816} \PYG{p}{(}\PYG{l+m+mi}{13} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{300} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394716} \PYG{p}{(}\PYG{l+m+mi}{15} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{307} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394715} \PYG{p}{(}\PYG{l+m+mi}{26} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{361} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{394713} \PYG{p}{(}\PYG{l+m+mi}{26} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{361} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384515} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{379} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384513} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{379} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384313} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{379} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384213} \PYG{p}{(}\PYG{l+m+mi}{33} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{390} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384211} \PYG{p}{(}\PYG{l+m+mi}{33} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{390} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384208} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{426} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{384207} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{427} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{364206} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{427} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353705} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{438} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353703} \PYG{p}{(}\PYG{l+m+mi}{42} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{443} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353702} \PYG{p}{(}\PYG{l+m+mi}{44} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{450} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{353701} \PYG{p}{(}\PYG{l+m+mi}{52} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{482} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343898} \PYG{p}{(}\PYG{l+m+mi}{88} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{705} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343698} \PYG{p}{(}\PYG{l+m+mi}{91} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{717} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343593} \PYG{p}{(}\PYG{l+m+mi}{94} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{726} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{2} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{343593} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{1906} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{343592} \PYG{p}{(}\PYG{l+m+mi}{319} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2203} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{3} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{343592} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{3467} \PYG{n}{nodes}\PYG{p}{)}

\PYG{n}{Time} \PYG{n}{limit} \PYG{n}{expired}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Aborting}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download file \sphinxcode{\sphinxupquote{404.wcsp.xz}}. Solve it using Depth\sphinxhyphen{}First Brand and Bound with Tree Decomposition and HBFS (BTD\sphinxhyphen{}HBFS) \sphinxcite{userdoc:schiex2006a} based on a min\sphinxhyphen{}fill variable ordering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{404.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{710} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{6.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{64} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{35.938}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{3.030}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{67} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{1.493}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.008} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{88} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{228} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{591} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{155}\PYG{p}{]} \PYG{l+m+mf}{56.774}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{19}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{43}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{47}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.002} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{124} \PYG{p}{(}\PYG{l+m+mi}{20} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{35} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{124}\PYG{p}{]} \PYG{l+m+mf}{43.548} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{20} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{35} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{123} \PYG{p}{(}\PYG{l+m+mi}{34} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{64} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{77}\PYG{p}{,} \PYG{l+m+mi}{123}\PYG{p}{]} \PYG{l+m+mf}{37.398} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{34} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{64} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{119} \PYG{p}{(}\PYG{l+m+mi}{173} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{348} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{88}\PYG{p}{,} \PYG{l+m+mi}{119}\PYG{p}{]} \PYG{l+m+mf}{26.050} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{173} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{348} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{91}\PYG{p}{,} \PYG{l+m+mi}{119}\PYG{p}{]} \PYG{l+m+mf}{23.529} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{202} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{442} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{117} \PYG{p}{(}\PYG{l+m+mi}{261} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{609} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{97}\PYG{p}{,} \PYG{l+m+mi}{117}\PYG{p}{]} \PYG{l+m+mf}{17.094} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{261} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{609} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{p}{(}\PYG{l+m+mi}{342} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{858} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{98}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{14.035} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{342} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{858} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{12.281} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{373} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{984} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{101}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{11.404} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{437} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1123} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{102}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{10.526} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{446} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1152} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{103}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{9.649} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{484} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1232} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{104}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{8.772} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{521} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1334} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{105}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{7.895} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{521} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1353} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{106}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{7.018} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1364} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{107}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{6.140} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{525} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1379} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{109}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{4.386} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{534} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1539} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{111}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{2.632} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1559} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{113}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{0.877} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1564} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{,} \PYG{l+m+mi}{114}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{536} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1598} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{HBFS} \PYG{n+nb}{open} \PYG{n+nb}{list} \PYG{n}{restarts}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{o+ow}{and} \PYG{n}{reuse}\PYG{p}{:} \PYG{l+m+mf}{11.080} \PYG{o}{\PYGZpc{}} \PYG{n}{of} \PYG{l+m+mi}{352}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{34.355} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{o+ow}{in} \PYG{l+m+mi}{536} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1598} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{21} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.031} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve the same problem using Russian Doll Search exploiting BTD \sphinxcite{userdoc:sanchez2009a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{404.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{100} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{710} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{6.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{64} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{35.938}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{3.030}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{67} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{1.493}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.008} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{88} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{228} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{591} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{13}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{155}\PYG{p}{]} \PYG{l+m+mf}{56.774}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{19}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{43}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{47}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.002} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{5} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{6} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{7} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{44} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{42} \PYG{p}{(}\PYG{l+m+mi}{420} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{723} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{39} \PYG{p}{(}\PYG{l+m+mi}{431} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{743} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{9}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{35} \PYG{p}{(}\PYG{l+m+mi}{447} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{785} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{22}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{35}\PYG{p}{,}\PYG{l+m+mi}{35}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{557} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{960} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{46} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{p}{(}\PYG{l+m+mi}{557} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{960} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{,}\PYG{l+m+mi}{114}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{557} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{960} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{114} \PYG{o+ow}{in} \PYG{l+m+mi}{557} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{960} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{50} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.026} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve another WCSP using the original Russian Doll Search method \sphinxcite{userdoc:verfaillie1996} with static variable ordering (following problem file) and soft arc consistency:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{505.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{svo} \PYG{o}{\PYGZhy{}}\PYG{n}{k}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{240} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{2242} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000911} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.013967} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{233} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{666} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{1966} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+m+mi}{34347}\PYG{p}{]} \PYG{l+m+mf}{99.994}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{59}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{233}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{239}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.017} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{0} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{1} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{2} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{3} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{p}{(}\PYG{l+m+mi}{26963} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48851} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21251} \PYG{p}{(}\PYG{l+m+mi}{26991} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{21251}\PYG{p}{,}\PYG{l+m+mi}{21251}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{26992} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}} \PYG{n}{Solving} \PYG{n}{cluster} \PYG{n}{subtree} \PYG{l+m+mi}{238} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{p}{(}\PYG{l+m+mi}{26992} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}  \PYG{n}{done}  \PYG{n}{cost} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{21253}\PYG{p}{,}\PYG{l+m+mi}{21253}\PYG{p}{]} \PYG{p}{(}\PYG{l+m+mi}{26992} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48883} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{2}\PYG{p}{)}

\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{o+ow}{in} \PYG{l+m+mi}{26992} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{48883} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{6.180} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve the same WCSP using a parallel variable neighborhood search algorithm (UPDGVNS) with min\sphinxhyphen{}fill cluster decomposition \sphinxcite{userdoc:ouali2017} using 4 cores during 5 seconds:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{4} \PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mf}{505.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{vns} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{time}\PYG{o}{=}\PYG{l+m+mi}{5}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{240} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{2242} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.002201} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{11120} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{81.403}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{11128} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.072}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.079} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{233} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{666} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{1966} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{11128}\PYG{p}{,} \PYG{l+m+mi}{34354}\PYG{p}{]} \PYG{l+m+mf}{67.608}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.017} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{89} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{4} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{11} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{11.831} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{23}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{26266} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{59} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{60}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{26265} \PYG{o+ow}{in} \PYG{l+m+mf}{0.038} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{26264} \PYG{o+ow}{in} \PYG{l+m+mf}{0.046} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{25266} \PYG{o+ow}{in} \PYG{l+m+mf}{0.047} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{25265} \PYG{o+ow}{in} \PYG{l+m+mf}{0.060} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{25260} \PYG{o+ow}{in} \PYG{l+m+mf}{0.071} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{24262} \PYG{o+ow}{in} \PYG{l+m+mf}{0.080} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{23262} \PYG{o+ow}{in} \PYG{l+m+mf}{0.090} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{23260} \PYG{o+ow}{in} \PYG{l+m+mf}{0.098} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{23259} \PYG{o+ow}{in} \PYG{l+m+mf}{0.108} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22262} \PYG{o+ow}{in} \PYG{l+m+mf}{0.108} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22261} \PYG{o+ow}{in} \PYG{l+m+mf}{0.110} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22260} \PYG{o+ow}{in} \PYG{l+m+mf}{0.113} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22259} \PYG{o+ow}{in} \PYG{l+m+mf}{0.118} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22258} \PYG{o+ow}{in} \PYG{l+m+mf}{0.128} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22257} \PYG{o+ow}{in} \PYG{l+m+mf}{0.138} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22255} \PYG{o+ow}{in} \PYG{l+m+mf}{0.154} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22254} \PYG{o+ow}{in} \PYG{l+m+mf}{0.170} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{22252} \PYG{o+ow}{in} \PYG{l+m+mf}{0.206} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21257} \PYG{o+ow}{in} \PYG{l+m+mf}{0.227} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21256} \PYG{o+ow}{in} \PYG{l+m+mf}{0.256} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21254} \PYG{o+ow}{in} \PYG{l+m+mf}{0.380} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{21253} \PYG{o+ow}{in} \PYG{l+m+mf}{0.478} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{MPI\PYGZus{}ABORT} \PYG{n}{was} \PYG{n}{invoked} \PYG{n}{on} \PYG{n}{rank} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{communicator} \PYG{n}{MPI\PYGZus{}COMM\PYGZus{}WORLD}
\PYG{k}{with} \PYG{n}{errorcode} \PYG{l+m+mf}{0.}

\PYG{n}{NOTE}\PYG{p}{:} \PYG{n}{invoking} \PYG{n}{MPI\PYGZus{}ABORT} \PYG{n}{causes} \PYG{n}{Open} \PYG{n}{MPI} \PYG{n}{to} \PYG{n}{kill} \PYG{n+nb}{all} \PYG{n}{MPI} \PYG{n}{processes}\PYG{o}{.}
\PYG{n}{You} \PYG{n}{may} \PYG{o+ow}{or} \PYG{n}{may} \PYG{o+ow}{not} \PYG{n}{see} \PYG{n}{output} \PYG{k+kn}{from} \PYG{n+nn}{other} \PYG{n}{processes}\PYG{p}{,} \PYG{n}{depending} \PYG{n}{on}
\PYG{n}{exactly} \PYG{n}{when} \PYG{n}{Open} \PYG{n}{MPI} \PYG{n}{kills} \PYG{n}{them}\PYG{o}{.}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}

\PYG{n}{Time} \PYG{n}{limit} \PYG{n}{expired}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{Aborting}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a cluster decomposition file \sphinxcode{\sphinxupquote{example.dec}} (each line corresponds to a cluster of variables, clusters may overlap). Solve a WCSP using a variable neighborhood search algorithm (UDGVNS) with a given cluster decomposition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{dec} \PYG{o}{\PYGZhy{}}\PYG{n}{vns}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.6e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{68.750}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{7}\PYG{p}{)}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{7} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{11} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{15} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{15.143} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{17}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{1} \PYG{k}{with} \PYG{l+m+mi}{1} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{28} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{2} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{57} \PYG{n}{nodes}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{3} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{143} \PYG{n}{nodes}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{4} \PYG{k}{with} \PYG{l+m+mi}{8} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{418} \PYG{n}{nodes}\PYG{p}{)}
\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{n}{Restart} \PYG{l+m+mi}{5} \PYG{k}{with} \PYG{l+m+mi}{16} \PYG{n}{discrepancies} \PYG{o+ow}{and} \PYG{n}{UB}\PYG{o}{=}\PYG{l+m+mi}{27} \PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*} \PYG{p}{(}\PYG{l+m+mi}{846} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{521} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1156} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{3066} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.039} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Solve a WCSP using a parallel variable neighborhood search algorithm (UPDGVNS) with the same cluster decomposition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpirun} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{l+m+mi}{4} \PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{dec} \PYG{o}{\PYGZhy{}}\PYG{n}{vns}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{2.7e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.002} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{68.750}\PYG{o}{\PYGZpc{}}
\PYG{n}{Problem} \PYG{n}{decomposition} \PYG{o+ow}{in} \PYG{l+m+mi}{7} \PYG{n}{clusters} \PYG{k}{with} \PYG{n}{size} \PYG{n}{distribution}\PYG{p}{:} \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{11} \PYG{n}{median}\PYG{p}{:} \PYG{l+m+mi}{15} \PYG{n}{mean}\PYG{p}{:} \PYG{l+m+mf}{15.143} \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{17}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{0} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{7} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{36} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.064} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Total} \PYG{n}{CPU} \PYG{n}{time} \PYG{o}{=} \PYG{l+m+mf}{0.288} \PYG{n}{seconds}
\PYG{n}{Solving} \PYG{n}{real}\PYG{o}{\PYGZhy{}}\PYG{n}{time} \PYG{o}{=} \PYG{l+m+mf}{0.071} \PYG{n}{seconds} \PYG{p}{(}\PYG{o+ow}{not} \PYG{n}{including} \PYG{n}{preprocessing} \PYG{n}{time}\PYG{p}{)}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download file \sphinxcode{\sphinxupquote{example.order}}. Solve a WCSP using BTD\sphinxhyphen{}HBFS based on a given (min\sphinxhyphen{}fill) reverse variable elimination ordering:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{order} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{25} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{5} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{63} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.5e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{10.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{21} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{4.762}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{24} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{116} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{62} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{21}\PYG{p}{,} \PYG{l+m+mi}{64}\PYG{p}{]} \PYG{l+m+mf}{67.188}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{8}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{16}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{18}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{29} \PYG{p}{(}\PYG{l+m+mi}{19} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{30} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{28} \PYG{p}{(}\PYG{l+m+mi}{37} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{62} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{22}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{]} \PYG{l+m+mf}{21.429} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{37} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{62} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{28}\PYG{p}{]} \PYG{l+m+mf}{17.857} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{309} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{629} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{p}{(}\PYG{l+m+mi}{328} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{672} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{23}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{14.815} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{328} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{672} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{24}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{11.111} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{347} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{724} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{25}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{7.407} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{372} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{819} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{3.704} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{372} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{829} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{27}\PYG{p}{,} \PYG{l+m+mi}{27}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{372} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{873} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{HBFS} \PYG{n+nb}{open} \PYG{n+nb}{list} \PYG{n}{restarts}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{o+ow}{and} \PYG{n}{reuse}\PYG{p}{:} \PYG{l+m+mf}{10.769} \PYG{o}{\PYGZpc{}} \PYG{n}{of} \PYG{l+m+mi}{65}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{16.724} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{o+ow}{in} \PYG{l+m+mi}{372} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{873} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{463} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.020} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download file \sphinxcode{\sphinxupquote{example.cov}}. Solve a WCSP using BTD\sphinxhyphen{}HBFS based on a given explicit (min\sphinxhyphen{}fill path\sphinxhyphen{}) tree\sphinxhyphen{}decomposition:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{example}\PYG{o}{.}\PYG{n}{cov} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Read 25 variables, with 5 values at most, and 63 cost functions, with maximum arity 2.
Warning! Cannot apply variable elimination during search with a given tree decomposition file.
Warning! Cannot apply functional variable elimination with a given tree decomposition file.
Cost function decomposition time : 1.6e\PYGZhy{}05 seconds.
Reverse DAC dual bound: 20 (+15.000\PYGZpc{})
Reverse DAC dual bound: 22 (+9.091\PYGZpc{})
Preprocessing time: 0.001 seconds.
25 unassigned variables, 120 values in all current domains (med. size:5, max size:5) and 63 non\PYGZhy{}unary cost functions (med. arity:2, med. degree:5)
Initial lower and upper bounds: [22, 64] 65.625\PYGZpc{}
Tree decomposition width  : 16
Tree decomposition height : 24
Number of clusters         : 9
Tree decomposition time: 0.000 seconds.
New solution: 29 (23 backtracks, 29 nodes, depth 3)
New solution: 28 (32 backtracks, 46 nodes, depth 3)
Optimality gap: [23, 28] 17.857 \PYGZpc{} (37 backtracks, 58 nodes)
New solution: 27 (61 backtracks, 122 nodes, depth 3)
Optimality gap: [23, 27] 14.815 \PYGZpc{} (61 backtracks, 122 nodes)
Optimality gap: [24, 27] 11.111 \PYGZpc{} (132 backtracks, 269 nodes)
Optimality gap: [25, 27] 7.407 \PYGZpc{} (177 backtracks, 395 nodes)
Optimality gap: [26, 27] 3.704 \PYGZpc{} (189 backtracks, 467 nodes)
Optimality gap: [27, 27] 0.000 \PYGZpc{} (189 backtracks, 482 nodes)
HBFS open list restarts: 0.000 \PYGZpc{} and reuse: 25.926 \PYGZpc{} of 27
Node redundancy during HBFS: 25.519 \PYGZpc{}
Optimum: 27 in 189 backtracks and 482 nodes ( 95 removals by DEE) and 0.010 seconds.
end.
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a Markov Random Field (MRF) file \sphinxcode{\sphinxupquote{pedigree9.uai.xz}} in UAI format. Solve it using bounded (of degree at most 8) variable elimination enhanced by cost function decomposition in preprocessing \sphinxcite{userdoc:favier2011a} followed by BTD\sphinxhyphen{}HBFS exploiting only small\sphinxhyphen{}size (less than four variables) separators:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{pedigree9}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{p}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{4}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{1118} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{7} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{1118} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{4.}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file} \PYG{n}{specified}\PYG{o}{.} \PYG{n}{Trying} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{pedigree9}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz}\PYG{o}{.}\PYG{n}{evid}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Generic} \PYG{n}{variable} \PYG{n}{elimination} \PYG{n}{of} \PYG{n}{degree} \PYG{l+m+mi}{4}
\PYG{n}{Maximum} \PYG{n}{degree} \PYG{n}{of} \PYG{n}{generic} \PYG{n}{variable} \PYG{n}{elimination}\PYG{p}{:} \PYG{l+m+mi}{4}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.003733} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.073664} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{232} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{517} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{415} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{553902779}\PYG{p}{,} \PYG{l+m+mi}{13246577453}\PYG{p}{]} \PYG{l+m+mf}{95.819}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{227}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{230}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{890}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.047} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{865165767} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{298.395} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{2.564e\PYGZhy{}130} \PYG{p}{(}\PYG{l+m+mi}{72} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{140} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{844685630} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{296.347} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.987e\PYGZhy{}129} \PYG{p}{(}\PYG{l+m+mi}{128} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{254} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{822713386} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{294.149} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.789e\PYGZhy{}128} \PYG{p}{(}\PYG{l+m+mi}{188} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{373} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{809800912} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{292.858} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{6.506e\PYGZhy{}128} \PYG{p}{(}\PYG{l+m+mi}{327} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{665} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{769281277} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{288.806} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{3.742e\PYGZhy{}126} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{771} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{755317979} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{287.410} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.512e\PYGZhy{}125} \PYG{p}{(}\PYG{l+m+mi}{714} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1549} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{755129381} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{287.391} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.540e\PYGZhy{}125} \PYG{p}{(}\PYG{l+m+mi}{927} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2038} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{711184893} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{282.997} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.248e\PYGZhy{}123} \PYG{p}{(}\PYG{l+m+mi}{1249} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2685} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{HBFS} \PYG{n+nb}{open} \PYG{n+nb}{list} \PYG{n}{restarts}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{o+ow}{and} \PYG{n}{reuse}\PYG{p}{:} \PYG{l+m+mf}{39.620} \PYG{o}{\PYGZpc{}} \PYG{n}{of} \PYG{l+m+mi}{1474}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{22.653} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{711184893} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{282.997} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{1.248e\PYGZhy{}123} \PYG{o+ow}{in} \PYG{l+m+mi}{21719} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{56124} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{72435} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{4.310} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another MRF file \sphinxcode{\sphinxupquote{GeomSurf\sphinxhyphen{}7\sphinxhyphen{}gm256.uai.xz}}. Solve it using Virtual Arc Consistency (VAC) in preprocessing \sphinxcite{userdoc:cooper2008} and exploit a VAC\sphinxhyphen{}based value \sphinxcite{userdoc:cooper2010a} and variable \sphinxcite{userdoc:trosser2020a} ordering heuristics:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GeomSurf}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{n}{gm256}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{A} \PYG{o}{\PYGZhy{}}\PYG{n}{V} \PYG{o}{\PYGZhy{}}\PYG{n}{vacint}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{787} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{7} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{3527} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{3.}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file} \PYG{n}{specified}\PYG{o}{.} \PYG{n}{Trying} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GeomSurf}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{7}\PYG{o}{\PYGZhy{}}\PYG{n}{gm256}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz}\PYG{o}{.}\PYG{n}{evid}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.001227} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{5879065363} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1074.088} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.082}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{VAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{5906374927} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1076.819} \PYG{p}{(}\PYG{n+nb}{iter}\PYG{p}{:}\PYG{l+m+mi}{486}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{726}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{240} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{234}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{1.872} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{729} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{4819} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{7}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{3128} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5906374927}\PYG{p}{,} \PYG{l+m+mi}{111615200815}\PYG{p}{]} \PYG{l+m+mf}{94.708}\PYG{o}{\PYGZpc{}}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5968997522} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1083.081} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{4.204e\PYGZhy{}471} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{19} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{21}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5920086558}\PYG{p}{,} \PYG{l+m+mi}{5968997522}\PYG{p}{]} \PYG{l+m+mf}{0.819} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{17} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{36} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{5922481881} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1078.430} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{4.404e\PYGZhy{}469} \PYG{p}{(}\PYG{l+m+mi}{17} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{48} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{5922481881}\PYG{p}{,} \PYG{l+m+mi}{5922481881}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{21} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{52} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{846}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{360} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{351}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{11.538} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{5922481881} \PYG{n}{energy}\PYG{p}{:} \PYG{l+m+mf}{1078.430} \PYG{n}{prob}\PYG{p}{:} \PYG{l+m+mf}{4.404e\PYGZhy{}469} \PYG{o+ow}{in} \PYG{l+m+mi}{21} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{52} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{2749} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.980} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another MRF file \sphinxcode{\sphinxupquote{1CM1.uai.xz}}. Solve it by applying first an initial upper bound probing, and secondly, use a modified variable ordering heuristic based on VAC\sphinxhyphen{}integrality during search \sphinxcite{userdoc:trosser2020a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{n}{CM1}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{A}\PYG{o}{=}\PYG{l+m+mi}{1000} \PYG{o}{\PYGZhy{}}\PYG{n}{vacint} \PYG{o}{\PYGZhy{}}\PYG{n}{rasps} \PYG{o}{\PYGZhy{}}\PYG{n}{vacthr}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{37} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{350} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{703} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file} \PYG{n}{specified}\PYG{o}{.} \PYG{n}{Trying} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{l+m+mi}{1}\PYG{n}{CM1}\PYG{o}{.}\PYG{n}{uai}\PYG{o}{.}\PYG{n}{xz}\PYG{o}{.}\PYG{n}{evid}
\PYG{n}{No} \PYG{n}{evidence} \PYG{n}{file}\PYG{o}{.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000679} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{103988236701} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12486.138} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{0.000}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{VAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{103988236701} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12486.138} \PYG{p}{(}\PYG{n+nb}{iter}\PYG{p}{:}\PYG{l+m+mi}{4068}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{4389}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{189} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{186}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{2326139858} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{2320178814} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{0} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{21288438} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{19} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{11823689} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{20} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000000}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{8187968} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{21} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6858739} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{22} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6058812} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{22} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{5504560} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{22} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000001}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3972336} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{23} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000002}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3655432} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{23} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000002}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3067825} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{23} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000002}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{2174446} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000003}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1641827} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000004}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1376213} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000005}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{208082} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{24} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000031}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{104041} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{26} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000068}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{52020} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000140}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{26010} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000281}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{13005} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0000561}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6502} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0001122}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3251} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0002245}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1625} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0004491}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{812} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0008987}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{406} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0017974}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{203} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0035947}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{101} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0072250}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{50} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0145946}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{25} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0291892}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{12} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.0608108}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{6} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.1216216}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{3} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.2432432}
\PYG{n}{Threshold}\PYG{p}{:} \PYG{l+m+mi}{1} \PYG{n}{NbAssignedVar}\PYG{p}{:} \PYG{l+m+mi}{27} \PYG{n}{Ratio}\PYG{p}{:} \PYG{l+m+mf}{0.7297297}
\PYG{n}{RASPS}\PYG{o}{/}\PYG{n}{VAC} \PYG{n}{threshold}\PYG{p}{:} \PYG{l+m+mi}{203}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{41.340} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{37} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{3366} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{38}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{331}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{626} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{35}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{103988236701}\PYG{p}{,} \PYG{l+m+mi}{239074057808}\PYG{p}{]} \PYG{l+m+mf}{56.504}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{104206588216} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12464.303} \PYG{n}{prob}\PYG{p}{:} \PYG{n}{inf} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{RASPS} \PYG{n}{done} \PYG{o+ow}{in} \PYG{n}{preprocessing} \PYG{p}{(}\PYG{n}{backtrack}\PYG{p}{:} \PYG{l+m+mi}{4} \PYG{n}{nodes}\PYG{p}{:} \PYG{l+m+mi}{8}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{104174014744} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12467.560} \PYG{n}{prob}\PYG{p}{:} \PYG{n}{inf} \PYG{p}{(}\PYG{l+m+mi}{4} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{12} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{104174014744}\PYG{p}{,} \PYG{l+m+mi}{104174014744}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{7} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{15} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{VAC} \PYG{n}{iterations}\PYG{p}{:} \PYG{l+m+mi}{4695}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{o+ow}{is} \PYG{n}{VAC}\PYG{p}{:} \PYG{l+m+mi}{458} \PYG{n}{Number} \PYG{n}{of} \PYG{n}{times} \PYG{n}{isvac} \PYG{o+ow}{and} \PYG{n}{itThreshold} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:} \PYG{l+m+mi}{451}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{104174014744} \PYG{n}{energy}\PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12467.560} \PYG{n}{prob}\PYG{p}{:} \PYG{n}{inf} \PYG{o+ow}{in} \PYG{l+m+mi}{7} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{15} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{937} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{41.354} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a weighted Max\sphinxhyphen{}SAT file \sphinxcode{\sphinxupquote{brock200\_4.clq.wcnf.xz}} in wcnf format. Solve it using a modified variable ordering heuristic \sphinxcite{userdoc:schiex2014a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{brock200\PYGZus{}4}\PYG{o}{.}\PYG{n}{clq}\PYG{o}{.}\PYG{n}{wcnf}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c} \PYG{n}{Read} \PYG{l+m+mi}{200} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{2} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{7011} \PYG{n}{clauses}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000485} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{91} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{86.813}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{92} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{1.087}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.040} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{200} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{400} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{6811} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{68}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{92}\PYG{p}{,} \PYG{l+m+mi}{200}\PYG{p}{]} \PYG{l+m+mf}{54.000}\PYG{o}{\PYGZpc{}}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{189} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{188} \PYG{p}{(}\PYG{l+m+mi}{45} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{143} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{37}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{187} \PYG{p}{(}\PYG{l+m+mi}{155} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{473} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{47}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{186} \PYG{p}{(}\PYG{l+m+mi}{892} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2247} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{19}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{185} \PYG{p}{(}\PYG{l+m+mi}{3874} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{8393} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{70}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{184} \PYG{p}{(}\PYG{l+m+mi}{29475} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{62393} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{40}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{183} \PYG{p}{(}\PYG{l+m+mi}{221446} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{522724} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{11}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{37.221} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{183} \PYG{o+ow}{in} \PYG{l+m+mi}{281307} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{896184} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{9478} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{25.977} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download another WCSP file \sphinxcode{\sphinxupquote{latin4.wcsp.xz}}. Count the number of feasible solutions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{latin4}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{a}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{16} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{24} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{4.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{2e\PYGZhy{}06} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{2.083}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.006} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{16} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{64} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{8} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{48}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{95.200}\PYG{o}{\PYGZpc{}}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{49}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{95.100} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{17} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{41} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{58}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{94.200} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{355} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{812} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{72}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{92.800} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{575} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1309} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{0.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{575} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1318} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}    \PYG{p}{:} \PYG{o}{=}  \PYG{l+m+mi}{576}
\PYG{n}{Time}                   \PYG{p}{:}    \PYG{l+m+mf}{0.306} \PYG{n}{seconds}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o+ow}{in} \PYG{l+m+mi}{575} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1318} \PYG{n}{nodes}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Find a greedy sequence of at most 20 diverse solutions with Hamming distance greater than 12 between any pair of solutions:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{latin4}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{a}\PYG{o}{=}\PYG{l+m+mi}{20} \PYG{o}{\PYGZhy{}}\PYG{n}{div}\PYG{o}{=}\PYG{l+m+mi}{12}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{16} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{4} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{24} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{4.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{3e\PYGZhy{}06} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Reverse} \PYG{n}{DAC} \PYG{n}{dual} \PYG{n}{bound}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{p}{(}\PYG{o}{+}\PYG{l+m+mf}{2.083}\PYG{o}{\PYGZpc{}}\PYG{p}{)}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.009} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{320} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{7968} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{26}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{8} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{48}\PYG{p}{,} \PYG{l+m+mi}{1000}\PYG{p}{]} \PYG{l+m+mf}{95.200}\PYG{o}{\PYGZpc{}}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{1} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{49} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{11} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{18.182} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{48} \PYG{o+ow}{in} \PYG{l+m+mi}{2} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{11} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.017} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{2} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{52} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{879} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{871}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{5} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{882} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{51} \PYG{p}{(}\PYG{l+m+mi}{5} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1748} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{868}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{51}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.922} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{1749} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{0.172} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{51} \PYG{o+ow}{in} \PYG{l+m+mi}{6} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{1749} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.046} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{3} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{p}{(}\PYG{l+m+mi}{6} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{2569} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{823}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{62} \PYG{p}{(}\PYG{l+m+mi}{14} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{3407} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{824}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{p}{(}\PYG{l+m+mi}{21} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4245} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{821}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{53}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.547} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{29} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4270} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12.500} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{30} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4276} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{57}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{14.035} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{31} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{4292} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{57} \PYG{p}{(}\PYG{l+m+mi}{31} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5114} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{819}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{1.017} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{57} \PYG{o+ow}{in} \PYG{l+m+mi}{31} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{5114} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.146} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{4} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{73} \PYG{p}{(}\PYG{l+m+mi}{44} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{5923} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{773}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{46} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{6702} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{778}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{p}{(}\PYG{l+m+mi}{53} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7485} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{773}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{58}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{15.517} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{70} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{7584} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{1.846} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{o+ow}{in} \PYG{l+m+mi}{70} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{7584} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.256} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{5} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{70} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{8307} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{726}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{p}{(}\PYG{l+m+mi}{100} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9139} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{728}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{l+m+mi}{112} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{9896} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{724}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{64} \PYG{p}{(}\PYG{l+m+mi}{116} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{10636} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{725}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{p}{(}\PYG{l+m+mi}{171} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{11654} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{725}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{3.484} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{58} \PYG{o+ow}{in} \PYG{l+m+mi}{171} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{11654} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.474} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{6} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{178} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{12347} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{677}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{207} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{13102} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{677}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{p}{(}\PYG{l+m+mi}{212} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{13804} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{680}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{59}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{16.949} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{251} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14053} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{60}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{18.333} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{256} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14093} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{61}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{19.672} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{259} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14126} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{62}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{20.968} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{260} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14165} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{62} \PYG{p}{(}\PYG{l+m+mi}{260} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{14849} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{675}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{4.936} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{62} \PYG{o+ow}{in} \PYG{l+m+mi}{260} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{14849} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.688} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{7} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{c} \PYG{l+m+mi}{2097152} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{77} \PYG{p}{(}\PYG{l+m+mi}{267} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{15495} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{630}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{283} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{16160} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{629}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{75} \PYG{p}{(}\PYG{l+m+mi}{334} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{16982} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{628}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{335} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{17615} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{628}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{64}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{23.438} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{17946} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{18577} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{627}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{65}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{24.615} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{18581} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{5.915} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{o+ow}{in} \PYG{l+m+mi}{383} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{18581} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{0.963} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{8} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{81} \PYG{p}{(}\PYG{l+m+mi}{383} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{19161} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{583}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{425} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{19865} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{583}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{69} \PYG{p}{(}\PYG{l+m+mi}{471} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{20646} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{585}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{479} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{21273} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{581}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{p}{(}\PYG{l+m+mi}{483} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{21881} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{580}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{6.014} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{65} \PYG{o+ow}{in} \PYG{l+m+mi}{483} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{21881} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.175} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{9} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{483} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{22413} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{535}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{66}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{25.758} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{581} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{22902} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{p}{(}\PYG{l+m+mi}{581} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{23434} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{531}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{6.900} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{66} \PYG{o+ow}{in} \PYG{l+m+mi}{581} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{23434} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.379} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{10} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{619} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24035} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{484}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{67}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{26.866} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{686} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24436} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{68}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{27.941} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{686} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24444} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{7.924} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{o+ow}{in} \PYG{l+m+mi}{686} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{24444} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.597} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{11} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{714} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{24958} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{436}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{p}{(}\PYG{l+m+mi}{739} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{25534} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{436}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{8.052} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{68} \PYG{o+ow}{in} \PYG{l+m+mi}{739} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{25534} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.712} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{12} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{c} \PYG{l+m+mi}{4194304} \PYG{n}{Bytes} \PYG{n}{allocated} \PYG{k}{for} \PYG{n}{long} \PYG{n}{long} \PYG{n}{stack}\PYG{o}{.}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{81} \PYG{p}{(}\PYG{l+m+mi}{770} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{26006} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{p}{(}\PYG{l+m+mi}{772} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{26399} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{77} \PYG{p}{(}\PYG{l+m+mi}{779} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{26818} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{809} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{27354} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{390}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{858} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28065} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{389}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{69}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{28.986} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{863} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28122} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{30.000} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{864} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28130} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{71}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{30.986} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{864} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28140} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{71} \PYG{p}{(}\PYG{l+m+mi}{864} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28532} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{387}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{8.762} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{71} \PYG{o+ow}{in} \PYG{l+m+mi}{864} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{28532} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{1.981} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{13} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{898} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{28974} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{343}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{p}{(}\PYG{l+m+mi}{906} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{29334} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{340}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{72}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{31.944} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{979} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{29782} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.563} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{72} \PYG{o+ow}{in} \PYG{l+m+mi}{979} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{29782} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.212} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{14} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{86} \PYG{p}{(}\PYG{l+m+mi}{1062} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{30429} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{292}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1078} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{30768} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{292}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{p}{(}\PYG{l+m+mi}{1085} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31080} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{292}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{74}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{33.784} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1102} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31203} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{10.124} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{74} \PYG{o+ow}{in} \PYG{l+m+mi}{1102} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{31203} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.441} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{15} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{1103} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31448} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{246}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{p}{(}\PYG{l+m+mi}{1122} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{31726} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{246}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{p}{(}\PYG{l+m+mi}{1183} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32087} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{245}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{76}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{35.526} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1231} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32181} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.816} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{76} \PYG{o+ow}{in} \PYG{l+m+mi}{1231} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{32181} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.603} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{16} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1253} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32419} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{197}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{1315} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32735} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{197}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{p}{(}\PYG{l+m+mi}{1336} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32968} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{196}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{78}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{37.179} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1349} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{32993} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.575} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{78} \PYG{o+ow}{in} \PYG{l+m+mi}{1349} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{32993} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.760} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{17} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1349} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33141} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{151}\PYG{p}{)}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{p}{(}\PYG{l+m+mi}{1374} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33334} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{149}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{79}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{37.975} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1474} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33532} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.421} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{79} \PYG{o+ow}{in} \PYG{l+m+mi}{1474} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{33532} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{2.924} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{18} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1546} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33775} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{102}\PYG{p}{)}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{80}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{38.750} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1592} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{33864} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.328} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{o+ow}{in} \PYG{l+m+mi}{1592} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{33864} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{3.085} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{19} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{New} \PYG{n}{solution}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{p}{(}\PYG{l+m+mi}{1687} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{34105} \PYG{n}{nodes}\PYG{p}{,} \PYG{n}{depth} \PYG{l+m+mi}{54}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.263} \PYG{o}{\PYGZpc{}}
\PYG{n}{Optimum}\PYG{p}{:} \PYG{l+m+mi}{80} \PYG{o+ow}{in} \PYG{l+m+mi}{1687} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{34105} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{3.219} \PYG{n}{seconds}\PYG{o}{.}
\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+} \PYG{n}{Search} \PYG{k}{for} \PYG{n}{solution} \PYG{l+m+mi}{20} \PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}\PYG{o}{+}
\PYG{n}{Optimality} \PYG{n}{gap}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{49}\PYG{p}{]} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{95.100} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{l+m+mi}{1809} \PYG{n}{backtracks}\PYG{p}{,} \PYG{l+m+mi}{34349} \PYG{n}{nodes}\PYG{p}{)}
\PYG{n}{Node} \PYG{n}{redundancy} \PYG{n}{during} \PYG{n}{HBFS}\PYG{p}{:} \PYG{l+m+mf}{9.197} \PYG{o}{\PYGZpc{}}
\PYG{n}{No} \PYG{n}{solution} \PYG{o+ow}{in} \PYG{l+m+mi}{1809} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{34349} \PYG{n}{nodes} \PYG{p}{(} \PYG{l+m+mi}{0} \PYG{n}{removals} \PYG{n}{by} \PYG{n}{DEE}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mf}{3.377} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Download a crisp CSP file \sphinxcode{\sphinxupquote{GEOM40\_6.wcsp.xz}} (initial upper bound equal to 1). Count the number of solutions using \#BTD \sphinxcite{userdoc:favier2009a} using a min\sphinxhyphen{}fill variable ordering (warning, cannot use BTD to find all solutions in optimization):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GEOM40\PYGZus{}6}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{ub}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{hbfs}\PYG{p}{:}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{40} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{6} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{1.1e\PYGZhy{}05} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001019} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{40} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{240} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{5}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{20}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{29}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}    \PYG{p}{:} \PYG{o}{=}  \PYG{l+m+mi}{411110802705928379432960}
\PYG{n}{Number} \PYG{n}{of} \PYG{c+c1}{\PYGZsh{}goods       :    3993}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{used} \PYG{c+c1}{\PYGZsh{}goods  :    17190}
\PYG{n}{Size} \PYG{n}{of} \PYG{n}{sep}            \PYG{p}{:}    \PYG{l+m+mi}{4}
\PYG{n}{Time}                   \PYG{p}{:}    \PYG{l+m+mf}{0.055} \PYG{n}{seconds}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o+ow}{in} \PYG{l+m+mi}{13689} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{27378} \PYG{n}{nodes}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
Get a quick approximation of the number of solutions of a CSP with Approx\#BTD \sphinxcite{userdoc:favier2009a}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{n}{EXAMPLES}\PYG{o}{/}\PYG{n}{GEOM40\PYGZus{}6}\PYG{o}{.}\PYG{n}{wcsp}\PYG{o}{.}\PYG{n}{xz} \PYG{o}{\PYGZhy{}}\PYG{n}{O}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{n}{a} \PYG{o}{\PYGZhy{}}\PYG{n}{B}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{D} \PYG{o}{\PYGZhy{}}\PYG{n}{ub}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{n}{hbfs}\PYG{p}{:}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Read} \PYG{l+m+mi}{40} \PYG{n}{variables}\PYG{p}{,} \PYG{k}{with} \PYG{l+m+mi}{6} \PYG{n}{values} \PYG{n}{at} \PYG{n}{most}\PYG{p}{,} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{cost} \PYG{n}{functions}\PYG{p}{,} \PYG{k}{with} \PYG{n}{maximum} \PYG{n}{arity} \PYG{l+m+mf}{2.}
\PYG{n}{Cost} \PYG{n}{function} \PYG{n}{decomposition} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{9e\PYGZhy{}06} \PYG{n}{seconds}\PYG{o}{.}
\PYG{n}{Preprocessing} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.000997} \PYG{n}{seconds}\PYG{o}{.}
\PYG{l+m+mi}{40} \PYG{n}{unassigned} \PYG{n}{variables}\PYG{p}{,} \PYG{l+m+mi}{240} \PYG{n}{values} \PYG{o+ow}{in} \PYG{n+nb}{all} \PYG{n}{current} \PYG{n}{domains} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{,} \PYG{n+nb}{max} \PYG{n}{size}\PYG{p}{:}\PYG{l+m+mi}{6}\PYG{p}{)} \PYG{o+ow}{and} \PYG{l+m+mi}{78} \PYG{n}{non}\PYG{o}{\PYGZhy{}}\PYG{n}{unary} \PYG{n}{cost} \PYG{n}{functions} \PYG{p}{(}\PYG{n}{med}\PYG{o}{.} \PYG{n}{arity}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{med}\PYG{o}{.} \PYG{n}{degree}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{Initial} \PYG{n}{lower} \PYG{o+ow}{and} \PYG{n}{upper} \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{l+m+mf}{100.000}\PYG{o}{\PYGZpc{}}

\PYG{n}{part} \PYG{l+m+mi}{1} \PYG{p}{:} \PYG{l+m+mi}{40} \PYG{n}{variables} \PYG{o+ow}{and} \PYG{l+m+mi}{71} \PYG{n}{constraints} \PYG{p}{(}\PYG{n}{really} \PYG{n}{added}\PYG{p}{)}
\PYG{n}{part} \PYG{l+m+mi}{2} \PYG{p}{:} \PYG{l+m+mi}{10} \PYG{n}{variables} \PYG{o+ow}{and} \PYG{l+m+mi}{7} \PYG{n}{constraints} \PYG{p}{(}\PYG{n}{really} \PYG{n}{added}\PYG{p}{)}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{number} \PYG{n}{of} \PYG{n}{parts} \PYG{p}{:} \PYG{l+m+mi}{2}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n}{time} \PYG{p}{:} \PYG{l+m+mf}{0.000} \PYG{n}{seconds}\PYG{o}{.}

\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{width}  \PYG{p}{:} \PYG{l+m+mi}{5}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{height} \PYG{p}{:} \PYG{l+m+mi}{17}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{clusters}        \PYG{p}{:} \PYG{l+m+mi}{33}
\PYG{n}{Tree} \PYG{n}{decomposition} \PYG{n}{time}\PYG{p}{:} \PYG{l+m+mf}{0.001} \PYG{n}{seconds}\PYG{o}{.}

\PYG{n}{Cartesian} \PYG{n}{product}                  \PYG{p}{:}    \PYG{l+m+mi}{13367494538843734031554962259968}
\PYG{n}{Upper} \PYG{n}{bound} \PYG{n}{of} \PYG{n}{number} \PYG{n}{of} \PYG{n}{solutions} \PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{1719926784000000000000000}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{solutions}    \PYG{p}{:} \PYG{o}{\PYGZti{}}\PYG{o}{=} \PYG{l+m+mi}{480000000000000000000000}
\PYG{n}{Number} \PYG{n}{of} \PYG{c+c1}{\PYGZsh{}goods       :    468}
\PYG{n}{Number} \PYG{n}{of} \PYG{n}{used} \PYG{c+c1}{\PYGZsh{}goods  :    4788}
\PYG{n}{Size} \PYG{n}{of} \PYG{n}{sep}            \PYG{p}{:}    \PYG{l+m+mi}{3}
\PYG{n}{Time}                   \PYG{p}{:}    \PYG{l+m+mf}{0.011} \PYG{n}{seconds}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{o+ow}{in} \PYG{l+m+mi}{3738} \PYG{n}{backtracks} \PYG{o+ow}{and} \PYG{l+m+mi}{7476} \PYG{n}{nodes}
\PYG{n}{end}\PYG{o}{.}
\end{sphinxVerbatim}

\end{itemize}


\chapter{Command line options}
\label{\detokenize{userdoc:command-line-options}}
\sphinxAtStartPar
If you just execute:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2}
\end{sphinxVerbatim}

\sphinxAtStartPar
toulbar2 will give you its (long) list of optional parameters, that you can
see in part \sphinxstyleemphasis{‘Available options’} of :
\sphinxcode{\sphinxupquote{ToulBar2 Help Message}}.

\sphinxAtStartPar
To deactivate a default command line option, just use the command\sphinxhyphen{}line option
followed by \sphinxcode{\sphinxupquote{:}}. For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{toulbar2} \PYG{o}{\PYGZhy{}}\PYG{n}{dee}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{file}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
will disable the default Dead End Elimination \sphinxcite{userdoc:givry2013a} (aka Soft
Neighborhood Substitutability) preprocessing.

\sphinxAtStartPar
We now describe in more detail toulbar2 optional parameters.


\section{General control}
\label{\detokenize{userdoc:general-control}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}agap={[}decimal{]}}
\sphinxAtStartPar
stops search if the absolute optimality gap reduces below the given value (provides guaranteed approximation) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}rgap={[}double{]}}
\sphinxAtStartPar
stops search if the relative optimality gap reduces below the given value (provides guaranteed approximation) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}a={[}integer{]}}
\sphinxAtStartPar
finds at most a given number of solutions with a cost strictly lower than the initial upper bound and stops, or if no integer is given, finds all solutions (or counts the number of zero\sphinxhyphen{}cost satisfiable solutions in conjunction with BTD)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}D]  
\sphinxAtStartPar
approximate satisfiable solution count with BTD
\item [\sphinxhyphen{}logz]  
\sphinxAtStartPar
computes log of probability of evidence (i.e. log partition function or log(Z) or PR task) for graphical models only (problem file extension .uai)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}timer={[}integer{]}}
\sphinxAtStartPar
gives a CPU time limit in seconds. toulbar2 will stop after the specified CPU time has been consumed. The time limit is a CPU user time limit, not wall clock time limit.

\sphinxlineitem{\sphinxhyphen{}bt={[}integer{]}}
\sphinxAtStartPar
gives a limit on the number of backtracks (\(9223372036854775807\) by default)

\sphinxlineitem{\sphinxhyphen{}seed={[}integer{]}}
\sphinxAtStartPar
random seed non\sphinxhyphen{}negative value or use current time if a negative value is given (default value is 1)

\end{description}


\section{Preprocessing}
\label{\detokenize{userdoc:preprocessing}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}nopre]  
\sphinxAtStartPar
deactivates all preprocessing options (equivalent to \sphinxhyphen{}e:
\sphinxhyphen{}p: \sphinxhyphen{}t: \sphinxhyphen{}f: \sphinxhyphen{}dec: \sphinxhyphen{}n: \sphinxhyphen{}mst: \sphinxhyphen{}dee: \sphinxhyphen{}trws:)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}p={[}integer{]}}
\sphinxAtStartPar
preprocessing only: general variable elimination
of degree less than or equal to the given value (default value is \sphinxhyphen{}1)

\sphinxlineitem{\sphinxhyphen{}t={[}integer{]}}
\sphinxAtStartPar
preprocessing only: simulates restricted path
consistency by adding ternary cost functions on triangles of binary
cost functions within a given maximum space limit (in MB)

\sphinxlineitem{\sphinxhyphen{}f={[}integer{]}}
\sphinxAtStartPar
preprocessing only: variable elimination of
functional (f=1) (resp. bijective (f=2)) variables (default value is 1)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}dec]  
\sphinxAtStartPar
preprocessing only: pairwise decomposition \sphinxcite{userdoc:favier2011a} of cost
functions with arity \(>=3\) into smaller arity cost functions
(default option)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}n={[}integer{]}}
\sphinxAtStartPar
preprocessing only: projects n\sphinxhyphen{}ary cost functions
on all binary cost functions if n is lower than the given value
(default value is 10). See \sphinxcite{userdoc:favier2011a}.

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}amo]  
\sphinxAtStartPar
automatically detects at\sphinxhyphen{}most\sphinxhyphen{}one constraints and adds them to existing
knapsack/linear/pseudo\sphinxhyphen{}boolean constraints.
\item [\sphinxhyphen{}mst]  
\sphinxAtStartPar
find a maximum spanning tree ordering for DAC
\item [\sphinxhyphen{}S]  
\sphinxAtStartPar
preprocessing only: performs singleton consistency (only in
conjunction with option \sphinxhyphen{}A)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}M={[}integer{]}}
\sphinxAtStartPar
preprocessing only:
apply the Min Sum Diffusion algorithm (default is inactivated, with
a number of iterations of 0). See \sphinxcite{userdoc:cooper2010a}.

\sphinxlineitem{\sphinxhyphen{}trws={[}float{]}}
\sphinxAtStartPar
preprocessing only: enforces TRW\sphinxhyphen{}S until a given precision is reached
(default value is 0.001). See Kolmogorov 2006.

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}\sphinxhyphen{}trws\sphinxhyphen{}order]  
\sphinxAtStartPar
replaces DAC order by Kolmogorov’s TRW\sphinxhyphen{}S order.
\end{optionlist}
\begin{description}
\sphinxlineitem{\textendash{}trws\sphinxhyphen{}n\sphinxhyphen{}iters={[}integer{]}}
\sphinxAtStartPar
enforce at most N iterations of TRW\sphinxhyphen{}S (default value is 1000).

\sphinxlineitem{\textendash{}trws\sphinxhyphen{}n\sphinxhyphen{}iters\sphinxhyphen{}no\sphinxhyphen{}change={[}integer{]}}
\sphinxAtStartPar
stop TRW\sphinxhyphen{}S when N iterations did not change the lower bound up the given precision (default value is 5, \sphinxhyphen{}1=never).

\sphinxlineitem{\textendash{}trws\sphinxhyphen{}n\sphinxhyphen{}iters\sphinxhyphen{}compute\sphinxhyphen{}ub={[}integer{]}}
\sphinxAtStartPar
compute a basic upper bound every N steps during TRW\sphinxhyphen{}S (default value is 100)

\end{description}


\section{Initial upper bounding}
\label{\detokenize{userdoc:initial-upper-bounding}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}l={[}integer{]}}
\sphinxAtStartPar
limited discrepancy search \sphinxcite{userdoc:ginsberg1995}, use a negative value to stop the search after the given absolute number of discrepancies has been explored (discrepancy bound = 4 by default)

\sphinxlineitem{\sphinxhyphen{}L={[}integer{]}}
\sphinxAtStartPar
randomized (quasi\sphinxhyphen{}random variable ordering) search with restart (maximum number of nodes/VNS restarts = 10000 by default)

\sphinxlineitem{\sphinxhyphen{}i={[}“string”{]}}
\sphinxAtStartPar
initial upper bound found by INCOP local search
solver \sphinxcite{userdoc:idwalk-cp04}. The string parameter is optional,
using “0 1 3 idwa 100000 cv v 0 200 1 0 0” by default with the
following meaning:
\sphinxstyleemphasis{stoppinglowerbound randomseed nbiterations method nbmoves
neighborhoodchoice neighborhoodchoice2 minnbneighbors maxnbneighbors
neighborhoodchoice3 autotuning tracemode}.

\sphinxlineitem{\sphinxhyphen{}pils={[}“string”{]}}
\sphinxAtStartPar
initial upper bound found by PILS local search
solver. The string parameter is optional,
using “3 0 0.333 100 500 10000 0.1 0.5 0.1 0.1” by default with the
following meaning:
\sphinxstyleemphasis{nbruns perturb\_mode perturb\_strength flatMaxIter nbEvalHC
nbEvalMax strengthMin strengthMax incrFactor decrFactor}.

\sphinxlineitem{\sphinxhyphen{}x={[}(,i{[}\(=\#<>\){]}a)*{]}}
\sphinxAtStartPar
performs an elementary operation (’\(=\)’:assign,
‘\(\#\)’:remove, ‘\(<\)’:decrease, ‘\(>\)’:increase) with
value a on variable of index i (multiple operations are separated by a
comma and no space) (without any
argument, a complete assignment \textendash{} used as initial upper bound and
as a value heuristic \textendash{} read from default file “sol” taken as a
certificate or given directly as an additional input
filename with “.sol” extension and without \sphinxstylestrong{\sphinxhyphen{}x})

\sphinxlineitem{\sphinxhyphen{}ub={[}decimal{]}}
\sphinxAtStartPar
gives an initial upper bound

\sphinxlineitem{\sphinxhyphen{}rasps={[}integer{]}}
\sphinxAtStartPar
VAC\sphinxhyphen{}based upper bound probing heuristic (0: disable, \textgreater{}0: max. nb. of
backtracks, 1000 if no integer given) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}raspslds={[}integer{]}}
\sphinxAtStartPar
VAC\sphinxhyphen{}based upper bound probing heuristic using LDS instead of DFS
(0: DFS, \textgreater{}0: max. discrepancy) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}raspsdeg={[}integer{]}}
\sphinxAtStartPar
automatic threshold cost value selection for probing heuristic
(default value is 10 degrees)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}raspsini]  
\sphinxAtStartPar
reset weighted degree variable ordering heuristic after doing
upper bound probing
\end{optionlist}


\section{Tree search algorithms and tree decomposition selection}
\label{\detokenize{userdoc:tree-search-algorithms-and-tree-decomposition-selection}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}hbfs={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search \sphinxcite{userdoc:katsirelos2015a}, restarting from the
root after a given number of backtracks (default value is 16384)

\sphinxlineitem{\sphinxhyphen{}hbfsmin={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search compromise between BFS and DFS minimum node redundancy
threshold (alpha percentage, default value is 5\%)

\sphinxlineitem{\sphinxhyphen{}hbfsmax={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search compromise between BFS and DFS maximum node redundancy
threshold (beta percentage default value is 10\%)

\sphinxlineitem{\sphinxhyphen{}open={[}integer{]}}
\sphinxAtStartPar
hybrid best\sphinxhyphen{}first search limit on the number
of stored open nodes (default value is \sphinxhyphen{}1, i.e., no limit)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}burst]  
\sphinxAtStartPar
in parallel HBFS, workers send their solutions and open nodes as soon as possible (by default)
For using a parallel version of HBFS, after compiling with MPI option (cmake \sphinxhyphen{}DMPI=ON .)
use “mpirun \sphinxhyphen{}n {[}NbOfProcess{]} toulbar2 problem.wcsp”
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}eps={[}integer|filename{]}}
\sphinxAtStartPar
Embarrassingly parallel search mode. It outputs a given number of open nodes in \sphinxhyphen{}x format and exit  (default value is 0).
See ./misc/script/eps.sh to run them. Use this option twice to specify the output filename.

\sphinxlineitem{\sphinxhyphen{}B={[}integer{]}}
\sphinxAtStartPar
(0) HBFS, (1) BTD\sphinxhyphen{}HBFS \sphinxcite{userdoc:schiex2006a} \sphinxcite{userdoc:katsirelos2015a},
(2) RDS\sphinxhyphen{}BTD \sphinxcite{userdoc:sanchez2009a}, (3) RDS\sphinxhyphen{}BTD with path decomposition
instead of tree decomposition \sphinxcite{userdoc:sanchez2009a} (default value is 0)

\sphinxlineitem{\sphinxhyphen{}O={[}filename{]}}
\sphinxAtStartPar
reads either a reverse variable elimination order (given by a list
of variable indexes) from a file
in order to build a tree decomposition (if BTD\sphinxhyphen{}like and/or variable
elimination methods are used) or reads a valid tree decomposition directly (given by a list of clusters in topological order of a rooted forest, each line contains a cluster number, followed by a cluster parent number with \sphinxhyphen{}1 for the first/root(s) cluster(s), followed by a list of variable indexes). It is also used as a DAC ordering.

\sphinxlineitem{\sphinxhyphen{}O={[}negative integer{]}}
\sphinxAtStartPar
build a tree decomposition (if BTD\sphinxhyphen{}like
and/or variable elimination methods are used) and also a compatible
DAC ordering using
\begin{itemize}
\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}1) maximum cardinality search ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}2) minimum degree ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}3) minimum fill\sphinxhyphen{}in ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}4) maximum spanning tree ordering (see \sphinxhyphen{}mst),

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}5) reverse Cuthill\sphinxhyphen{}Mckee ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}6) approximate minimum degree ordering,

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}7) default file ordering

\item {} 
\sphinxAtStartPar
(\sphinxhyphen{}8) lexicographic ordering of variable names

\end{itemize}

\sphinxAtStartPar
If not specified, then use the variable order in which variables appear in the problem file.

\sphinxlineitem{\sphinxhyphen{}root={[}integer{]}}
\sphinxAtStartPar
root cluster heuristic
(0:largest, 1:max. size/(height\sphinxhyphen{}size), 2:min. size/(height\sphinxhyphen{}size), 3:min. height) (default value is 0)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}minheight]  
\sphinxAtStartPar
minimizes cluster tree height when searching for the root cluster (can be slow to perform)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}j={[}integer{]}}
\sphinxAtStartPar
splits large clusters into a chain of smaller embedded clusters with a number of proper variables less than this number (use options “\sphinxhyphen{}B=3 \sphinxhyphen{}j=1 \sphinxhyphen{}svo \sphinxhyphen{}k=1” for pure RDS, use value 0 for no splitting) (default value is 0).

\sphinxlineitem{\sphinxhyphen{}r={[}integer{]}}
\sphinxAtStartPar
limit on the maximum cluster separator size (merge cluster with its father otherwise, use a negative value for no limit) (default value is \sphinxhyphen{}1)

\sphinxlineitem{\sphinxhyphen{}X={[}integer{]}}
\sphinxAtStartPar
limit on the minimum number of proper variables in a cluster (merge cluster with its father otherwise, use a zero for no limit) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}E={[}float{]}}
\sphinxAtStartPar
merges leaf clusters with their fathers if small local treewidth (in conjunction with option “\sphinxhyphen{}e” and positive threshold value) or ratio of number of separator variables by number of cluster variables above a given threshold (in conjunction with option \sphinxhyphen{}vns) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}F={[}integer{]}}
\sphinxAtStartPar
merges clusters automatically to give more freedom to variable ordering heuristic in BTD\sphinxhyphen{}HBFS
(\sphinxhyphen{}1: no merging, positive value: maximum iteration value for trying to solve the same subtree given its separator assignment before considering it as unmerged) (default value is \sphinxhyphen{}1)

\sphinxlineitem{\sphinxhyphen{}R={[}integer{]}}
\sphinxAtStartPar
choice for a specific root cluster number

\sphinxlineitem{\sphinxhyphen{}I={[}integer{]}}
\sphinxAtStartPar
choice for solving only a particular rooted cluster subtree
(with RDS\sphinxhyphen{}BTD only)

\end{description}


\section{Variable neighborhood search algorithms}
\label{\detokenize{userdoc:variable-neighborhood-search-algorithms}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}vns]  
\sphinxAtStartPar
unified decomposition guided variable neighborhood search
\sphinxcite{userdoc:ouali2017} (UDGVNS). A problem decomposition into clusters can be
given as *.dec, *.cov, or *.order input files or using tree
decomposition options such as \sphinxhyphen{}O. For a parallel version (UPDGVNS),
use “mpirun \sphinxhyphen{}n {[}NbOfProcess{]} toulbar2 \sphinxhyphen{}vns problem.wcsp”.
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}vnsini={[}integer{]}}
\sphinxAtStartPar
initial solution for VNS\sphinxhyphen{}like methods found: (\sphinxhyphen{}1) at random, (\sphinxhyphen{}2) min domain values, (\sphinxhyphen{}3) max domain values, (\sphinxhyphen{}4) first solution found by a complete method, (k=0 or more) tree search with k discrepancy max (\sphinxhyphen{}4 by default)

\sphinxlineitem{\sphinxhyphen{}ldsmin={[}integer{]}}
\sphinxAtStartPar
minimum discrepancy for VNS\sphinxhyphen{}like methods (1 by default)

\sphinxlineitem{\sphinxhyphen{}ldsmax={[}integer{]}}
\sphinxAtStartPar
maximum discrepancy for VNS\sphinxhyphen{}like methods (number of problem variables multiplied by maximum domain size \sphinxhyphen{}1 by default)

\sphinxlineitem{\sphinxhyphen{}ldsinc={[}integer{]}}
\sphinxAtStartPar
discrepancy increment strategy for VNS\sphinxhyphen{}like methods using (1) Add1, (2) Mult2, (3) Luby operator (2 by default)

\sphinxlineitem{\sphinxhyphen{}kmin={[}integer{]}}
\sphinxAtStartPar
minimum neighborhood size for VNS\sphinxhyphen{}like methods (4 by default)

\sphinxlineitem{\sphinxhyphen{}kmax={[}integer{]}}
\sphinxAtStartPar
maximum neighborhood size for VNS\sphinxhyphen{}like methods (number of problem variables by default)

\sphinxlineitem{\sphinxhyphen{}kinc={[}integer{]}}
\sphinxAtStartPar
neighborhood size increment strategy for VNS\sphinxhyphen{}like methods using: (1) Add1, (2) Mult2, (3) Luby operator (4) Add1/Jump (4 by default)

\sphinxlineitem{\sphinxhyphen{}best={[}integer{]}}
\sphinxAtStartPar
stop VNS\sphinxhyphen{}like methods if a better solution is found (default value is 0)

\end{description}


\section{Node processing \& bounding options}
\label{\detokenize{userdoc:node-processing-bounding-options}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}e={[}integer{]}}
\sphinxAtStartPar
performs “on the fly” variable elimination of variable with small
degree (less than or equal to a specified value, default is 3 creating
a maximum of ternary cost functions). See \sphinxcite{userdoc:larrosa2000}.

\sphinxlineitem{\sphinxhyphen{}k={[}integer{]}}
\sphinxAtStartPar
soft local consistency level (NC \sphinxcite{userdoc:larrosa2002} with Strong NIC for global cost functions=0 \sphinxcite{userdoc:ll2009}, (G)AC=1 \sphinxcite{userdoc:schiex2000b} \sphinxcite{userdoc:larrosa2002}, D(G)AC=2 \sphinxcite{userdoc:cooperfcsp}, FD(G)AC=3 \sphinxcite{userdoc:larrosa2003}, (weak) ED(G)AC=4 \sphinxcite{userdoc:heras2005} \sphinxcite{userdoc:ll2010}) (default value is 4). See also \sphinxcite{userdoc:cooper2010a} \sphinxcite{userdoc:ll2012asa}.

\sphinxlineitem{\sphinxhyphen{}A={[}integer{]}}
\sphinxAtStartPar
enforces VAC \sphinxcite{userdoc:cooper2008} at each search node with a search depth less than a given value (default value is 0)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}V]  
\sphinxAtStartPar
VAC\sphinxhyphen{}based value ordering heuristic (default option)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}T={[}decimal{]}}
\sphinxAtStartPar
threshold cost value for VAC (default value is 1)

\sphinxlineitem{\sphinxhyphen{}P={[}decimal{]}}
\sphinxAtStartPar
threshold cost value for VAC during the preprocessing phase only (default value is 1)

\sphinxlineitem{\sphinxhyphen{}C={[}float{]}}
\sphinxAtStartPar
multiplies all costs internally by this number when loading the problem (cannot be done with cfn format and probabilistic graphical models in uai/LG formats) (default value is 1)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}vacthr]  
\sphinxAtStartPar
automatic threshold cost value selection for VAC during search (must be combined with option \sphinxhyphen{}A)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}dee={[}integer{]}}
\sphinxAtStartPar
restricted dead\sphinxhyphen{}end elimination \sphinxcite{userdoc:givry2013a} (value pruning by dominance rule from EAC value (dee \(>=1\)  and dee \(<=3\) )) and soft neighborhood substitutability (in preprocessing (dee=2 or dee=4) or during search (dee=3)) (default value is 1)

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}o]  
\sphinxAtStartPar
ensures an optimal worst\sphinxhyphen{}case time complexity of DAC and EAC
(can be slower in practice)
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}kpdp={[}integer{]}}
\sphinxAtStartPar
solves knapsack constraints using dynamic programming
(\sphinxhyphen{}2: never, \sphinxhyphen{}1: only in preprocessing, 0: at every search node, \textgreater{}0: after a given number of nodes) (default value is \sphinxhyphen{}2)

\end{description}


\section{Branching, variable and value ordering}
\label{\detokenize{userdoc:branching-variable-and-value-ordering}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}svo]  
\sphinxAtStartPar
searches using a static variable ordering heuristic.
The variable order value used will be the same order as the DAC order.
\item [\sphinxhyphen{}b]  
\sphinxAtStartPar
searches using binary branching (by default) instead of n\sphinxhyphen{}ary branching.
Uses binary branching for interval domains and small domains
and dichotomic branching for large enumerated domains (see option \sphinxhyphen{}d).
\item [\sphinxhyphen{}c]  
\sphinxAtStartPar
searches using binary branching with last conflict
backjumping variable ordering heuristic \sphinxcite{userdoc:lecoutre2009}.
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}q={[}integer{]}}
\sphinxAtStartPar
use weighted degree variable ordering heuristic \sphinxcite{userdoc:boussemart2004}
if the number of cost
functions is less than the given value (default value is 1000000).

\sphinxlineitem{\sphinxhyphen{}var={[}integer{]}}
\sphinxAtStartPar
searches by branching only on the first {[}given value{]}
decision variables, assuming the remaining variables are
intermediate variables that will be completely assigned by the
decision variables (use a zero if all variables are decision
variables, default value is 0)

\sphinxlineitem{\sphinxhyphen{}m={[}integer{]}}
\sphinxAtStartPar
use a variable ordering heuristic that selects first variables such
that the sum of the mean (m=1) or median (m=2) cost of all incident
cost functions is maximum \sphinxcite{userdoc:schiex2014a}
(in conjunction with weighted degree
heuristic \sphinxhyphen{}q) (default value is 0: unused).

\sphinxlineitem{\sphinxhyphen{}d={[}integer{]}}
\sphinxAtStartPar
searches using dichotomic branching. The default d=1 splits domains
in the middle of domain range while d=2 splits domains in the middle
of the sorted domain based on unary costs.

\end{description}
\begin{optionlist}{3cm}
\item [\sphinxhyphen{}sortd]  
\sphinxAtStartPar
sorts domains in preprocessing based on increasing unary costs
(works only for binary WCSPs).
\item [\sphinxhyphen{}sortc]  
\sphinxAtStartPar
sorts constraints in preprocessing based on lexicographic ordering (1), decreasing DAC ordering (2 \sphinxhyphen{} default option), decreasing constraint tightness (3), DAC then tightness (4), tightness then DAC (5), randomly (6) or the opposite order if using a negative value.
\item [\sphinxhyphen{}solr]  
\sphinxAtStartPar
solution\sphinxhyphen{}based phase saving (reuse last found solution as preferred value assignment in the value ordering heuristic) (default option).
\item [\sphinxhyphen{}vacint]  
\sphinxAtStartPar
VAC\sphinxhyphen{}integrality/Full\sphinxhyphen{}EAC variable ordering heuristic (can be combined with option \sphinxhyphen{}A)
\end{optionlist}


\section{Diverse solutions}
\label{\detokenize{userdoc:diverse-solutions}}
\sphinxAtStartPar
toulbar2 can search for a greedy sequence of diverse solutions with guaranteed local optimality and minimum pairwise Hamming distance \sphinxcite{userdoc:ruffini2019a}.
\begin{description}
\sphinxlineitem{\sphinxhyphen{}div={[}integer{]}}
\sphinxAtStartPar
minimum Hamming distance between diverse solutions (use in conjunction
with \sphinxhyphen{}a=integer with a limit of 1000 solutions) (default value is 0)

\sphinxlineitem{\sphinxhyphen{}divm={[}integer{]}}
\sphinxAtStartPar
diversity encoding method (0:Dual, 1:Hidden, 2:Ternary, 3:Knapsack)
(default value is 3)

\sphinxlineitem{\sphinxhyphen{}mdd={[}integer{]}}
\sphinxAtStartPar
maximum relaxed MDD width for diverse solution global constraint
(default value is 0)

\sphinxlineitem{\sphinxhyphen{}mddh={[}integer{]}}
\sphinxAtStartPar
MDD relaxation heuristic: 0: random, 1: high div, 2: small div,
3: high unary costs (default value is 0)

\end{description}


\section{Console output}
\label{\detokenize{userdoc:console-output}}\begin{optionlist}{3cm}
\item [\sphinxhyphen{}help]  
\sphinxAtStartPar
shows the default help message that toulbar2 prints when
it gets no argument.
\end{optionlist}
\begin{description}
\sphinxlineitem{\sphinxhyphen{}v={[}integer{]}}
\sphinxAtStartPar
sets the verbosity level (default 0).

\sphinxlineitem{\sphinxhyphen{}Z={[}integer{]}}
\sphinxAtStartPar
debug mode (save problem at each node if verbosity
option \sphinxhyphen{}v=num \(>= 1\) and \sphinxhyphen{}Z=num \(>=3\))

\sphinxlineitem{\sphinxhyphen{}s={[}integer{]}}
\sphinxAtStartPar
shows each solution found during search. The solution is
printed on one line, giving by default (\sphinxhyphen{}s=1) the value (integer)
of each variable successively
in increasing file order. For \sphinxhyphen{}s=2, the value name is used instead,
and for \sphinxhyphen{}s=3, variable name=value name is printed instead.

\end{description}


\section{File output}
\label{\detokenize{userdoc:file-output}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}w={[}filename{]}}
\sphinxAtStartPar
writes last/all solutions found in the specified
filename (or “sol” if no parameter is given). The current directory
is used as a relative path.

\sphinxlineitem{\sphinxhyphen{}w={[}integer{]}}
\sphinxAtStartPar
1: writes value numbers, 2: writes value names, 3: writes also variable names (default value is 1, this option can be used in combination with \sphinxhyphen{}w=filename).

\sphinxlineitem{\sphinxhyphen{}z={[}filename{]}}
\sphinxAtStartPar
saves problem in wcsp or cfn format in filename (or
“problem.wcsp”/”problem.cfn” if no parameter is given) writes also
the graphviz dot file and the degree distribution of the input problem

\sphinxlineitem{\sphinxhyphen{}z={[}integer{]}}
\sphinxAtStartPar
1 or 3: saves original instance in 1\sphinxhyphen{}wcsp or 3\sphinxhyphen{}cfn format
(1 by default), 2 or 4: saves
after preprocessing in 2\sphinxhyphen{}wcsp or 4\sphinxhyphen{}cfn format (this option can be
used in combination with \sphinxhyphen{}z=filename)

\sphinxlineitem{\sphinxhyphen{}x={[}(,i{[}\(=\#<>\){]}a)*{]}}
\sphinxAtStartPar
performs an elementary operation (’\(=\)’:assign, ‘\(\#\)’:remove, ‘\(<\)’:decrease, ‘\(>\)’:increase) with value a on variable of index i (multiple
operations are separated by a comma and no space) (without any
argument, a complete assignment \textendash{} used as initial upper bound and
as value heuristic \textendash{} read from default file “sol” or given as input
filename with “.sol” extension)

\end{description}


\section{Probability representation and numerical control}
\label{\detokenize{userdoc:probability-representation-and-numerical-control}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}precision={[}integer{]}}
\sphinxAtStartPar
probability/real precision is a conversion
factor (a power of ten) for representing fixed point numbers
(default value is 7)

\sphinxlineitem{\sphinxhyphen{}epsilon={[}float{]}}
\sphinxAtStartPar
approximation factor for computing the partition
function (greater than 1, default value is infinity)

\end{description}


\section{Random problem generation}
\label{\detokenize{userdoc:random-problem-generation}}\begin{description}
\sphinxlineitem{\sphinxhyphen{}random={[}bench profile{]}}
\sphinxAtStartPar
bench profile must be specified as follows.
\begin{itemize}
\item {} 
\sphinxAtStartPar
n and d are respectively the number of variable and the
maximum domain size of the random problem.

\sphinxAtStartPar
bin\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
t1 is the tightness in percentage \% of random binary cost
functions

\item {} 
\sphinxAtStartPar
p2 is the number of binary cost functions to include

\item {} 
\sphinxAtStartPar
the seed parameter is optional

\end{itemize}

\sphinxAtStartPar
binsub\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}\sphinxhyphen{}\{seed\} binary random \& submodular
cost functions
\begin{itemize}
\item {} 
\sphinxAtStartPar
t1 is the tightness in percentage \% of random cost functions

\item {} 
\sphinxAtStartPar
p2 is the number of binary cost functions to include

\item {} 
\sphinxAtStartPar
p3 is the percentage \% of submodular cost functions among p2
cost functions
(plus 10 permutations of two randomly\sphinxhyphen{}chosen values for each
domain)

\end{itemize}

\sphinxAtStartPar
tern\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
p3 is the number of ternary cost functions

\end{itemize}

\sphinxAtStartPar
nary\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}…\sphinxhyphen{}\{pn\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
pn is the number of n\sphinxhyphen{}ary cost functions

\end{itemize}

\sphinxAtStartPar
salldiff\sphinxhyphen{}\{n\}\sphinxhyphen{}\{d\}\sphinxhyphen{}\{t1\}\sphinxhyphen{}\{p2\}\sphinxhyphen{}\{p3\}…\sphinxhyphen{}\{pn\}\sphinxhyphen{}\{seed\}
\begin{itemize}
\item {} 
\sphinxAtStartPar
pn is the number of salldiff global cost functions (p2 and
p3 still being used for the number of random binary and
ternary cost functions). \sphinxstyleemphasis{salldiff} can be replaced by
\sphinxstyleemphasis{gcc} or \sphinxstyleemphasis{regular} keywords with three possible forms
(\sphinxstyleemphasis{e.g., sgcc, sgccdp, wgcc}) and by \sphinxstyleemphasis{knapsack}.

\end{itemize}

\end{itemize}

\end{description}


\chapter{Input formats}
\label{\detokenize{userdoc:input-formats}}\label{\detokenize{userdoc:id56}}

\section{Introduction}
\label{\detokenize{userdoc:introduction}}
\sphinxAtStartPar
The available \sphinxstylestrong{file formats} (possibly compressed by gzip or bzip2 or xz, e.g., .cfn.gz, .wcsp.xz, .opb.bz2) are :
\begin{itemize}
\item {} 
\sphinxAtStartPar
Cost Function Network format ({\hyperref[\detokenize{formats/cfnformat:cfn-format}]{\sphinxcrossref{\DUrole{std,std-ref}{.cfn}}}} file extension)

\item {} 
\sphinxAtStartPar
Weighted Constraint Satisfaction Problem ({\hyperref[\detokenize{formats/wcspformat:wcsp-format}]{\sphinxcrossref{\DUrole{std,std-ref}{.wcsp}}}} file extension)

\item {} 
\sphinxAtStartPar
Probabilistic Graphical Model (\sphinxhref{http://www.cs.huji.ac.il/project/PASCAL/fileFormat.php}{.uai} / .LG file extension ; the file format .LG is identical to .UAI except that we expect log\sphinxhyphen{}potentials)

\item {} 
\sphinxAtStartPar
Weigthed Partial Max\sphinxhyphen{}SAT (\sphinxhref{http://www.maxsat.udl.cat/08/index.php?disp=requirements}{.cnf/.wcnf} file extension)

\item {} 
\sphinxAtStartPar
Quadratic Unconstrained Pseudo\sphinxhyphen{}Boolean Optimization ({\hyperref[\detokenize{formats/qpboformat:qpbo-format}]{\sphinxcrossref{\DUrole{std,std-ref}{.qpbo}}}} file extension)

\item {} 
\sphinxAtStartPar
Pseudo\sphinxhyphen{}Boolean Optimization (\sphinxhref{http://www.cril.univ-artois.fr/PB16/format.pdf}{.opb} file extension)

\item {} 
\sphinxAtStartPar
Constraint Satisfaction and Optimization Problem (\sphinxhref{https://xcsp.org}{.xml} file extension)

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Some examples} :
\begin{itemize}
\item {} 
\sphinxAtStartPar
A simple 2 variables maximization problem \sphinxhref{https://github.com/toulbar2/toulbar2/raw/master/validation/default/maximization.cfn}{maximization.cfn} in JSON\sphinxhyphen{}compatible CFN format, with decimal positive and negative costs.

\item {} 
\sphinxAtStartPar
Random binary cost function network \sphinxcode{\sphinxupquote{example.wcsp}}, with a specific variable ordering \sphinxcode{\sphinxupquote{example.order}}, a tree decomposition \sphinxcode{\sphinxupquote{example.cov}}, and a cluster decomposition \sphinxcode{\sphinxupquote{example.dec}}

\item {} 
\sphinxAtStartPar
Latin square 4x4 with random costs on each variable \sphinxcode{\sphinxupquote{latin4.wcsp}}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/schiex/Doc/Export/CELAR.ps.gz}{Radio link frequency assignment CELAR} instances \sphinxcode{\sphinxupquote{scen06.wcsp}}, \sphinxcode{\sphinxupquote{scen06.cov}}, \sphinxcode{\sphinxupquote{scen06.dec}}, \sphinxcode{\sphinxupquote{scen07.wcsp}}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library/-/raw/master/real/spot5/BensanaLemaitreVerfaillieConstraints1999.pdf}{Earth observation satellite management SPOT5} instances \sphinxcode{\sphinxupquote{404.wcsp}} and \sphinxcode{\sphinxupquote{505.wcsp}} with associated tree/cluster decompositions \sphinxcode{\sphinxupquote{404.cov}}, \sphinxcode{\sphinxupquote{505.cov}}, \sphinxcode{\sphinxupquote{404.dec}}, \sphinxcode{\sphinxupquote{505.dec}}

\item {} 
\sphinxAtStartPar
Linkage analysis instance \sphinxcode{\sphinxupquote{pedigree9.uai}}

\item {} 
\sphinxAtStartPar
Computer vision superpixel\sphinxhyphen{}based image segmentation instance \sphinxcode{\sphinxupquote{GeomSurf\sphinxhyphen{}7\sphinxhyphen{}gm256.uai}}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://miat.inrae.fr/degivry/Schiex14a.pdf}{Protein folding} instance \sphinxcode{\sphinxupquote{1CM1.uai}}

\item {} 
\sphinxAtStartPar
Max\sphinxhyphen{}clique DIMACS instance \sphinxcode{\sphinxupquote{brock200\_4.clq.wcnf}}

\item {} 
\sphinxAtStartPar
Graph 6\sphinxhyphen{}coloring instance \sphinxcode{\sphinxupquote{GEOM40\_6.wcsp}}

\item {} 
\sphinxAtStartPar
Many more instances available \sphinxhref{http://genoweb.toulouse.inra.fr/~degivry/evalgm}{evalgm} and  \sphinxhref{https://forgemia.inra.fr/thomas.schiex/cost-function-library}{Cost Function Library}.

\end{itemize}

\sphinxAtStartPar
Notice that by default toulbar2 distinguishes file formats based on their extension.
It is possible to read a file from a unix pipe using option \sphinxcode{\sphinxupquote{\sphinxhyphen{}stdin={[}format{]}}}; \sphinxstyleemphasis{e.g.}, \sphinxcode{\sphinxupquote{cat example.wcsp | toulbar2 \sphinxhyphen{}\sphinxhyphen{}stdin=wcsp}}

\sphinxAtStartPar
It is also possible to read and combine multiple problem files (warning, they must be all in the same format, either wcsp, cfn, or xml).
Variables with the same name are merged (domains must be identical), otherwise the merge is based on variable indexes (wcsp format).


\section{Formats details}
\label{\detokenize{userdoc:formats-details}}
\sphinxstepscope


\subsection{CFN format (.cfn suffix)}
\label{\detokenize{formats/cfnformat:cfn-format-cfn-suffix}}\label{\detokenize{formats/cfnformat:cfn-format}}\label{\detokenize{formats/cfnformat::doc}}
\sphinxAtStartPar
With this JSON compatible format, it is possible:
\begin{itemize}
\item {} 
\sphinxAtStartPar
to give a name to variables and functions.

\item {} 
\sphinxAtStartPar
to associate a local label to every value that is accessible inside toulbar2 (among others for heuristics design purposes).

\item {} 
\sphinxAtStartPar
to use decimal and possibly negative costs.

\item {} 
\sphinxAtStartPar
to solve both minimization and maximization problems.

\item {} 
\sphinxAtStartPar
to debug your \sphinxstylestrong{.cfn} files: the parser gives a cause and line number when it fails.

\item {} 
\sphinxAtStartPar
to use gzip’d or xz compressed files directly as input (.cfn.gz and .cfn.xz).

\item {} 
\sphinxAtStartPar
to use dense descriptions for dense cost tables.

\end{itemize}

\sphinxAtStartPar
In a \sphinxstylestrong{cfn} file, a Cost Function Network is described as a JSON object with extra freedom and extra constraints.

\sphinxAtStartPar
Freedom:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the double quotes around strings are not compulsory: both \sphinxcode{\sphinxupquote{"problem"}} and \sphinxcode{\sphinxupquote{problem}} are strings.

\item {} 
\sphinxAtStartPar
double quotes can also be added around numbers: both \sphinxcode{\sphinxupquote{1.20}} and \sphinxcode{\sphinxupquote{"1.20"}} will be interpreted as decimal numbers.

\item {} 
\sphinxAtStartPar
the commas that separates the fields inside an array or object are not compulsory. Any separator will do (comma, white space). So \sphinxcode{\sphinxupquote{{[}1, 2{]}}} or \sphinxcode{\sphinxupquote{{[}1,2{]}}} or \sphinxcode{\sphinxupquote{{[}1 2{]}}} are all describing the same array.

\item {} 
\sphinxAtStartPar
the delimiters for objects and arrays (\sphinxcode{\sphinxupquote{\{\}}} and \sphinxcode{\sphinxupquote{{[}{]}}}) can be used arbitrarily for both types of items.

\item {} 
\sphinxAtStartPar
the colon (\sphinxcode{\sphinxupquote{:}}) that separates the name of a field in an object from the contents of the field is not compulsory.

\item {} 
\sphinxAtStartPar
It is possible to comment a line with a \sphinxcode{\sphinxupquote{\#}} the first position of a line.

\end{itemize}

\sphinxAtStartPar
Constraints:
\begin{itemize}
\item {} 
\sphinxAtStartPar
strings should not start with a character in \sphinxcode{\sphinxupquote{0123456789\sphinxhyphen{}.+}} and cannot contain \sphinxcode{\sphinxupquote{/\#{[}{]}\{\}}} or a space character (tabs…).

\item {} 
\sphinxAtStartPar
numbers can only be integers or decimals. No scientific notation.

\item {} 
\sphinxAtStartPar
the orders of fields inside an object is compulsory and cannot be changed.

\end{itemize}

\sphinxAtStartPar
A CFN is an object with 3 data: a definition of the main problem properties (tag \sphinxcode{\sphinxupquote{problem}}), of variables and their domains (tag \sphinxcode{\sphinxupquote{variables}}) and of cost functions (tag \sphinxcode{\sphinxupquote{functions}}), in this order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{problem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{problem} \PYG{n}{properties}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{variables}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{variables} \PYG{o+ow}{and} \PYG{n}{domains}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{functions}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{functions} \PYG{n}{descriptions}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Problem properties:}

\sphinxAtStartPar
An object with two fields:
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"name"}} : the name of the problem.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"mustbe"}} : specifies the direction of optimization and a global (upper/lower) bound on the objective. This is the concatenation of a comparator (\sphinxcode{\sphinxupquote{\textgreater{}}} or \sphinxcode{\sphinxupquote{\textless{}}}) immediately followed by a decimal number, described as a string. The comparator specifies the direction of optimization:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}"}}: we are minimizing and the decimal indicates a global upper bound (all costs equal to or larger than this are considered as unfeasible).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}"}}: we are maximizing and and the decimal indicates a global lower bound (all costs equal to or less than this are considered as unfeasible).

\end{itemize}

\sphinxAtStartPar
The number of significant digits in the decimal number gives the precision that will be used for all cost computations inside toulbar2.

\sphinxAtStartPar
An an example, \sphinxcode{\sphinxupquote{"mustbe": "\textless{}10.00"}} means that the CFN describes a function where all costs larger than or equal to 10.00 are considered as infinite. All costs will also be handled with 2 digits of precision after the decimal point.
\end{quote}

\sphinxAtStartPar
The two fields must appear in this order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}problem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustbe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}\PYGZhy{}12.100}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{test}\PYG{o}{.}\PYG{n}{problem} \PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{12.100}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
in a more concise non JSON\sphinxhyphen{}compatible form.

\sphinxAtStartPar
\sphinxstylestrong{Variables and domains:}

\sphinxAtStartPar
An object with as many fields as variables. All fields must have different names. The contents of a variable field can be an array or an integer. An array gives the sequence of values (defined by their name) of the variable domain. An integer gives the domain cardinality, without naming values (values are represented by their position in the domain, starting at 0). If a negative domain size is given, the variable is an interval variable instead of a finite domain variable and it has domain {[}0,\sphinxhyphen{}domainsize\sphinxhyphen{}1{]}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iv1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
defines 3 variables, two finite domain variables and 1 interval variable. The first domain variable has 3 values, \sphinxcode{\sphinxupquote{"a"}} \sphinxcode{\sphinxupquote{"b"}} and \sphinxcode{\sphinxupquote{"c"}}. the second has two anonymous values and the interval variable has domain {[}0,99{]}.

\sphinxAtStartPar
As an extra freedom, it is possible to give no name to variables. This can be achieved using an array instead of an object. The example above can therefore be written:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{n}{a} \PYG{n}{b} \PYG{n}{c}\PYG{p}{]} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
or even just

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
in a dense non JSON\sphinxhyphen{}compatible format.

\sphinxAtStartPar
\sphinxstylestrong{Functions:}

\sphinxAtStartPar
An object with as many fields as functions. Every function is an object with different possible fields. All functions have a \sphinxcode{\sphinxupquote{scope}} which is an array of variables (names or indices). The rest of the fields depends on the type of the cost function: table cost function or global (including arithmetic functions).

\sphinxAtStartPar
\sphinxstylestrong{Table cost functions:}

\sphinxAtStartPar
Sparse functions format:* useful for functions that are dominantly constant. A numerical \sphinxcode{\sphinxupquote{defaultcost}} must be given after the scope. The \sphinxcode{\sphinxupquote{costs}} table must be an array of tuple.costs: a sequence of value names or indices followed by a numeric cost. The \sphinxcode{\sphinxupquote{defaultcost}} is used to define the cost of any missing tuple.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{defaultcost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.234}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{6.2}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.21}\PYG{p}{]} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
is a possible sparse function definition. Here only 3 tuples are defined with their costs. All 3 remaining tuples will have cost \sphinxcode{\sphinxupquote{0.234}}.

\sphinxAtStartPar
\sphinxstyleemphasis{Dense function format:} if the \sphinxcode{\sphinxupquote{defaultcost}} tag is absent, a complete lexicographically ordered list of costs is expected instead.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{4.2}\PYG{p}{,} \PYG{l+m+mf}{3.67}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+m+mf}{7.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.1}\PYG{p}{,} \PYG{l+m+mf}{100.2}\PYG{p}{]} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
describes the 6 costs of the 6 tuples insides the cartesian product of the two variables \sphinxcode{\sphinxupquote{"fdv1"}} and \sphinxcode{\sphinxupquote{"fdv2"}}. To assign costs to tuples, all possible tuples of the cartesian product are lexicographically ordered using the declared value order in the domain of each variable.  In the example above, the order over the six pairs will be \sphinxcode{\sphinxupquote{("a",0) ("a",1) ("b",0) ("b",1) ("c",0) ("c",1)}} that will be associated to the costs \sphinxcode{\sphinxupquote{4.2, 3.67, \sphinxhyphen{}12.1, 7.1, \sphinxhyphen{}3.1}} and \sphinxcode{\sphinxupquote{100.2}} in this order. This lexicographic ordering is used for all arities.

\sphinxAtStartPar
\sphinxstyleemphasis{Shared function format:} If instead of an array, a string is given for the cost table, then this string must be the name of a yet undefined function. The actual function will have the same cost table as the future indicated function (on the specified scope). The domain sizes of the two functions must match.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f12}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
defines a function on variables \sphinxcode{\sphinxupquote{v1}} and \sphinxcode{\sphinxupquote{v3}} that will have the same cost table as the function i:code:\sphinxtitleref{f12} that must be defined later in the file.

\sphinxAtStartPar
\sphinxstylestrong{Global and arithmetic cost functions}

\sphinxAtStartPar
These functions are defined by a \sphinxcode{\sphinxupquote{scope}}, a \sphinxcode{\sphinxupquote{type}} and \sphinxcode{\sphinxupquote{parameters}}. The \sphinxcode{\sphinxupquote{type}} is a string that defines the specific function to use, the \sphinxcode{\sphinxupquote{parameters}} is an array of objects. The composition of the \sphinxcode{\sphinxupquote{parameters}} depends on the \sphinxcode{\sphinxupquote{type}} of the function.

\sphinxAtStartPar
At this point, in maximization mode, most of the global cost functions have restricted usage (with the exception of wregular).

\sphinxAtStartPar
\sphinxstyleemphasis{Arithmetic functions:}

\sphinxAtStartPar
These functions have all arity 2 and it is assumed here that these variables are called x and y . The values are considered as representing their index in the domain and are therefore integer. The \sphinxcode{\sphinxupquote{type}} can be either:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}="}} : with \sphinxcode{\sphinxupquote{parameters}} array \([ cst , \delta ]\)
where \(cst\) and \(\delta\) are two costs, to express cost
function \(max(0, y + cst - x \leq \delta ? y + cst - x : upperbound)\). This is a soft inequality with hard threshold \(\delta\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}"}}: similar with a strict inequality and semantics
\(max(0, y + 1 + cst - x \leq \delta ? y + 1 + cst - x : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}="}}: similar with an inverted inequality and semantics:
\(max(0, x - cst - y \leq \delta ? x - cst - y : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}"}}: similar with a strict inequality and semantics
\(max(0, x - cst + 1 - y \leq \delta ? x - cst + 1 - y : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"="}}: similar with an equality and semantics: similar with a strict
inequality and semantics
\(\left| y + cst - x \right| \leq \delta ? \left|y + cst - x \right| : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"disj"}}: takes a \sphinxcode{\sphinxupquote{parameters}} array \([ cstx, csty, w]\)
to express soft binary disjunctive cost function with semantics \(( (x \geq y + csty) \lor ( y \geq x + cstx)) ? 0 : w)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sdisj"}}: takes a \sphinxcode{\sphinxupquote{parameters}} array \([ cstx, csty, xmax, ymax wx wy]\) to express a special disjunctive cost function with three implicit constraints \(x \leq xmax\), \(y \leq ymax\) and \(( x < xmax \land y < ymax) \Rightarrow ( x \geq y + csty \lor  y \geq x + cstx)\) and an additional cost function \(( (x = xmax) ? wx : 0) + ( (y = y max? wy : 0)\).

\end{itemize}

\sphinxAtStartPar
example : arithmetic function with \sphinxcode{\sphinxupquote{\textgreater{}=}} operator :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arith0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Global cost functions:}

\sphinxAtStartPar
We use an informal syntactical description of each global cost function below. the \sphinxcode{\sphinxupquote{"|"}} is used for alternative keywords and parentheses together with \sphinxcode{\sphinxupquote{?}}, \sphinxcode{\sphinxupquote{*}} and \sphinxcode{\sphinxupquote{+}} to denote optional or repeated groups of items (+ requires that at least one repetition exists). For more details on
semantics and implementation, see:
\begin{quote}

\sphinxAtStartPar
1. Lee, J. H. M., \& Leung, K. L. (2012). Consistency techniques for flow\sphinxhyphen{}based projection\sphinxhyphen{}safe global cost functions in weighted constraint satisfaction. \sphinxstyleemphasis{Journal of Artificial Intelligence Research}, 43, 257\sphinxhyphen{}292.
\sphinxstyleemphasis{Artificial Intelligence}, 238, 166\sphinxhyphen{}189. 2. Allouche, D., Bessiere, C., Boizumault, P., De Givry, S., Gutierrez, P., Lee, J. H., … \& Wu, Y. (2016). Tractability\sphinxhyphen{}preserving transformations of global cost functions. \sphinxstyleemphasis{Artificial Intelligence}, 238, 166\sphinxhyphen{}189.
\end{quote}

\sphinxAtStartPar
Using a flow\sphinxhyphen{}based propagator:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salldiff"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"dec"|"decbi" cost: cost{]}}} expresses a soft alldifferent with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{dec}} and \sphinxcode{\sphinxupquote{decbi}} keywords) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation (\sphinxcode{\sphinxupquote{decbi}} decomposes into a complete binary cost function network).
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{salldiff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.7}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
generates a cost of 0.7 per variable assignment that needs to be
changed for all variables to take a different value.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgcc"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric:"var"|"dec"|"wdec" cost: cost bounds: {[}{[}value lower\_bound upper\_bound (shortage\_weight excess\_weight)?{]}*{]}}} expresses a soft global cardinality constraint with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{dec}} keyword) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation and for each value its \sphinxcode{\sphinxupquote{lower}} and \sphinxcode{\sphinxupquote{upper}} bound (\sphinxcode{\sphinxupquote{value shortage}} and \sphinxcode{\sphinxupquote{excess weights}} penalties must be given iff \sphinxcode{\sphinxupquote{wdec}} is used).
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{sgcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{wdec}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.5}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.2}\PYG{p}{]}
                   \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"ssame"}} with parameters array \sphinxcode{\sphinxupquote{{[}cost: cost vars1: {[}(variable)*{]} vars2: {[}(variable)*{]}{]}}} to express a permutation constraint on two lists of variables of equal size with implicit variable\sphinxhyphen{}based cost semantic
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{ssame}
       \PYG{n}{params} \PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{6.2}
          \PYG{n}{vars1} \PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2}\PYG{p}{]}
          \PYG{n}{vars2} \PYG{p}{:} \PYG{p}{[}\PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sregular"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"edit" cost: cost starts: {[}(state)*{]} ends: {[}(state)*{]} transitions: {[}(start\sphinxhyphen{}state symbol\_value end\_state)*{]}}} to express a soft regular constraint with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or edit distance\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{edit}} keyword) cost semantics with a given \sphinxcode{\sphinxupquote{cost}} per violation followed by the definition of a deterministic finite automaton with arrays of initial and final states, and an array of state transitions where symbols are domain values indices.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{sregular}
       \PYG{n}{params} \PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n}{nb\PYGZus{}states}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{starts}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{n}{ends}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}
          \PYG{n}{transitions}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Global cost functions using a dynamic programming DAG\sphinxhyphen{}based propagator:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sregulardp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost nb\_states: nb\_states starts: {[}(state)*{]} ends: {[}(state)*{]} transitions: {[}(start\_state value\_index end\_state)*{]}}} to express a soft regular constraint with a variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation followed by the definition of a deterministic finite automaton with arrays of initial and final states, and an array of state transitions where symbols are domain value indices.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example: see sregular above.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgrammar"|"sgrammardp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"weight" cost: cost nb\_symbols: nb\_symbols nb\_values: nb\_values start: start\_symbol terminals: {[}(terminal\_symbol value (cost)?)*{]} non\_terminals: {[}(nonterminal\_in nonterminal\_out\_left nonterminal\_out\_right (cost)?)*{]}}} to express a soft/weighted grammar in Chomsky normal form. The costs inside the rules and terminals should be used only with the \sphinxcode{\sphinxupquote{weight}} metric.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{sgrammardp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric} \PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{1.012}
          \PYG{n}{nb\PYGZus{}symbols} \PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{n}{nb\PYGZus{}values} \PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{start} \PYG{p}{:} \PYG{l+m+mi}{0}
          \PYG{n}{terminals} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{non\PYGZus{}terminals} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"samong"|"samongdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost min: lower\_bound max: upper\_bound values: {[}(value)*{]}{]}}} to express a soft among constraint to restrict the number of variables taking their value into a given set of value indices
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{samong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric} \PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"salldiffdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost{]}}} to express a soft alldifferent constraint with variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{"var"}} keyword) cost semantic with a given cost per violation (decomposes into \sphinxcode{\sphinxupquote{samongdp}} cost functions)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{salldiffdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.7}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgccdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: "cost" bounds: {[}(value lower\_bound upper\_bound)*{]}{]}}} to express a soft global cardinality constraint with variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{"var"}} keyword) cost semantic with a given cost per violation and for each value its lower and upper bound (decomposes into \sphinxcode{\sphinxupquote{samongdp}} cost functions)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{sgccdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.1}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"max|smaxdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}defaultcost: defcost tuples: {[}(variable value cost)*{]}{]}}} to express a weighted max cost function to find the maximum cost over a set of unary cost functions associated to a set of variables (by default, \sphinxcode{\sphinxupquote{defCost}} if unspecified)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{smaxdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{defaultcost}\PYG{p}{:} \PYG{l+m+mi}{3}
          \PYG{n}{tuples}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"MST"|"smstdp"}} with empty parameters expresses a hard spanning tree constraint where each variable is assigned to its parent variable index in order to build a spanning tree (the root being assigned to itself)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
        \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{MST} \PYG{n}{params}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Global cost functions using a cost function network\sphinxhyphen{}based propagator (decompose to bounded arity table cost functions):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wregular"}} with parameters \sphinxcode{\sphinxupquote{nb\_states: nbstates starts: {[}{[}state cost{]}*{]} ends: {[}{[}state cost{]}*{]} transitions: {[}{[}state value\_index state cost{]}*{]}}} to express a weighted regular constraint with weights on initial states, final states, and transitions, followed by the definition of a deterministic finite automaton with number of states, list of initial and final states with their costs, and list of weighted state transitions where symbols are domain value indices
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v4} \PYG{n}{v3}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wregular}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{nb\PYGZus{}states}\PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{n}{starts} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{ends} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{transitions} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.0}\PYG{p}{]}
                         \PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"walldiff"}} with parameters array \sphinxcode{\sphinxupquote{{[}hard|lin|quad{]}}} cost to express a soft alldifferent constraint as a set of wamong hard constraint (\sphinxcode{\sphinxupquote{hard}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{lin}} and \sphinxcode{\sphinxupquote{quad}} keywords) cost semantic with a given cost per violation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{walldiff}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.8}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wgcc"}} with parameters metric: \sphinxcode{\sphinxupquote{hard|lin|quad cost: cost bounds: {[}{[}value lower\_bound upper\_bound{]}*{]}}} to express a soft global cardinality constraint as either a hard constraint (\sphinxcode{\sphinxupquote{hard}} keyword) or with decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{lin}} and \sphinxcode{\sphinxupquote{quad}} keyword) cost semantic with a given cost per violation and for each value its lower and upper bound
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wgcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsame"}} with parameters a \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost}} to express a permutation constraint on two lists of variables of equal size (implicitly concatenated in the scope) using implicit decomposition\sphinxhyphen{}based cost semantic
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
        \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wsame}
        \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
           \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
           \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
           \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsamegcc"}} with parameters array \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost bounds: {[}{[}value lower\_bound upper\_bound{]}*{]}}} to express the combination of a soft global cardinality constraint and a permutation constraint.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wsamegcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wamong"}} with parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost values: {[}(value)*{]} min: lower\_bound max: upper\_bound}} to express a soft among constraint to restrict the number of variables taking their value into a given set of values.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wamong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wvaramong"}} with parameters array \sphinxcode{\sphinxupquote{metric: hard cost: cost values: {[}(value)*{]}}} to express a hard among constraint to restrict the number of variables taking their value into a given set of values to be equal to the last variable in the scope.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4} \PYG{n}{v5}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wvaramong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{12.0}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"woverlap"}} with parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost comparator: comparator to: righthandside{]}}} overlaps between two sequences of variables X, Y (i.e. set the fact that Xi and Yi take the same value (not equal to zero))
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{woverlap}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{2.01}\PYG{n}{comparator}\PYG{p}{:} \PYG{o}{\PYGZgt{}}
          \PYG{n}{to}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsum"}} parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost comparator: comparator to: righthandside}} to express a soft sum constraint with unit coefficients to test if the sum of a set of variables matches with a given comparator and right\sphinxhyphen{}hand\sphinxhyphen{}side value.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wsum}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{quad}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n}{comparator}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}=}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{n}{to}\PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wvarsum"}} with parameters \sphinxcode{\sphinxupquote{metric: hard cost: cost comparator: comparator}} to express a hard sum constraint to restrict the sum to be comparator to the value of the last variable in the scope.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mywsum}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
         \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wvarsum}
         \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
            \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
            \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mi}{3}
            \PYG{n}{comparator}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{==}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
Comparators: let us note \textless{}\textgreater{} the comparator, K the right\sphinxhyphen{}hand\sphinxhyphen{}side (to:) value associated to the comparator, and Sum the result of the sum over the variables. For each comparator, the gap is defined according to the distance as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is == : gap = abs(K \sphinxhyphen{} Sum)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{}= : gap = max(0,Sum \sphinxhyphen{} K)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{} : gap = max(0,Sum \sphinxhyphen{} K \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is != : gap = 1 if Sum != K and gap = 0 otherwise

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{} : gap = max(0,K \sphinxhyphen{} Sum + 1);

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{}= : gap = max(0,K \sphinxhyphen{} Sum);

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Warning: the decomposition of \sphinxcode{\sphinxupquote{wsum}} and \sphinxcode{\sphinxupquote{wvarsum}} may use an exponential size (sum of domain sizes). list\_size1 and list\_size2 must be equal in \sphinxcode{\sphinxupquote{ssame}}.

\sphinxstepscope


\subsection{Weighted Constraint Satisfaction Problem file format (wcsp)}
\label{\detokenize{formats/wcspformat:weighted-constraint-satisfaction-problem-file-format-wcsp}}\label{\detokenize{formats/wcspformat:wcsp-format}}\label{\detokenize{formats/wcspformat::doc}}

\begin{fulllineitems}

\pysigstartsignatures
\pysigline{\phantomsection\label{\detokenize{formats/wcspformat:group__wcspformat}}\sphinxstyleemphasis{group} \sphinxbfcode{\sphinxupquote{wcspformat}}}
\pysigstopsignatures
\sphinxAtStartPar
It is a text format composed of a list of numerical and string terms separated by spaces. Instead of using names for making reference to variables, variable indexes are employed. The same for domain values. All indexes start at zero.

\sphinxAtStartPar
Cost functions can be defined in intention (see below) or in extension, by their list of tuples. A default cost value is defined per function in order to reduce the size of the list. Only tuples with a different cost value should be given (not mandatory). All the cost values must be positive. The arity of a cost function in extension may be equal to zero. In this case, there is no tuples and the default cost value is added to the cost of any solution. This can be used to represent a global lower bound constant of the problem.

\sphinxAtStartPar
The wcsp file format is composed of three parts: a problem header, the list of variable domain sizes, and the list of cost functions.

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Header definition for a given problem: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Problem} \PYG{n}{name}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{variables} \PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Maximum} \PYG{n}{domain} \PYG{n}{size}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{cost} \PYG{n}{functions}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Initial} \PYG{k}{global} \PYG{n}{upper} \PYG{n}{bound} \PYG{n}{of} \PYG{n}{the} \PYG{n}{problem} \PYG{p}{(}\PYG{n}{UB}\PYG{p}{)}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
 The goal is to find an assignment of all the variables with minimum total cost, strictly lower than UB. Tuples with a cost greater than or equal to UB are forbidden (hard constraint).

\item {} 
\sphinxAtStartPar
Definition of domain sizes 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Domain} \PYG{n}{size} \PYG{n}{of} \PYG{n}{variable} \PYG{k}{with} \PYG{n}{index} \PYG{l+m+mi}{0}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Domain} \PYG{n}{size} \PYG{n}{of} \PYG{n}{variable} \PYG{k}{with} \PYG{n}{index} \PYG{n}{N} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Note : domain values range from zero to \sphinxstyleemphasis{size\sphinxhyphen{}1} 

\sphinxAtStartPar
Note : a negative domain size is interpreted as a variable with an interval domain in \([0,-size-1]\)

\sphinxAtStartPar
Warning : variables with interval domains are restricted to arithmetic and disjunctive cost functions in intention (see below)

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
General definition of cost functions\begin{itemize}
\item {} 
\sphinxAtStartPar
Definition of a cost function in extension 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Arity} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Default} \PYG{n}{cost} \PYG{n}{value}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Number} \PYG{n}{of} \PYG{n}{tuples} \PYG{k}{with} \PYG{n}{a} \PYG{n}{cost} \PYG{n}{different} \PYG{n}{than} \PYG{n}{the} \PYG{n}{default} \PYG{n}{cost}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
 followed by for every tuple with a cost different than the default cost: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{value} \PYG{n}{assigned} \PYG{n}{to} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{value} \PYG{n}{assigned} \PYG{n}{to} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Cost} \PYG{n}{of} \PYG{n}{the} \PYG{n+nb}{tuple}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\end{itemize}


\sphinxAtStartPar
Note : Shared cost function: A cost function in extension can be shared by several cost functions with the same arity (and same domain sizes) but different scopes. In order to do that, the cost function to be shared must start by a negative scope size. Each shared cost function implicitly receives an occurrence number starting from 1 and incremented at each new shared definition. New cost functions in extension can reuse some previously defined shared cost functions in extension by using a negative number of tuples representing the occurrence number of the desired shared cost function. Note that default costs should be the same in the shared and new cost functions. Here is an example of 4 variables with domain size 4 and one AllDifferent hard constraint decomposed into 6 binary constraints.

\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shared CF used inside a small example in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AllDifferentDecomposedIntoBinaryConstraints} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{6} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
Definition of a cost function in intension by replacing the default cost value by \sphinxhyphen{}1 and by giving its keyword name and its K parameters 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Arity} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{first} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{Index} \PYG{n}{of} \PYG{n}{the} \PYG{n}{last} \PYG{n}{variable} \PYG{o+ow}{in} \PYG{n}{the} \PYG{n}{scope} \PYG{n}{of} \PYG{n}{the} \PYG{n}{cost} \PYG{n}{function}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{o}{\PYGZlt{}}\PYG{n}{keyword}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameter1}\PYG{o}{\PYGZgt{}}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{\PYGZlt{}}\PYG{n}{parameterK}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Possible keywords of cost functions defined in intension followed by their specific parameters:\begin{itemize}
\item {} 
\sphinxAtStartPar
\textgreater{}= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x \geq y + cst\) with associated cost function \(max( (y + cst - x \leq delta)?(y + cst - x):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textgreater{} \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x > y + cst\) with associated cost function \(max( (y + cst + 1 - x \leq delta)?(y + cst + 1 - x):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textless{}= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x \leq y + cst\) with associated cost function \(max( (x - cst - y \leq delta)?(x - cst - y):UB , 0 )\)

\item {} 
\sphinxAtStartPar
\textless{} \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x < y + cst\) with associated cost function \(max( (x - cst + 1 - y \leq delta)?(x - cst + 1 - y):UB , 0 )\)

\item {} 
\sphinxAtStartPar
= \sphinxstyleemphasis{cst} \sphinxstyleemphasis{delta} to express soft binary constraint \(x = y + cst\) with associated cost function \((|y + cst - x| \leq delta)?|y + cst - x|:UB\)

\item {} 
\sphinxAtStartPar
disj \sphinxstyleemphasis{cstx} \sphinxstyleemphasis{csty} \sphinxstyleemphasis{penalty} to express soft binary disjunctive constraint \(x \geq y + csty \vee y \geq x + cstx\) with associated cost function \((x \geq y + csty \vee y \geq x + cstx)?0:penalty\)

\item {} 
\sphinxAtStartPar
sdisj \sphinxstyleemphasis{cstx} \sphinxstyleemphasis{csty} \sphinxstyleemphasis{xinfty} \sphinxstyleemphasis{yinfty} \sphinxstyleemphasis{costx} \sphinxstyleemphasis{costy} to express a special disjunctive constraint with three implicit hard constraints \(x \leq xinfty\) and \(y \leq yinfty\) and \(x < xinfty \wedge y < yinfty \Rightarrow (x \geq y + csty \vee y \geq x + cstx)\) and an additional cost function \(((x = xinfty)?costx:0) + ((y= yinfty)?costy:0)\)

\item {} 
\sphinxAtStartPar
Global cost functions using a dedicated propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
clique \sphinxstyleemphasis{1} (\sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})*)* to express a hard clique cut to restrict the number of variables taking their value into a given set of values (per variable) to at most \sphinxstyleemphasis{1} occurrence for all the variables (warning! it assumes also a clique of binary constraints already exists to forbid any two variables using both the restricted values)

\item {} 
\sphinxAtStartPar
knapsack \sphinxstyleemphasis{capacity} (\sphinxstyleemphasis{weight})* to express a reverse knapsack constraint (i.e., a linear constraint on 0/1 variables with \textgreater{}= operator) with capacity and weights are positive or negative integer coefficients (use negative numbers to express a linear constraint with \textless{}= operator)

\item {} 
\sphinxAtStartPar
knapsackp \sphinxstyleemphasis{capacity} (\sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{weight})*)* to express a reverse knapsack constraint with for each variable the list of values to select the item in the knapsack with their corresponding weight

\end{itemize}


\item {} 
\sphinxAtStartPar
Global cost functions using a flow\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
salldiff var|dec|decbi \sphinxstyleemphasis{cost} to express a soft alldifferent constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{dec} and \sphinxstyleemphasis{decbi} keywords) cost semantic with a given \sphinxstyleemphasis{cost} per violation (\sphinxstyleemphasis{decbi} decomposes into a binary cost function complete network)

\item {} 
\sphinxAtStartPar
sgcc var|dec|wdec \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} (\sphinxstyleemphasis{shortage\_weight} \sphinxstyleemphasis{excess\_weight})?)* to express a soft global cardinality constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{dec} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound (if \sphinxstyleemphasis{wdec} then violation cost depends on each value shortage or excess weights)

\item {} 
\sphinxAtStartPar
ssame \sphinxstyleemphasis{cost} \sphinxstyleemphasis{list\_size1} \sphinxstyleemphasis{list\_size2} (\sphinxstyleemphasis{variable\_index})* (\sphinxstyleemphasis{variable\_index})* to express a permutation constraint on two lists of variables of equal size (implicit variable\sphinxhyphen{}based cost semantic)

\item {} 
\sphinxAtStartPar
sregular var|edit \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state})* to express a soft regular constraint with either variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) or edit distance\sphinxhyphen{}based (\sphinxstyleemphasis{edit} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation followed by the definition of a deterministic finite automaton with number of states, list of initial and final states, and list of state transitions where symbols are domain values

\end{itemize}


\end{itemize}


\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Global cost functions using a dynamic programming DAG\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
sregulardp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state})* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state})* to express a soft regular constraint with a variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation followed by the definition of a deterministic finite automaton with number of states, list of initial and final states, and list of state transitions where symbols are domain values

\item {} 
\sphinxAtStartPar
sgrammar|sgrammardp var|weight \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_symbols} \sphinxstyleemphasis{nb\_values} \sphinxstyleemphasis{start\_symbol} \sphinxstyleemphasis{nb\_rules} ((0 \sphinxstyleemphasis{terminal\_symbol} \sphinxstyleemphasis{value})|(1 \sphinxstyleemphasis{nonterminal\_in} \sphinxstyleemphasis{nonterminal\_out\_left} \sphinxstyleemphasis{nonterminal\_out\_right})|(2 \sphinxstyleemphasis{terminal\_symbol} \sphinxstyleemphasis{value} \sphinxstyleemphasis{weight})|(3 \sphinxstyleemphasis{nonterminal\_in} \sphinxstyleemphasis{nonterminal\_out\_left} \sphinxstyleemphasis{nonterminal\_out\_right} \sphinxstyleemphasis{weight}))* to express a soft/weighted grammar in Chomsky normal form

\item {} 
\sphinxAtStartPar
samong|samongdp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* to express a soft among constraint to restrict the number of variables taking their value into a given set of values

\item {} 
\sphinxAtStartPar
salldiffdp var \sphinxstyleemphasis{cost} to express a soft alldifferent constraint with variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation (decomposes into samongdp cost functions)

\item {} 
\sphinxAtStartPar
sgccdp var \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express a soft global cardinality constraint with variable\sphinxhyphen{}based (\sphinxstyleemphasis{var} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound (decomposes into samongdp cost functions)

\item {} 
\sphinxAtStartPar
max|smaxdp \sphinxstyleemphasis{defCost} \sphinxstyleemphasis{nbtuples} (\sphinxstyleemphasis{variable} \sphinxstyleemphasis{value} \sphinxstyleemphasis{cost})* to express a weighted max cost function to find the maximum cost over a set of unary cost functions associated to a set of variables (by default, \sphinxstyleemphasis{defCost} if unspecified)

\item {} 
\sphinxAtStartPar
MST|smstdp to express a spanning tree hard constraint where each variable is assigned to its parent variable index in order to build a spanning tree (the root being assigned to itself)

\end{itemize}


\end{itemize}


\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
Global cost functions using a cost function network\sphinxhyphen{}based propagator:\begin{itemize}
\item {} 
\sphinxAtStartPar
wregular \sphinxstyleemphasis{nb\_states} \sphinxstyleemphasis{nb\_initial\_states} (\sphinxstyleemphasis{state} and cost)* \sphinxstyleemphasis{nb\_final\_states} (\sphinxstyleemphasis{state} and cost)* \sphinxstyleemphasis{nb\_transitions} (\sphinxstyleemphasis{start\_state} \sphinxstyleemphasis{symbol\_value} \sphinxstyleemphasis{end\_state} \sphinxstyleemphasis{cost})* to express a weighted regular constraint with weights on initial states, final states, and transitions, followed by the definition of a deterministic finite automaton with number of states, list of initial and final states with their costs, and list of weighted state transitions where symbols are domain values

\item {} 
\sphinxAtStartPar
walldiff hard|lin|quad \sphinxstyleemphasis{cost} to express a soft alldifferent constraint as a set of wamong hard constraint (\sphinxstyleemphasis{hard} keyword) or decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{lin} and \sphinxstyleemphasis{quad} keywords) cost semantic with a given \sphinxstyleemphasis{cost} per violation

\item {} 
\sphinxAtStartPar
wgcc hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express a soft global cardinality constraint as either a hard constraint (\sphinxstyleemphasis{hard} keyword) or with decomposition\sphinxhyphen{}based (\sphinxstyleemphasis{lin} and \sphinxstyleemphasis{quad} keyword) cost semantic with a given \sphinxstyleemphasis{cost} per violation and for each value its lower and upper bound

\item {} 
\sphinxAtStartPar
wsame hard|lin|quad \sphinxstyleemphasis{cost} to express a permutation constraint on two lists of variables of equal size (implicitly concatenated in the scope) using implicit decomposition\sphinxhyphen{}based cost semantic

\item {} 
\sphinxAtStartPar
wsamegcc hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value} \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound})* to express the combination of a soft global cardinality constraint and a permutation constraint

\item {} 
\sphinxAtStartPar
wamong hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* \sphinxstyleemphasis{lower\_bound} \sphinxstyleemphasis{upper\_bound} to express a soft among constraint to restrict the number of variables taking their value into a given set of values

\item {} 
\sphinxAtStartPar
wvaramong hard \sphinxstyleemphasis{cost} \sphinxstyleemphasis{nb\_values} (\sphinxstyleemphasis{value})* to express a hard among constraint to restrict the number of variables taking their value into a given set of values to be equal to the last variable in the scope

\item {} 
\sphinxAtStartPar
woverlap hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} \sphinxstyleemphasis{righthandside} overlaps between two sequences of variables X, Y (i.e. set the fact that Xi and Yi take the same value (not equal to zero))

\item {} 
\sphinxAtStartPar
wsum hard|lin|quad \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} \sphinxstyleemphasis{righthandside} to express a soft sum constraint with unit coefficients to test if the sum of a set of variables matches with a given comparator and right\sphinxhyphen{}hand\sphinxhyphen{}side value

\item {} 
\sphinxAtStartPar
wvarsum hard \sphinxstyleemphasis{cost} \sphinxstyleemphasis{comparator} to express a hard sum constraint to restrict the sum to be \sphinxstyleemphasis{comparator} to the value of the last variable in the scope

\item {} 
\sphinxAtStartPar
wdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a dual encoding such that there is a given minimum Hamming distance to a given variable assignment

\item {} 
\sphinxAtStartPar
whdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a hidden encoding such that there is a given minimum Hamming distance to a given variable assignment

\item {} 
\sphinxAtStartPar
wtdiverse \sphinxstyleemphasis{distance} (\sphinxstyleemphasis{value})* to express a hard diversity constraint using a ternary encoding such that there is a given minimum Hamming distance to a given variable assignment

\sphinxAtStartPar
Let us note \textless{}\textgreater{} the comparator, K the right\sphinxhyphen{}hand\sphinxhyphen{}side value associated to the comparator, and Sum the result of the sum over the variables. For each comparator, the gap is defined according to the distance as follows:\begin{itemize}
\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is == : gap = abs(K \sphinxhyphen{} Sum)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{}= : gap = max(0,Sum \sphinxhyphen{} K)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{} : gap = max(0,Sum \sphinxhyphen{} K \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is != : gap = 1 if Sum != K and gap = 0 otherwise

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{} : gap = max(0,K \sphinxhyphen{} Sum + 1);

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{}= : gap = max(0,K \sphinxhyphen{} Sum);

\end{itemize}


\end{itemize}


\end{itemize}


\sphinxAtStartPar
Warning : The decomposition of wsum and wvarsum may use an exponential size (sum of domain sizes).

\sphinxAtStartPar
Warning : \sphinxstyleemphasis{list\_size1} and \sphinxstyleemphasis{list\_size2} must be equal in \sphinxstyleemphasis{ssame}.

\sphinxAtStartPar
Warning : Cost functions defined in intention cannot be shared.

\sphinxAtStartPar
Note More about network\sphinxhyphen{}based global cost functions can be found on ./misc/doc/DecomposableGlobalCostFunctions.html

\sphinxAtStartPar
Examples:\begin{itemize}
\item {} 
\sphinxAtStartPar
quadratic cost function \(x0 * x1\) in extension with variable domains \(\{0,1\}\) (equivalent to a soft clause \(\neg x0 \vee \neg x1\)):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
simple arithmetic hard constraint \(x1 < x2\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
hard temporal disjunction \(x1 \geq x2 + 2 \vee x2 \geq x1 + 1\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{disj} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{n}{UB} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
clique cut (\{x0,x1,x2,x3\}) on Boolean variables such that value 1 is used at most once:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{clique} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
knapsack constraint ( \(2 * x0 + 3 * x1 + 4 * x2 + 5 * x3 >= 10\)) on four Boolean 0/1 variables:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{knapsack} \PYG{l+m+mi}{10} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
knapsackp constraint ( \(2 * (x0=0) + 3 * (x1=1) + 4 * (x2=2) + 5 * (x3=0 \vee x3=1) >= 10\)) on four \{0,1,2\}\sphinxhyphen{}domain variables:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{knapsackp} \PYG{l+m+mi}{10} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_alldifferent(\{x0,x1,x2,x3\}):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_gcc(\{x1,x2,x3,x4\}) with each value \sphinxstyleemphasis{v} from 1 to 4 only appearing at least v\sphinxhyphen{}1 and at most v+1 times:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sgcc} \PYG{n}{var} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_same(\{x0,x1,x2,x3\},\{x4,x5,x6,x7\}):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{8} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{ssame} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_regular(\{x1,x2,x3,x4\}) with DFA (3*)+(4*):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sregular} \PYG{n}{var} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_grammar(\{x0,x1,x2,x3\}) with hard cost (1000) producing well\sphinxhyphen{}formed parenthesis expressions:
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{sgrammardp} \PYG{n}{var} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft\_among(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i \in \{1,2\}) < 1\) or \(\sum_{i=1}^4(x_i \in \{1,2\}) > 3\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{samongdp} \PYG{n}{var} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
soft max(\{x0,x1,x2,x3\}) with cost equal to \(\max_{i=0}^3((x_i!=i)?1000:(4-i))\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{smaxdp} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wregular(\{x0,x1,x2,x3\}) with DFA (0(10)*2*):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wregular} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{9} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wamong(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i \in \{1,2\}) < 1\) or \(\sum_{i=1}^4(x_i \in \{1,2\}) > 3\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wamong} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wvaramong(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^3(x_i \in \{1,2\}) \neq x_4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wvaramong} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
woverlap(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^2(x_i = x_{i+2}) \geq 1\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{woverlap} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wsum(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^4(x_i) \neq 4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wsum} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{==} \PYG{l+m+mi}{4} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wvarsum(\{x1,x2,x3,x4\}) with hard cost (1000) if \(\sum_{i=1}^3(x_i) \neq x_4\):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wvarsum} \PYG{n}{hard} \PYG{l+m+mi}{1000} \PYG{o}{==} 
\end{sphinxVerbatim}


\item {} 
\sphinxAtStartPar
wdiverse(\{x0,x1,x2,x3\}) hard constraint on four variables with minimum Hamming distance of 2 to the value assignment (1,1,0,0):
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{wdiverse} \PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} 
\end{sphinxVerbatim}


\end{itemize}


\sphinxAtStartPar
Latin Square 4 x 4 crisp CSP example in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{latin4} \PYG{l+m+mi}{16} \PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{6} \PYG{l+m+mi}{7} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{9} \PYG{l+m+mi}{10} \PYG{l+m+mi}{11} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{12} \PYG{l+m+mi}{13} \PYG{l+m+mi}{14} \PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4} \PYG{l+m+mi}{8} \PYG{l+m+mi}{12} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5} \PYG{l+m+mi}{9} \PYG{l+m+mi}{13} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{2} \PYG{l+m+mi}{6} \PYG{l+m+mi}{10} \PYG{l+m+mi}{14} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{3} \PYG{l+m+mi}{7} \PYG{l+m+mi}{11} \PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{n}{salldiff} \PYG{n}{var} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\sphinxAtStartPar
4\sphinxhyphen{}queens binary weighted CSP example with random unary costs in wcsp format: 
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{4}\PYG{o}{\PYGZhy{}}\PYG{n}{WQUEENS} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{10} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{6}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{8}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{10}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{5}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2}
\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}
 

\end{fulllineitems}


\sphinxstepscope


\subsection{UAI and LG formats (.uai, .LG)}
\label{\detokenize{formats/uailgformat:uai-and-lg-formats-uai-lg}}\label{\detokenize{formats/uailgformat:uai-lg-format}}\label{\detokenize{formats/uailgformat::doc}}
\sphinxAtStartPar
It is a simple text file format specified below to describe probabilistic graphical model instances. The format is a generalization of the Ergo file format initially developed by Noetic Systems Inc. for their Ergo software.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Structure}

\sphinxAtStartPar
A file in the UAI format consists of the following two parts, in that order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{Preamble}\PYG{o}{\PYGZgt{}}

\PYG{o}{\PYGZlt{}}\PYG{n}{Function} \PYG{n}{tables}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
The contents of each section (denoted \(<...>\) above) are described in the following:

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Preamble}

\sphinxAtStartPar
The preamble starts with one line denoting the type of network. This will be either BAYES (if the network is a Bayesian network) or MARKOV (in case of a Markov network). This is followed by a line containing the number of variables. The next line specifies each variable’s domain size, one at a time, separated by whitespace (note that this implies an order on the variables which will be used throughout the file).

\sphinxAtStartPar
The fourth line contains only one integer, denoting the number of functions in the problem (conditional probability tables for Bayesian networks, general factors for Markov networks). Then, one function per line, the scope of each function is given as follows: The first integer in each line specifies the size of the function’s scope, followed by the actual indexes of the variables in the scope. The order of this list is not restricted, except when specifying a conditional probability table (CPT) in a Bayesian network, where the child variable has to come last. Also note that variables are indexed starting with 0.

\sphinxAtStartPar
For instance, a general function over variables 0, 5 and 11 would have this entry:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{5} \PYG{l+m+mi}{11}
\end{sphinxVerbatim}

\sphinxAtStartPar
A simple Markov network preamble with three variables and two functions might for instance look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MARKOV}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line denotes the Markov network, the second line tells us the problem consists of three variables, let’s refer to them as X, Y, and Z. Their domain size is 2, 2, and 3 respectively (from the third line). Line four specifies that there are 2 functions. The scope of the first function is X,Y, while the second function is defined over X,Y,Z.

\sphinxAtStartPar
An example preamble for a Belief network over three variables (and therefore with three functions) might be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BAYES}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}
\end{sphinxVerbatim}

\sphinxAtStartPar
The first line signals a Bayesian network. This example has three variables, let’s call them X, Y, and Z, with domain size 2, 2, and 3, respectively (from lines two and three). Line four says that there are 3 functions (CPTs in this case). The scope of the first function is given in line five as just X (the probability P(X)), the second one is defined over X and Y (this is (Y | X)). The third function, from line seven, is the CPT P(Z | Y). We can therefore deduce that the joint probability for this problem factors as P(X,Y,Z) = P(X).P(Y | X).P(Z | Y).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Function tables}

\sphinxAtStartPar
In this section each function is specified by giving its full table (i.e, specifying the function value for each tuple). The order of the functions is identical to the one in which they were introduced in the preamble.

\sphinxAtStartPar
For each function table, first the number of entries is given (this should be equal to the product of the domain sizes of the variables in the scope). Then, one by one, separated by whitespace, the values for each assignment to the variables in the function’s scope are enumerated. Tuples are implicitly assumed in ascending order, with the last variable in the scope as the ‘least significant’.

\sphinxAtStartPar
To illustrate, we continue with our Bayesian network example from above, let’s assume the following conditional probability tables:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X}      \PYG{n}{P}\PYG{p}{(}\PYG{n}{X}\PYG{p}{)}
\PYG{l+m+mi}{0}      \PYG{l+m+mf}{0.436}
\PYG{l+m+mi}{1}      \PYG{l+m+mf}{0.564}

\PYG{n}{X}      \PYG{n}{Y}         \PYG{n}{P}\PYG{p}{(}\PYG{n}{Y} \PYG{o}{|} \PYG{n}{X}\PYG{p}{)}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.128}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.872}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.920}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.080}

\PYG{n}{Y}      \PYG{n}{Z}         \PYG{n}{P}\PYG{p}{(}\PYG{n}{Z} \PYG{o}{|} \PYG{n}{Y}\PYG{p}{)}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.210}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.333}
\PYG{l+m+mi}{0}      \PYG{l+m+mi}{2}         \PYG{l+m+mf}{0.457}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{0}         \PYG{l+m+mf}{0.811}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{1}         \PYG{l+m+mf}{0.000}
\PYG{l+m+mi}{1}      \PYG{l+m+mi}{2}         \PYG{l+m+mf}{0.189}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
The corresponding function tables in the file would then look like this:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
 \PYG{l+m+mf}{0.436} \PYG{l+m+mf}{0.564}

\PYG{l+m+mi}{4}
 \PYG{l+m+mf}{0.128} \PYG{l+m+mf}{0.872}
 \PYG{l+m+mf}{0.920} \PYG{l+m+mf}{0.080}

\PYG{l+m+mi}{6}
 \PYG{l+m+mf}{0.210} \PYG{l+m+mf}{0.333} \PYG{l+m+mf}{0.457}
 \PYG{l+m+mf}{0.811} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.189}
\end{sphinxVerbatim}

\sphinxAtStartPar
(Note that line breaks and empty lines are effectively just whitespace, exactly like plain spaces ” “. They are used here to improve readability.)

\sphinxAtStartPar
In the LG format, probabilities are replaced by their logarithm.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Summary}

\sphinxAtStartPar
To sum up, a problem file consists of 2 sections: the preamble and the full the function tables, the names and the labels.

\sphinxAtStartPar
For our Markov network example above, the full file could be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{MARKOV}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{2}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}

\PYG{l+m+mi}{4}
 \PYG{l+m+mf}{4.000} \PYG{l+m+mf}{2.400}
 \PYG{l+m+mf}{1.000} \PYG{l+m+mf}{0.000}

\PYG{l+m+mi}{12}
 \PYG{l+m+mf}{2.2500} \PYG{l+m+mf}{3.2500} \PYG{l+m+mf}{3.7500}
 \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{0.0000} \PYG{l+m+mf}{10.0000}
 \PYG{l+m+mf}{1.8750} \PYG{l+m+mf}{4.0000} \PYG{l+m+mf}{3.3330}
 \PYG{l+m+mf}{2.0000} \PYG{l+m+mf}{2.0000} \PYG{l+m+mf}{3.4000}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
Here is the full Bayesian network example from above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{BAYES}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}
\PYG{l+m+mi}{3}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{l+m+mi}{2} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}

\PYG{l+m+mi}{2}
 \PYG{l+m+mf}{0.436} \PYG{l+m+mf}{0.564}

\PYG{l+m+mi}{4}
 \PYG{l+m+mf}{0.128} \PYG{l+m+mf}{0.872}
 \PYG{l+m+mf}{0.920} \PYG{l+m+mf}{0.080}

\PYG{l+m+mi}{6}
 \PYG{l+m+mf}{0.210} \PYG{l+m+mf}{0.333} \PYG{l+m+mf}{0.457}
 \PYG{l+m+mf}{0.811} \PYG{l+m+mf}{0.000} \PYG{l+m+mf}{0.189}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Expressing evidence}

\sphinxAtStartPar
Evidence is specified in a separate file. This file has the same name as the original problems file but an added .evid extension at the end. For instance, problem.uai will have evidence in problem.uai.evid.

\sphinxAtStartPar
The file simply starts with a line specifying the number of evidence variables. This is followed by the pairs of variable and value indexes for each observed variable, one pair per line. The indexes correspond to the ones implied by the original problem file.

\sphinxAtStartPar
If, for our above example, we want to specify that variable Y has been observed as having its first value and Z with its second value, the file example.uai.evid would contain the following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2}
 \PYG{l+m+mi}{1} \PYG{l+m+mi}{0}
 \PYG{l+m+mi}{2} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{itemize}

\sphinxstepscope


\subsection{Partial Weighted MaxSAT format}
\label{\detokenize{formats/cnfwcnfformat:partial-weighted-maxsat-format}}\label{\detokenize{formats/cnfwcnfformat:cnfwcnf-format}}\label{\detokenize{formats/cnfwcnfformat::doc}}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Max\sphinxhyphen{}SAT input format (.cnf)\}}

\sphinxAtStartPar
The input file format for Max\sphinxhyphen{}SAT will be in DIMACS format:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{cnf} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
The file can start with comments, that is lines beginning with the character ‘c’.

\item {} 
\sphinxAtStartPar
Right after the comments, there is the line “p cnf nbvar nbclauses” indicating that the instance is in CNF format; nbvar is the number of variables appearing in the file; nbclauses is the exact number of clauses contained in the file.

\item {} 
\sphinxAtStartPar
Then the clauses follow. Each clause is a sequence of distinct non\sphinxhyphen{}null numbers between \sphinxhyphen{}nbvar and nbvar ending with 0 on the same line. Positive numbers denote the corresponding variables. Negative numbers denote the negations of the corresponding variables.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Weighted Max\sphinxhyphen{}SAT input format (.wcnf)}

\sphinxAtStartPar
In Weighted Max\sphinxhyphen{}SAT, the parameters line is “p wcnf nbvar nbclauses”. The weights of each clause will be identified by the first integer in each clause line. The weight of each clause is an integer greater than or equal to 1.

\sphinxAtStartPar
Example of Weighted Max\sphinxhyphen{}SAT formula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Weighted} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{wcnf} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4}
\PYG{l+m+mi}{10} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{5} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Partial Max\sphinxhyphen{}SAT input format (.wcnf)}

\sphinxAtStartPar
In Partial Max\sphinxhyphen{}SAT, the parameters line is “p wcnf nbvar nbclauses top”. We associate a weight with each clause, which is the first integer in the clause. Weights must be greater than or equal to 1. Hard clauses have weight top and soft clauses have weight 1. We assume that top is a weight always greater than the sum of the weights of violated soft clauses.

\sphinxAtStartPar
Example of Partial Max\sphinxhyphen{}SAT formula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Partial} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{wcnf} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{15}
\PYG{l+m+mi}{15} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{15} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Weighted Partial Max\sphinxhyphen{}SAT input format (.wcnf)}

\sphinxAtStartPar
In Weighted Partial Max\sphinxhyphen{}SAT, the parameters line is “p wcnf nbvar nbclauses top”. We associate a weight with each clause, which is the first integer in the clause. Weights must be greater than or equal to 1. Hard clauses have weight top and soft clauses have a weight smaller than top. We assume that top is a weight always greater than the sum of the weights of violated soft clauses.

\sphinxAtStartPar
Example of Weighted Partial Max\sphinxhyphen{}SAT formula:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{c}
\PYG{n}{c} \PYG{n}{comments} \PYG{n}{Weighted} \PYG{n}{Partial} \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{SAT}
\PYG{n}{c}
\PYG{n}{p} \PYG{n}{wcnf} \PYG{l+m+mi}{4} \PYG{l+m+mi}{5} \PYG{l+m+mi}{16}
\PYG{l+m+mi}{16} \PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{16} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{8} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{4} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{4} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{l+m+mi}{0}
\PYG{l+m+mi}{3} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{0}
\end{sphinxVerbatim}
\end{quote}

\sphinxstepscope


\subsection{QPBO format (.qpbo)}
\label{\detokenize{formats/qpboformat:qpbo-format-qpbo}}\label{\detokenize{formats/qpboformat:qpbo-format}}\label{\detokenize{formats/qpboformat::doc}}
\sphinxAtStartPar
In the quadratic pseudo\sphinxhyphen{}Boolean optimization (unconstrained quadratic programming) format, the goal is to minimize or maximize the quadratic function:

\sphinxAtStartPar
\(X' * W * X = \sum_{i=1}^N \sum_{j=1}^N  W_{ij} * X_i * X_j\)

\sphinxAtStartPar
where \(W\) is a symmetric squared \(N \times N\) matrix expressed by all its non\sphinxhyphen{}zero half (\(i \leq j\)) squared matrix coefficients, \(X\) is a vector of \(N\) binary variables with domain values in \(\{0,1\}\) or \(\{1,-1\}\), and \(X'\) is the transposed vector of \(X\).

\sphinxAtStartPar
Note that for two indices \(i \neq j\), coefficient \(W_{ij} = W_{ji}\) (symmetric matrix) and it appears twice in the previous sum.
It can be controled by the option \{tt \sphinxhyphen{}qpmult={[}double{]}\} which defines a coefficient multiplier for quadratic terms (default value is 2).

\sphinxAtStartPar
Note also that coefficients can be positive or negative and are real float numbers. They are converted to fixed\sphinxhyphen{}point real numbers by multiplying them by \(10^{precision}\) (see option \{em \sphinxhyphen{}precision\} to modify it, default value is 7).  Infinite coefficients are forbidden.

\sphinxAtStartPar
Notice that depending on the sign of the number of variables in the first text line, the domain of all variables is either \(\{0,1\}\) or \(\{1,-1\}\).

\sphinxAtStartPar
Warning! The encoding in Weighted CSP of variable domain \(\{1,-1\}\) associates for each variable value the following index: value 1 has index 0 and value \sphinxhyphen{}1 has index 1 in the solutions found by toulbar2.
The encoding  of variable domain \(\{0,1\}\) is direct.

\sphinxAtStartPar
Qpbo is a file text format:
\begin{itemize}
\item {} 
\sphinxAtStartPar
First line contains the number of variables \(N\) and the number of non\sphinxhyphen{}zero coefficients \(M\).

\sphinxAtStartPar
If \(N\) is negative then domain values are in \(\{1, -1\}\), otherwise \(\{0, 1\}\).
If \(M\) is negative then it will maximize the quadratic function, otherwise it will minimize it.

\item {} 
\sphinxAtStartPar
Followed by \(|M|\) lines where each text line contains three values separated by spaces:
position index \(i\) (integer belonging to \([1,|N|]\)),
position index \(j\) (integer belonging to \([1,|N|]\)),
coefficient \(W_{ij}\) (float number)
such that \(i \leq j\) and \(W_{ij} \neq 0\).

\end{itemize}

\sphinxstepscope


\subsection{OPB format (.opb)}
\label{\detokenize{formats/opbformat:opb-format-opb}}\label{\detokenize{formats/opbformat:opb-format}}\label{\detokenize{formats/opbformat::doc}}
\sphinxAtStartPar
The OPB file format is used to express pseudo\sphinxhyphen{}Boolean satisfaction and optimization models.
These models may only contain \(0/1\) Boolean variables. The format is defined by an optional objective function followed by a set of linear constraints.
Variables may be multiplied together in the objective function, but currently not in the constraints due to some restriction in the reader.
The objective function must start with the \sphinxstylestrong{min:} or \sphinxstylestrong{max:} keyword followed by \sphinxstylestrong{coef\_1 varname\_1\_1 varname\_1\_2 … coef2 varname\_2\_1 …} and end with a \sphinxstylestrong{;}.
Linear constraints are composed in the same way, ended by a comparison operator (\sphinxstylestrong{\textless{}=}, \sphinxstylestrong{\textgreater{}=}, or \sphinxstylestrong{!=}) followed by the right\sphinxhyphen{}hand side coefficient and \sphinxstylestrong{;}.
Each coefficient must be an integer beginning with its sign (\sphinxstylestrong{+} or \sphinxstylestrong{\sphinxhyphen{}} with no extra space).
Comment lines start with a *.

\sphinxAtStartPar
An example with a quadratic objective and 7 linear constraints is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{max}\PYG{p}{:} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{n}{x2} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x3} \PYG{n}{x4}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x2} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x3} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x4} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x1} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x3} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x2} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x4} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x2} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x4} \PYG{o}{+}\PYG{l+m+mi}{1} \PYG{n}{x3} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x1} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x2} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x3} \PYG{o}{+}\PYG{l+m+mi}{2} \PYG{n}{x4} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{l+m+mi}{7}\PYG{p}{;}
\end{sphinxVerbatim}

\sphinxAtStartPar
Internally, all integer costs are multiplied by a power of ten depending on the \sphinxhyphen{}precision option.
For problems with big integers, try to reduce the precision (\sphinxstyleemphasis{e.g.}, use option \sphinxhyphen{}precision 0).

\sphinxstepscope


\subsection{XCSP2.1 format (.xml)}
\label{\detokenize{formats/xmlformat:xcsp2-1-format-xml}}\label{\detokenize{formats/xmlformat:xml-format}}\label{\detokenize{formats/xmlformat::doc}}
\sphinxAtStartPar
CSP and weighted CSP in XML format XCSP 2.1, with constraints in extension only, can be read. See a description of this deprecated format here \sphinxurl{http://www.cril.univ-artois.fr/CPAI08/XCSP2\_1.pdf}.

\sphinxAtStartPar
Warning, toulbar2 must be compiled with a specific option XML in the cmake.


\subsection{XCSP3 format (.xml)}
\label{\detokenize{formats/xmlformat:xcsp3-format-xml}}
\sphinxAtStartPar
CSP and COP format in XML format XCSP3 core can be read (still on\sphinxhyphen{}going work for including globals). See a description of this format here \sphinxurl{http://xcsp.org}.

\sphinxAtStartPar
Warning, toulbar2 must be compiled with specific options XML and XCSP3 in the cmake.

\sphinxstepscope


\subsection{Linkage format (.pre)}
\label{\detokenize{formats/preformat:linkage-format-pre}}\label{\detokenize{formats/preformat:pre-format}}\label{\detokenize{formats/preformat::doc}}
\sphinxAtStartPar
See \sphinxstylestrong{mendelsoft} companion software at \sphinxurl{http://miat.inrae.fr/MendelSoft} for pedigree correction. See also \sphinxurl{https://carlit.toulouse.inra.fr/cgi-bin/awki.cgi/HaplotypeInference} for haplotype inference in half\sphinxhyphen{}sib families.


\chapter{How do I use it ?}
\label{\detokenize{userdoc:how-do-i-use-it}}

\section{Using it as a C++ library}
\label{\detokenize{userdoc:using-it-as-a-c-library}}
\sphinxAtStartPar
See \DUrole{xref,std,std-ref}{toulbar2 Reference Manual} which describes the libtb2.so C++ library API.


\section{Using it from Python}
\label{\detokenize{userdoc:using-it-from-python}}
\sphinxAtStartPar
A Python interface is now available. Compile toulbar2 with cmake option PYTB2 (and without MPI options) to generate a Python module \sphinxstylestrong{pytoulbar2} (in lib directory). See examples in \sphinxcode{\sphinxupquote{src/pytoulbar2.cpp}}
and \DUrole{xref,std,std-ref}{web/TUTORIALS} directory.

\sphinxAtStartPar
An older version of toulbar2 was integrated inside Numberjack. See \sphinxurl{https://github.com/eomahony/Numberjack}.


\chapter{References}
\label{\detokenize{userdoc:references}}
\sphinxAtStartPar
See ‘BIBLIOGRAPHY’ at the end of the document.

\begin{sphinxthebibliography}{Katsirel}
\bibitem[Beldjilali22]{userdoc:beldjilali22}
\sphinxAtStartPar
A Beldjilali, P Montalbano, D Allouche, G Katsirelos and S de Givry.
Parallel Hybrid Best\sphinxhyphen{}First Search.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}22}, Haifa, Israel, 2022.
\bibitem[Schiex2020b]{userdoc:schiex2020b}
\sphinxAtStartPar
Céline Brouard and Simon de Givry and Thomas Schiex.
Pushing Data in CP Models Using Graphical Model Learning and Solving.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}20}, Louvain\sphinxhyphen{}la\sphinxhyphen{}neuve, Belgium, 2020.
\bibitem[Trosser2020a]{userdoc:trosser2020a}
\sphinxAtStartPar
Fulya Trösser, Simon de Givry and George Katsirelos.
Relaxation\sphinxhyphen{}Aware Heuristics for Exact Optimization in Graphical Models.
In \sphinxstyleemphasis{Proc.of CP\sphinxhyphen{}AI\sphinxhyphen{}OR’2020}, Vienna, Austria, 2020.
\bibitem[Ruffini2019a]{userdoc:ruffini2019a}
\sphinxAtStartPar
M. Ruffini, J. Vucinic, S. de Givry, G. Katsirelos, S. Barbe and T. Schiex.
Guaranteed Diversity \& Quality for the Weighted CSP.
In \sphinxstyleemphasis{Proc. of ICTAI\sphinxhyphen{}19}, pages 18\sphinxhyphen{}25, Portland, OR, USA, 2019.
\bibitem[Ouali2017]{userdoc:ouali2017}
\sphinxAtStartPar
Abdelkader Ouali, David Allouche, Simon de Givry, Samir Loudni, Yahia Lebbah, Francisco Eckhardt, Lakhdar Loukil.
Iterative Decomposition Guided Variable Neighborhood Search for Graphical Model Energy Minimization.
In \sphinxstyleemphasis{Proc. of UAI\sphinxhyphen{}17}, pages 550\sphinxhyphen{}559, Sydney, Australia, 2017.
\bibitem[Schiex2016a]{userdoc:schiex2016a}
\sphinxAtStartPar
David Allouche, Christian Bessière, Patrice Boizumault, Simon de Givry, Patricia Gutierrez, Jimmy H.M. Lee, Ka Lun Leung, Samir Loudni, Jean\sphinxhyphen{}Philippe Métivier, Thomas Schiex and Yi Wu.
Tractability\sphinxhyphen{}preserving transformations of global cost functions.
\sphinxstyleemphasis{Artificial Intelligence}, 238:166\sphinxhyphen{}189, 2016.
\bibitem[Hurley2016b]{userdoc:hurley2016b}
\sphinxAtStartPar
B Hurley, B O’Sullivan, D Allouche, G Katsirelos, T Schiex, M Zytnicki and S de Givry.
Multi\sphinxhyphen{}Language Evaluation of Exact Solvers in Graphical Model Discrete Optimization.
\sphinxstyleemphasis{Constraints}, 21(3):413\sphinxhyphen{}434, 2016.
Presentation at CPAIOR’16, Banff, Canada,
\sphinxurl{http://www.inra.fr/mia/T/degivry/cpaior16sdg.pdf}.
\bibitem[Katsirelos2015a]{userdoc:katsirelos2015a}
\sphinxAtStartPar
D Allouche, S de Givry, G Katsirelos, T Schiex and M Zytnicki.
Anytime Hybrid Best\sphinxhyphen{}First Search with Tree Decomposition for Weighted CSP.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}15}, pages 12\sphinxhyphen{}28, Cork, Ireland, 2015.
\bibitem[Schiex2014a]{userdoc:schiex2014a}
\sphinxAtStartPar
David Allouche, Jessica Davies, Simon de Givry, George Katsirelos, Thomas Schiex, Seydou Traoré, Isabelle André, Sophie Barbe, Steve Prestwich and Barry O’Sullivan.
Computational Protein Design as an Optimization Problem.
\sphinxstyleemphasis{Artificial Intelligence}, 212:59\sphinxhyphen{}79, 2014.
\bibitem[Givry2013a]{userdoc:givry2013a}
\sphinxAtStartPar
S de Givry, S Prestwich and B O’Sullivan.
Dead\sphinxhyphen{}End Elimination for Weighted CSP.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}13}, pages 263\sphinxhyphen{}272, Uppsala, Sweden, 2013.
\bibitem[Ficolofo2012]{userdoc:ficolofo2012}
\sphinxAtStartPar
D Allouche, C Bessiere, P Boizumault, S de Givry, P Gutierrez, S Loudni, JP Métivier and T Schiex.
Decomposing Global Cost Functions.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}12}, Toronto, Canada, 2012.
\sphinxurl{http://www.inra.fr/mia/T/degivry/Ficolofo2012poster.pdf} (poster).
\bibitem[Favier2011a]{userdoc:favier2011a}
\sphinxAtStartPar
A Favier, S de Givry, A Legarra and T Schiex.
Pairwise decomposition for combinatorial optimization in graphical models.
In \sphinxstyleemphasis{Proc. of IJCAI\sphinxhyphen{}11}, Barcelona, Spain, 2011.
Video demonstration at \sphinxurl{http://www.inra.fr/mia/T/degivry/Favier11.mov}.
\bibitem[Cooper2010a]{userdoc:cooper2010a}
\sphinxAtStartPar
M. Cooper, S. de Givry, M. Sanchez, T. Schiex, M. Zytnicki and T. Werner.
Soft arc consistency revisited.
\sphinxstyleemphasis{Artificial Intelligence}, 174(7\sphinxhyphen{}8):449\sphinxhyphen{}478, 2010.
\bibitem[Favier2009a]{userdoc:favier2009a}
\sphinxAtStartPar
A. Favier, S. de Givry and P. Jégou.
Exploiting Problem Structure for Solution Counting.
In \sphinxstyleemphasis{Proc. of CP\sphinxhyphen{}09}, pages 335\sphinxhyphen{}343, Lisbon, Portugal, 2009.
\bibitem[Sanchez2009a]{userdoc:sanchez2009a}
\sphinxAtStartPar
M Sanchez, D Allouche, S de Givry and T Schiex.
Russian Doll Search with Tree Decomposition.
In \sphinxstyleemphasis{Proc. of IJCAI’09}, Pasadena (CA), USA, 2009.
\sphinxhref{http://www.inra.fr/mia/T/degivry/rdsbtd\_ijcai09\_sdg.ppt}{http://www.inra.fr/mia/T/degivry/rdsbtd\_ijcai09\_sdg.ppt}.
\bibitem[Cooper2008]{userdoc:cooper2008}
\sphinxAtStartPar
M. Cooper, S. de Givry, M. Sanchez, T. Schiex and M. Zytnicki.
Virtual Arc Consistency for Weighted CSP.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}08}, Chicago, IL, 2008.
\bibitem[Schiex2006a]{userdoc:schiex2006a}
\sphinxAtStartPar
S. de Givry, T. Schiex and G. Verfaillie.
Exploiting Tree Decomposition and Soft Local Consistency in Weighted CSP.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}06}, Boston, MA, 2006.
\sphinxurl{http://www.inra.fr/mia/T/degivry/VerfaillieAAAI06pres.pdf} (slides).
\bibitem[Heras2005]{userdoc:heras2005}
\sphinxAtStartPar
S. de Givry, M. Zytnicki, F. Heras and J. Larrosa.
Existential arc consistency: Getting closer to full arc consistency in weighted CSPs.
In \sphinxstyleemphasis{Proc. of IJCAI\sphinxhyphen{}05}, pages 84\sphinxhyphen{}89, Edinburgh, Scotland, 2005.
\bibitem[Larrosa2000]{userdoc:larrosa2000}
\sphinxAtStartPar
J. Larrosa.
Boosting search with variable elimination.
In \sphinxstyleemphasis{Principles and Practice of Constraint Programming \sphinxhyphen{} CP 2000},
volume 1894 of LNCS, pages 291\sphinxhyphen{}305, Singapore, September 2000.
\bibitem[koller2009]{userdoc:koller2009}
\sphinxAtStartPar
D Koller and N Friedman.
Probabilistic graphical models: principles and techniques.
The MIT Press, 2009.
\bibitem[Ginsberg1995]{userdoc:ginsberg1995}
\sphinxAtStartPar
W. D. Harvey and M. L. Ginsberg.
Limited Discrepency Search.
In \sphinxstyleemphasis{Proc. of IJCAI\sphinxhyphen{}95}, Montréal, Canada, 1995.
\bibitem[Lecoutre2009]{userdoc:lecoutre2009}
\sphinxAtStartPar
C. Lecoutre, L. Saïs, S. Tabary and V. Vidal.
Reasoning from last conflict(s) in constraint programming.
\sphinxstyleemphasis{Artificial Intelligence}, 173:1592,1614, 2009.
\bibitem[boussemart2004]{userdoc:boussemart2004}
\sphinxAtStartPar
Frédéric Boussemart, Fred Hemery, Christophe Lecoutre and Lakhdar Sais.
Boosting systematic search by weighting constraints.
In \sphinxstyleemphasis{ECAI}, volume 16, page 146, 2004.
\bibitem[idwalk:cp04]{userdoc:idwalk-cp04}
\sphinxAtStartPar
Bertrand Neveu, Gilles Trombettoni and Fred Glover.
ID Walk: A Candidate List Strategy with a Simple Diversification Device.
In \sphinxstyleemphasis{Proc. of CP}, pages 423\sphinxhyphen{}437, Toronto, Canada, 2004.
\bibitem[Verfaillie1996]{userdoc:verfaillie1996}
\sphinxAtStartPar
G. Verfaillie, M. Lemaître and T. Schiex.
Russian Doll Search.
In \sphinxstyleemphasis{Proc. of AAAI\sphinxhyphen{}96}, pages 181\sphinxhyphen{}187, Portland, OR, 1996.
\bibitem[LL2009]{userdoc:ll2009}
\sphinxAtStartPar
J. H. M. Lee and K. L. Leung.
Towards Efficient Consistency Enforcement for Global Constraints in Weighted Constraint Satisfaction.
In \sphinxstyleemphasis{Proceedings of IJCAI’09}, pages 559\sphinxhyphen{}565, 2009.
\bibitem[LL2010]{userdoc:ll2010}
\sphinxAtStartPar
J. H. M. Lee and K. L. Leung.
A Stronger Consistency for Soft Global Constraints in Weighted Constraint Satisfaction.
In \sphinxstyleemphasis{Proceedings of AAAI’10}, pages 121\sphinxhyphen{}127, 2010.
\bibitem[LL2012asa]{userdoc:ll2012asa}
\sphinxAtStartPar
J. H. M. Lee and K. L. Leung.
Consistency Techniques for Global Cost Functions in Weighted Constraint Satisfaction.
\sphinxstyleemphasis{Journal of Artificial Intelligence Research}, 43:257\sphinxhyphen{}292, 2012.
\bibitem[Larrosa2002]{userdoc:larrosa2002}
\sphinxAtStartPar
J. Larrosa.
On Arc and Node Consistency in weighted \{CSP\}.
In \sphinxstyleemphasis{Proc. AAAI’02}, pages 48\sphinxhyphen{}53, Edmondton, (CA), 2002.
\bibitem[Larrosa2003]{userdoc:larrosa2003}
\sphinxAtStartPar
J. Larrosa and T. Schiex.
In the quest of the best form of local consistency for Weighted CSP.
In \sphinxstyleemphasis{Proc. of the 18th IJCAI}, pages 239\sphinxhyphen{}244, Acapulco, Mexico, August 2003.
\bibitem[Schiex2000b]{userdoc:schiex2000b}
\sphinxAtStartPar
T. Schiex.
Arc consistency for soft constraints.
In \sphinxstyleemphasis{Principles and Practice of Constraint Programming \sphinxhyphen{} CP 2000},
volume 1894 of \sphinxstyleemphasis{LNCS}, pages 411\sphinxhyphen{}424, Singapore, September 2000.
\bibitem[CooperFCSP]{userdoc:cooperfcsp}
\sphinxAtStartPar
M.C. Cooper.
Reduction operations in fuzzy or valued constraint satisfaction.
\sphinxstyleemphasis{Fuzzy Sets and Systems}, 134(3):311\sphinxhyphen{}342, 2003.
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}