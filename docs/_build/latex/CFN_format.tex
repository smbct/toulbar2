%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{CFN format (.cfn suffix)}
\date{Nov 30, 2022}
\release{1.0.0}
\author{INRAE}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{formats/cfnformat::doc}}


\sphinxAtStartPar
With this JSON compatible format, it is possible:
\begin{itemize}
\item {} 
\sphinxAtStartPar
to give a name to variables and functions.

\item {} 
\sphinxAtStartPar
to associate a local label to every value that is accessible inside toulbar2 (among others for heuristics design purposes).

\item {} 
\sphinxAtStartPar
to use decimal and possibly negative costs.

\item {} 
\sphinxAtStartPar
to solve both minimization and maximization problems.

\item {} 
\sphinxAtStartPar
to debug your \sphinxstylestrong{.cfn} files: the parser gives a cause and line number when it fails.

\item {} 
\sphinxAtStartPar
to use gzip’d or xz compressed files directly as input (.cfn.gz and .cfn.xz).

\item {} 
\sphinxAtStartPar
to use dense descriptions for dense cost tables.

\end{itemize}

\sphinxAtStartPar
In a \sphinxstylestrong{cfn} file, a Cost Function Network is described as a JSON object with extra freedom and extra constraints.

\sphinxAtStartPar
Freedom:
\begin{itemize}
\item {} 
\sphinxAtStartPar
the double quotes around strings are not compulsory: both \sphinxcode{\sphinxupquote{"problem"}} and \sphinxcode{\sphinxupquote{problem}} are strings.

\item {} 
\sphinxAtStartPar
double quotes can also be added around numbers: both \sphinxcode{\sphinxupquote{1.20}} and \sphinxcode{\sphinxupquote{"1.20"}} will be interpreted as decimal numbers.

\item {} 
\sphinxAtStartPar
the commas that separates the fields inside an array or object are not compulsory. Any separator will do (comma, white space). So \sphinxcode{\sphinxupquote{{[}1, 2{]}}} or \sphinxcode{\sphinxupquote{{[}1,2{]}}} or \sphinxcode{\sphinxupquote{{[}1 2{]}}} are all describing the same array.

\item {} 
\sphinxAtStartPar
the delimiters for objects and arrays (\sphinxcode{\sphinxupquote{\{\}}} and \sphinxcode{\sphinxupquote{{[}{]}}}) can be used arbitrarily for both types of items.

\item {} 
\sphinxAtStartPar
the colon (\sphinxcode{\sphinxupquote{:}}) that separates the name of a field in an object from the contents of the field is not compulsory.

\item {} 
\sphinxAtStartPar
It is possible to comment a line with a \sphinxcode{\sphinxupquote{\#}} the first position of a line.

\end{itemize}

\sphinxAtStartPar
Constraints:
\begin{itemize}
\item {} 
\sphinxAtStartPar
strings should not start with a character in \sphinxcode{\sphinxupquote{0123456789\sphinxhyphen{}.+}} and cannot contain \sphinxcode{\sphinxupquote{/\#{[}{]}\{\}}} or a space character (tabs…).

\item {} 
\sphinxAtStartPar
numbers can only be integers or decimals. No scientific notation.

\item {} 
\sphinxAtStartPar
the orders of fields inside an object is compulsory and cannot be changed.

\end{itemize}

\sphinxAtStartPar
A CFN is an object with 3 data: a definition of the main problem properties (tag \sphinxcode{\sphinxupquote{problem}}), of variables and their domains (tag \sphinxcode{\sphinxupquote{variables}}) and of cost functions (tag \sphinxcode{\sphinxupquote{functions}}), in this order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{problem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{problem} \PYG{n}{properties}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{variables}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{variables} \PYG{o+ow}{and} \PYG{n}{domains}\PYG{o}{\PYGZgt{}}\PYG{p}{,}
  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{functions}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{o}{\PYGZlt{}}\PYG{n}{functions} \PYG{n}{descriptions}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Problem properties:}

\sphinxAtStartPar
An object with two fields:
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"name"}} : the name of the problem.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"mustbe"}} : specifies the direction of optimization and a global (upper/lower) bound on the objective. This is the concatenation of a comparator (\sphinxcode{\sphinxupquote{\textgreater{}}} or \sphinxcode{\sphinxupquote{\textless{}}}) immediately followed by a decimal number, described as a string. The comparator specifies the direction of optimization:

\end{enumerate}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}"}}: we are minimizing and the decimal indicates a global upper bound (all costs equal to or larger than this are considered as unfeasible).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}"}}: we are maximizing and and the decimal indicates a global lower bound (all costs equal to or less than this are considered as unfeasible).

\end{itemize}

\sphinxAtStartPar
The number of significant digits in the decimal number gives the precision that will be used for all cost computations inside toulbar2.

\sphinxAtStartPar
An an example, \sphinxcode{\sphinxupquote{"mustbe": "\textless{}10.00"}} means that the CFN describes a function where all costs larger than or equal to 10.00 are considered as infinite. All costs will also be handled with 2 digits of precision after the decimal point.
\end{quote}

\sphinxAtStartPar
The two fields must appear in this order:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{name}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}problem}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mustbe}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}\PYGZhy{}12.100}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{n}{test}\PYG{o}{.}\PYG{n}{problem} \PYG{o}{\PYGZlt{}}\PYG{l+m+mf}{12.100}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
in a more concise non JSON\sphinxhyphen{}compatible form.

\sphinxAtStartPar
\sphinxstylestrong{Variables and domains:}

\sphinxAtStartPar
An object with as many fields as variables. All fields must have different names. The contents of a variable field can be an array or an integer. An array gives the sequence of values (defined by their name) of the variable domain. An integer gives the domain cardinality, without naming values (values are represented by their position in the domain, starting at 0). If a negative domain size is given, the variable is an interval variable instead of a finite domain variable and it has domain {[}0,\sphinxhyphen{}domainsize\sphinxhyphen{}1{]}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{iv1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{:} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
defines 3 variables, two finite domain variables and 1 interval variable. The first domain variable has 3 values, \sphinxcode{\sphinxupquote{"a"}} \sphinxcode{\sphinxupquote{"b"}} and \sphinxcode{\sphinxupquote{"c"}}. the second has two anonymous values and the interval variable has domain {[}0,99{]}.

\sphinxAtStartPar
As an extra freedom, it is possible to give no name to variables. This can be achieved using an array instead of an object. The example above can therefore be written:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{p}{[}\PYG{n}{a} \PYG{n}{b} \PYG{n}{c}\PYG{p}{]} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
or even just

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{100}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
in a dense non JSON\sphinxhyphen{}compatible format.

\sphinxAtStartPar
\sphinxstylestrong{Functions:}

\sphinxAtStartPar
An object with as many fields as functions. Every function is an object with different possible fields. All functions have a \sphinxcode{\sphinxupquote{scope}} which is an array of variables (names or indices). The rest of the fields depends on the type of the cost function: table cost function or global (including arithmetic functions).

\sphinxAtStartPar
\sphinxstylestrong{Table cost functions:}

\sphinxAtStartPar
Sparse functions format:* useful for functions that are dominantly constant. A numerical \sphinxcode{\sphinxupquote{defaultcost}} must be given after the scope. The \sphinxcode{\sphinxupquote{costs}} table must be an array of tuple.costs: a sequence of value names or indices followed by a numeric cost. The \sphinxcode{\sphinxupquote{defaultcost}} is used to define the cost of any missing tuple.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{defaultcost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.234}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{6.2}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{c}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.21}\PYG{p}{]} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
is a possible sparse function definition. Here only 3 tuples are defined with their costs. All 3 remaining tuples will have cost \sphinxcode{\sphinxupquote{0.234}}.

\sphinxAtStartPar
\sphinxstyleemphasis{Dense function format:} if the \sphinxcode{\sphinxupquote{defaultcost}} tag is absent, a complete lexicographically ordered list of costs is expected instead.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fdv2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{4.2}\PYG{p}{,} \PYG{l+m+mf}{3.67}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+m+mf}{7.1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.1}\PYG{p}{,} \PYG{l+m+mf}{100.2}\PYG{p}{]} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
describes the 6 costs of the 6 tuples insides the cartesian product of the two variables \sphinxcode{\sphinxupquote{"fdv1"}} and \sphinxcode{\sphinxupquote{"fdv2"}}. To assign costs to tuples, all possible tuples of the cartesian product are lexicographically ordered using the declared value order in the domain of each variable.  In the example above, the order over the six pairs will be \sphinxcode{\sphinxupquote{("a",0) ("a",1) ("b",0) ("b",1) ("c",0) ("c",1)}} that will be associated to the costs \sphinxcode{\sphinxupquote{4.2, 3.67, \sphinxhyphen{}12.1, 7.1, \sphinxhyphen{}3.1}} and \sphinxcode{\sphinxupquote{100.2}} in this order. This lexicographic ordering is used for all arities.

\sphinxAtStartPar
\sphinxstyleemphasis{Shared function format:} If instead of an array, a string is given for the cost table, then this string must be the name of a yet undefined function. The actual function will have the same cost table as the future indicated function (on the specified scope). The domain sizes of the two functions must match.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{]}\PYG{p}{,}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{costs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f12}\PYG{l+s+s2}{\PYGZdq{}} \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
defines a function on variables \sphinxcode{\sphinxupquote{v1}} and \sphinxcode{\sphinxupquote{v3}} that will have the same cost table as the function i:code:\sphinxtitleref{f12} that must be defined later in the file.

\sphinxAtStartPar
\sphinxstylestrong{Global and arithmetic cost functions}

\sphinxAtStartPar
These functions are defined by a \sphinxcode{\sphinxupquote{scope}}, a \sphinxcode{\sphinxupquote{type}} and \sphinxcode{\sphinxupquote{parameters}}. The \sphinxcode{\sphinxupquote{type}} is a string that defines the specific function to use, the \sphinxcode{\sphinxupquote{parameters}} is an array of objects. The composition of the \sphinxcode{\sphinxupquote{parameters}} depends on the \sphinxcode{\sphinxupquote{type}} of the function.

\sphinxAtStartPar
At this point, in maximization mode, most of the global cost functions have restricted usage (with the exception of wregular).

\sphinxAtStartPar
\sphinxstyleemphasis{Arithmetic functions:}

\sphinxAtStartPar
These functions have all arity 2 and it is assumed here that these variables are called x and y . The values are considered as representing their index in the domain and are therefore integer. The \sphinxcode{\sphinxupquote{type}} can be either:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}="}} : with \sphinxcode{\sphinxupquote{parameters}} array \([ cst , \delta ]\)
where \(cst\) and \(\delta\) are two costs, to express cost
function \(max(0, y + cst - x \leq \delta ? y + cst - x : upperbound)\). This is a soft inequality with hard threshold \(\delta\).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textgreater{}"}}: similar with a strict inequality and semantics
\(max(0, y + 1 + cst - x \leq \delta ? y + 1 + cst - x : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}="}}: similar with an inverted inequality and semantics:
\(max(0, x - cst - y \leq \delta ? x - cst - y : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"\textless{}"}}: similar with a strict inequality and semantics
\(max(0, x - cst + 1 - y \leq \delta ? x - cst + 1 - y : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"="}}: similar with an equality and semantics: similar with a strict
inequality and semantics
\(\left| y + cst - x \right| \leq \delta ? \left|y + cst - x \right| : upperbound)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"disj"}}: takes a \sphinxcode{\sphinxupquote{parameters}} array \([ cstx, csty, w]\)
to express soft binary disjunctive cost function with semantics \(( (x \geq y + csty) \lor ( y \geq x + cstx)) ? 0 : w)\)

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sdisj"}}: takes a \sphinxcode{\sphinxupquote{parameters}} array \([ cstx, csty, xmax, ymax wx wy]\) to express a special disjunctive cost function with three implicit constraints \(x \leq xmax\), \(y \leq ymax\) and \(( x < xmax \land y < ymax) \Rightarrow ( x \geq y + csty \lor  y \geq x + cstx)\) and an additional cost function \(( (x = xmax) ? wx : 0) + ( (y = y max? wy : 0)\).

\end{itemize}

\sphinxAtStartPar
example : arithmetic function with \sphinxcode{\sphinxupquote{\textgreater{}=}} operator :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{arith0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v6}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZgt{}=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
           \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Global cost functions:}

\sphinxAtStartPar
We use an informal syntactical description of each global cost function below. the \sphinxcode{\sphinxupquote{"|"}} is used for alternative keywords and parentheses together with \sphinxcode{\sphinxupquote{?}}, \sphinxcode{\sphinxupquote{*}} and \sphinxcode{\sphinxupquote{+}} to denote optional or repeated groups of items (+ requires that at least one repetition exists). For more details on
semantics and implementation, see:
\begin{quote}

\sphinxAtStartPar
1. Lee, J. H. M., \& Leung, K. L. (2012). Consistency techniques for flow\sphinxhyphen{}based projection\sphinxhyphen{}safe global cost functions in weighted constraint satisfaction. \sphinxstyleemphasis{Journal of Artificial Intelligence Research}, 43, 257\sphinxhyphen{}292.
\sphinxstyleemphasis{Artificial Intelligence}, 238, 166\sphinxhyphen{}189. 2. Allouche, D., Bessiere, C., Boizumault, P., De Givry, S., Gutierrez, P., Lee, J. H., … \& Wu, Y. (2016). Tractability\sphinxhyphen{}preserving transformations of global cost functions. \sphinxstyleemphasis{Artificial Intelligence}, 238, 166\sphinxhyphen{}189.
\end{quote}

\sphinxAtStartPar
Using a flow\sphinxhyphen{}based propagator:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{salldiff"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"dec"|"decbi" cost: cost{]}}} expresses a soft alldifferent with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{dec}} and \sphinxcode{\sphinxupquote{decbi}} keywords) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation (\sphinxcode{\sphinxupquote{decbi}} decomposes into a complete binary cost function network).
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{f1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scope}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v1}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v3}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{v4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{,}
       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{type}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{salldiff}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
       \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{params}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{metric}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{var}\PYG{l+s+s2}{\PYGZdq{}} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cost}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mf}{0.7}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
generates a cost of 0.7 per variable assignment that needs to be
changed for all variables to take a different value.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgcc"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric:"var"|"dec"|"wdec" cost: cost bounds: {[}{[}value lower\_bound upper\_bound (shortage\_weight excess\_weight)?{]}*{]}}} expresses a soft global cardinality constraint with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{dec}} keyword) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation and for each value its \sphinxcode{\sphinxupquote{lower}} and \sphinxcode{\sphinxupquote{upper}} bound (\sphinxcode{\sphinxupquote{value shortage}} and \sphinxcode{\sphinxupquote{excess weights}} penalties must be given iff \sphinxcode{\sphinxupquote{wdec}} is used).
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{sgcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{wdec}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.5}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.2}\PYG{p}{]}
                   \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{l+m+mi}{4} \PYG{l+m+mf}{0.2} \PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"ssame"}} with parameters array \sphinxcode{\sphinxupquote{{[}cost: cost vars1: {[}(variable)*{]} vars2: {[}(variable)*{]}{]}}} to express a permutation constraint on two lists of variables of equal size with implicit variable\sphinxhyphen{}based cost semantic
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{ssame}
       \PYG{n}{params} \PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{6.2}
          \PYG{n}{vars1} \PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2}\PYG{p}{]}
          \PYG{n}{vars2} \PYG{p}{:} \PYG{p}{[}\PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sregular"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"edit" cost: cost starts: {[}(state)*{]} ends: {[}(state)*{]} transitions: {[}(start\sphinxhyphen{}state symbol\_value end\_state)*{]}}} to express a soft regular constraint with either variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) or edit distance\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{edit}} keyword) cost semantics with a given \sphinxcode{\sphinxupquote{cost}} per violation followed by the definition of a deterministic finite automaton with arrays of initial and final states, and an array of state transitions where symbols are domain values indices.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{sregular}
       \PYG{n}{params} \PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n}{nb\PYGZus{}states}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{starts}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{n}{ends}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}
          \PYG{n}{transitions}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Global cost functions using a dynamic programming DAG\sphinxhyphen{}based propagator:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sregulardp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost nb\_states: nb\_states starts: {[}(state)*{]} ends: {[}(state)*{]} transitions: {[}(start\_state value\_index end\_state)*{]}}} to express a soft regular constraint with a variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{var}} keyword) cost semantic with a given \sphinxcode{\sphinxupquote{cost}} per violation followed by the definition of a deterministic finite automaton with arrays of initial and final states, and an array of state transitions where symbols are domain value indices.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example: see sregular above.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgrammar"|"sgrammardp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var"|"weight" cost: cost nb\_symbols: nb\_symbols nb\_values: nb\_values start: start\_symbol terminals: {[}(terminal\_symbol value (cost)?)*{]} non\_terminals: {[}(nonterminal\_in nonterminal\_out\_left nonterminal\_out\_right (cost)?)*{]}}} to express a soft/weighted grammar in Chomsky normal form. The costs inside the rules and terminals should be used only with the \sphinxcode{\sphinxupquote{weight}} metric.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{sgrammardp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric} \PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{1.012}
          \PYG{n}{nb\PYGZus{}symbols} \PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{n}{nb\PYGZus{}values} \PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{start} \PYG{p}{:} \PYG{l+m+mi}{0}
          \PYG{n}{terminals} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{non\PYGZus{}terminals} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"samong"|"samongdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost min: lower\_bound max: upper\_bound values: {[}(value)*{]}{]}}} to express a soft among constraint to restrict the number of variables taking their value into a given set of value indices
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{samong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric} \PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost} \PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{2}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"salldiffdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: cost{]}}} to express a soft alldifferent constraint with variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{"var"}} keyword) cost semantic with a given cost per violation (decomposes into \sphinxcode{\sphinxupquote{samongdp}} cost functions)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{salldiffdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.7}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"sgccdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}metric: "var" cost: "cost" bounds: {[}(value lower\_bound upper\_bound)*{]}{]}}} to express a soft global cardinality constraint with variable\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{"var"}} keyword) cost semantic with a given cost per violation and for each value its lower and upper bound (decomposes into \sphinxcode{\sphinxupquote{samongdp}} cost functions)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{sgccdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{var}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.1}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"max|smaxdp"}} with parameters array \sphinxcode{\sphinxupquote{{[}defaultcost: defcost tuples: {[}(variable value cost)*{]}{]}}} to express a weighted max cost function to find the maximum cost over a set of unary cost functions associated to a set of variables (by default, \sphinxcode{\sphinxupquote{defCost}} if unspecified)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{smaxdp}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{defaultcost}\PYG{p}{:} \PYG{l+m+mi}{3}
          \PYG{n}{tuples}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{4}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{3} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"MST"|"smstdp"}} with empty parameters expresses a hard spanning tree constraint where each variable is assigned to its parent variable index in order to build a spanning tree (the root being assigned to itself)
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
        \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{MST} \PYG{n}{params}\PYG{p}{:} \PYG{p}{[}\PYG{p}{]}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Global cost functions using a cost function network\sphinxhyphen{}based propagator (decompose to bounded arity table cost functions):
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wregular"}} with parameters \sphinxcode{\sphinxupquote{nb\_states: nbstates starts: {[}{[}state cost{]}*{]} ends: {[}{[}state cost{]}*{]} transitions: {[}{[}state value\_index state cost{]}*{]}}} to express a weighted regular constraint with weights on initial states, final states, and transitions, followed by the definition of a deterministic finite automaton with number of states, list of initial and final states with their costs, and list of weighted state transitions where symbols are domain value indices
\begin{itemize}
\item {} 
\sphinxAtStartPar
example :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v4} \PYG{n}{v3}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wregular}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{nb\PYGZus{}states}\PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{n}{starts} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{ends} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mf}{0.0}\PYG{p}{]}\PYG{p}{]}
          \PYG{n}{transitions} \PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mf}{0.0}\PYG{p}{]}
                         \PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{2} \PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{1} \PYG{l+m+mi}{3} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
       \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"walldiff"}} with parameters array \sphinxcode{\sphinxupquote{{[}hard|lin|quad{]}}} cost to express a soft alldifferent constraint as a set of wamong hard constraint (\sphinxcode{\sphinxupquote{hard}} keyword) or decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{lin}} and \sphinxcode{\sphinxupquote{quad}} keywords) cost semantic with a given cost per violation.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{walldiff}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{0.8}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wgcc"}} with parameters metric: \sphinxcode{\sphinxupquote{hard|lin|quad cost: cost bounds: {[}{[}value lower\_bound upper\_bound{]}*{]}}} to express a soft global cardinality constraint as either a hard constraint (\sphinxcode{\sphinxupquote{hard}} keyword) or with decomposition\sphinxhyphen{}based (\sphinxcode{\sphinxupquote{lin}} and \sphinxcode{\sphinxupquote{quad}} keyword) cost semantic with a given cost per violation and for each value its lower and upper bound
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wgcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{2} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsame"}} with parameters a \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost}} to express a permutation constraint on two lists of variables of equal size (implicitly concatenated in the scope) using implicit decomposition\sphinxhyphen{}based cost semantic
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}} \PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
        \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wsame}
        \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
           \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
           \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
           \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsamegcc"}} with parameters array \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost bounds: {[}{[}value lower\_bound upper\_bound{]}*{]}}} to express the combination of a soft global cardinality constraint and a permutation constraint.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wsamegcc}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{3.3}
          \PYG{n}{bounds}\PYG{p}{:} \PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3} \PYG{l+m+mi}{0} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wamong"}} with parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost values: {[}(value)*{]} min: lower\_bound max: upper\_bound}} to express a soft among constraint to restrict the number of variables taking their value into a given set of values.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wamong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{lin}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
          \PYG{n+nb}{min}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{n+nb}{max}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wvaramong"}} with parameters array \sphinxcode{\sphinxupquote{metric: hard cost: cost values: {[}(value)*{]}}} to express a hard among constraint to restrict the number of variables taking their value into a given set of values to be equal to the last variable in the scope.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4} \PYG{n}{v5}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wvaramong}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{12.0}
          \PYG{n}{values}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"woverlap"}} with parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost comparator: comparator to: righthandside{]}}} overlaps between two sequences of variables X, Y (i.e. set the fact that Xi and Yi take the same value (not equal to zero))
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{woverlap}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{2.01}\PYG{n}{comparator}\PYG{p}{:} \PYG{o}{\PYGZgt{}}
          \PYG{n}{to}\PYG{p}{:} \PYG{l+m+mi}{1}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wsum"}} parameters \sphinxcode{\sphinxupquote{metric: hard|lin|quad cost: cost comparator: comparator to: righthandside}} to express a soft sum constraint with unit coefficients to test if the sum of a set of variables matches with a given comparator and right\sphinxhyphen{}hand\sphinxhyphen{}side value.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{name}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
       \PYG{n+nb}{type}\PYG{p}{:} \PYG{n}{wsum}
       \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
          \PYG{n}{metric}\PYG{p}{:} \PYG{n}{quad}
          \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mf}{1.0}
          \PYG{n}{comparator}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}=}\PYG{l+s+s2}{\PYGZdq{}}
          \PYG{n}{to}\PYG{p}{:} \PYG{l+m+mi}{4}
          \PYG{p}{\PYGZcb{}}
      \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"wvarsum"}} with parameters \sphinxcode{\sphinxupquote{metric: hard cost: cost comparator: comparator}} to express a hard sum constraint to restrict the sum to be comparator to the value of the last variable in the scope.
\begin{itemize}
\item {} 
\sphinxAtStartPar
example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mywsum}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{n}{scope}\PYG{p}{:} \PYG{p}{[}\PYG{n}{v1} \PYG{n}{v2} \PYG{n}{v3} \PYG{n}{v4}\PYG{p}{]}
         \PYG{n+nb}{type} \PYG{p}{:} \PYG{n}{wvarsum}
         \PYG{n}{params}\PYG{p}{:} \PYG{p}{\PYGZob{}}
            \PYG{n}{metric}\PYG{p}{:} \PYG{n}{hard}
            \PYG{n}{cost}\PYG{p}{:} \PYG{l+m+mi}{3}
            \PYG{n}{comparator}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{==}\PYG{l+s+s2}{\PYGZdq{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\end{itemize}

\sphinxAtStartPar
Comparators: let us note \textless{}\textgreater{} the comparator, K the right\sphinxhyphen{}hand\sphinxhyphen{}side (to:) value associated to the comparator, and Sum the result of the sum over the variables. For each comparator, the gap is defined according to the distance as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is == : gap = abs(K \sphinxhyphen{} Sum)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{}= : gap = max(0,Sum \sphinxhyphen{} K)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textless{} : gap = max(0,Sum \sphinxhyphen{} K \sphinxhyphen{} 1)

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is != : gap = 1 if Sum != K and gap = 0 otherwise

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{} : gap = max(0,K \sphinxhyphen{} Sum + 1);

\item {} 
\sphinxAtStartPar
if \textless{}\textgreater{} is \textgreater{}= : gap = max(0,K \sphinxhyphen{} Sum);

\end{itemize}

\end{itemize}

\sphinxAtStartPar
Warning: the decomposition of \sphinxcode{\sphinxupquote{wsum}} and \sphinxcode{\sphinxupquote{wvarsum}} may use an exponential size (sum of domain sizes). list\_size1 and list\_size2 must be equal in \sphinxcode{\sphinxupquote{ssame}}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}