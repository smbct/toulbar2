%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage[english]{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{Python Library of toulbar2}
\date{Nov 30, 2022}
\release{1.0.0}
\author{INRAE}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{ref/ref_python::doc}}


\sphinxAtStartPar
pytoulbar2 software is the Python interface of toulbar2.
\index{CFN (class in pytoulbar2)@\spxentry{CFN}\spxextra{class in pytoulbar2}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{pytoulbar2.}}\sphinxbfcode{\sphinxupquote{CFN}}}{\emph{\DUrole{n}{ubinit}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{resolution}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{vac}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{configuration}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{vns}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{seed}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{verbose}\DUrole{o}{=}\DUrole{default_value}{\sphinxhyphen{}1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
pytoulbar2 base class used to manipulate and solve a cost function network.
\begin{description}
\sphinxlineitem{Constructor Args:}
\sphinxAtStartPar
ubinit (decimal cost or None): initial upper bound.
resolution (int): decimal precision of costs.
vac (int): if non zero, maximum solver depth minus one where virtual arc consistency algorithm is applied (1: VAC only in preprocessing).
configuration (bool): if True then special settings for preference learning using incremental solving (see car configuration tutorial).
vns (int or None): if None then solves using branch\sphinxhyphen{}and\sphinxhyphen{}bound methods else using variable neighborhood search heuristic
\begin{quote}
\begin{description}
\sphinxlineitem{(\sphinxhyphen{}1: initial solution at random, \sphinxhyphen{}2: minimum domain values, \sphinxhyphen{}3: maximum domain values,}
\sphinxAtStartPar
\sphinxhyphen{}4: first solution found by DFS, \textgreater{}=0: or by LDS with at most vns discrepancies).

\end{description}
\end{quote}

\sphinxAtStartPar
seed (int): random seed.
verbose (int): verbosity control (\sphinxhyphen{}1: no message, 0: search statistics, 1: search tree, 2\sphinxhyphen{}7: propagation information).

\sphinxlineitem{Members:}
\sphinxAtStartPar
CFN (WeightedCSPSolver): python interface to C++ class WeightedCSPSolver.

\sphinxAtStartPar
Contradiction (exception): python exception corresponding to the same C++ class.

\sphinxAtStartPar
Limit (exception|None): contains the last SolverOut exception or None if no exception occurs when solving with SolveNext.

\sphinxAtStartPar
Option (TouBar2): python interface to C++ class ToulBar2.

\sphinxAtStartPar
SolverOut (exception): python exception corresponding to the same C++ class.

\sphinxAtStartPar
Top (decimal cost): maximum decimal cost (it can be used to represent a forbidden cost).

\sphinxAtStartPar
VariableIndices (dict): associative array returning the variable name (str) associated to a given index (int).

\sphinxAtStartPar
VariableNames (list): array of created variable names (str) sorted by their index number.

\end{description}

\sphinxAtStartPar
See pytoulbar2test.py example in src repository.
\index{AddAllDifferent() (pytoulbar2.CFN method)@\spxentry{AddAllDifferent()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddAllDifferent}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddAllDifferent}}}{\emph{\DUrole{n}{scope}}, \emph{\DUrole{n}{encoding}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}binary\textquotesingle{}}}, \emph{\DUrole{n}{excepted}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{incremental}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Add AllDifferent hard global constraint.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scope}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} input variables of the function. A variable can be represented by its name (str) or its index (int).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{encoding}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} encoding used to represent AllDifferent (available choices are ‘binary’ or ‘salldiff’ or ‘salldiffdp’ or ‘salldiffkp’ or ‘walldiff’).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{excepted}} (\sphinxstyleliteralemphasis{\sphinxupquote{None}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of excepted domain values which can be taken by any variable without violating the constraint.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{incremental}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} if True then the constraint is backtrackable (i.e., it disappears when restoring at a lower depth, see Store/Restore).

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{AddCompactFunction() (pytoulbar2.CFN method)@\spxentry{AddCompactFunction()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddCompactFunction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddCompactFunction}}}{\emph{\DUrole{n}{scope}}, \emph{\DUrole{n}{defcost}}, \emph{\DUrole{n}{tuples}}, \emph{\DUrole{n}{tcosts}}, \emph{\DUrole{n}{incremental}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
AddCompactFunction creates a cost function in extension. The scope corresponds to the input variables of the function.
The costs are given by a list of assignments with the corresponding list of costs, all the other assignments taking the default cost.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scope}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} input variables of the function. A variable can be represented by its name (str) or its index (int).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{defcost}} (\sphinxstyleliteralemphasis{\sphinxupquote{decimal cost}}) \textendash{} default cost.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tuples}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} array of assignments (each assignment is a list of domain values, following the scope order).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tcosts}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} array of corresponding decimal costs (tcosts and tuples have the same size).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{incremental}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} if True then the function is backtrackable (i.e., it disappears when restoring at a lower depth, see Store/Restore).

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\sphinxAtStartPar
AddCompactFunction({[}‘x’,’y’,’z’{]},0,{[}{[}0,0,0{]},{[}1,1,1{]}{]},{[}1,\sphinxhyphen{}1{]}) encodes a ternary cost function with the null assignment having a cost of 1,
the identity assignment having a cost of \sphinxhyphen{}1, and all the other assignments a cost of 0.

\end{fulllineitems}

\index{AddFunction() (pytoulbar2.CFN method)@\spxentry{AddFunction()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddFunction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddFunction}}}{\emph{\DUrole{n}{scope}}, \emph{\DUrole{n}{costs}}, \emph{\DUrole{n}{incremental}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
AddFunction creates a cost function in extension. The scope corresponds to the input variables of the function.
The costs are given by a flat array the size of which corresponds to the product of initial domain sizes (see note in AddVariable).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scope}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} input variables of the function. A variable can be represented by its name (str) or its index (int).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{costs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} array of decimal costs for all possible assignments (iterating first over the domain values of the last variable in the scope).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{incremental}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} if True then the function is backtrackable (i.e., it disappears when restoring at a lower depth, see Store/Restore).

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\sphinxAtStartPar
AddFunction({[}‘x’,’y’{]}, {[}0,1,1,0{]}) encodes a binary cost function on Boolean variables x and y such that (x=0,y=0) has a cost of 0,
(x=0,y=1) has a cost of 1, (x=1,y=0) has a cost of 1, and (x=1,y=1) has a cost of 0.

\end{fulllineitems}

\index{AddGeneralizedLinearConstraint() (pytoulbar2.CFN method)@\spxentry{AddGeneralizedLinearConstraint()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddGeneralizedLinearConstraint}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddGeneralizedLinearConstraint}}}{\emph{\DUrole{n}{tuples}}, \emph{\DUrole{n}{operand}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}==\textquotesingle{}}}, \emph{\DUrole{n}{rightcoef}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
AddGeneralizedLinearConstraint creates a linear constraint with integer coefficients associated to domain values.
The scope implicitely corresponds to the variables involved in the tuples. Missing domain values have an implicit zero coefficient.
All constant terms must belong to the right part.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tuples}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} array of triplets (variable, domain value, coefficient) in the left part of the constraint.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{operand}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} can be either ‘==’ or ‘\textless{}=’ or ‘\textgreater{}=’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rightcoef}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} constant term in the right part.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\sphinxAtStartPar
AddGeneralizedLinearConstraint({[}(‘x’,1,1),(‘y’,1,1),(‘z’,0,2){]}, ‘==’, 1) encodes (x==1) + (y==1) + 2*(z==0) = 1 assuming 0/1 variables and (x==u) is equal to 1 if value u is assigned to x else equal to 0.

\end{fulllineitems}

\index{AddGlobalFunction() (pytoulbar2.CFN method)@\spxentry{AddGlobalFunction()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddGlobalFunction}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddGlobalFunction}}}{\emph{\DUrole{n}{scope}}, \emph{\DUrole{n}{gcname}}, \emph{\DUrole{o}{*}\DUrole{n}{parameters}}}{}
\pysigstopsignatures
\sphinxAtStartPar
AddGlobalFunction creates a soft global cost function.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scope}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} input variables of the function. A variable can be represented by its name (str) or its index (int).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gcname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} name of the global cost function (see toulbar2 user documentation).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of parameters (str or int) for this global cost function.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\sphinxAtStartPar
AddGlobalFunction({[}‘x1’,’x2’,’x3’,’x4’{]}, ‘wamong’, ‘hard’, 1000, 2, 1, 2, 1, 3) encodes a hard among constraint satisfied iff values \{1,2\} are assigned to the given variables at least once and at most 3 times, otherwise it returns a cost of 1000.

\end{fulllineitems}

\index{AddLinearConstraint() (pytoulbar2.CFN method)@\spxentry{AddLinearConstraint()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddLinearConstraint}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddLinearConstraint}}}{\emph{\DUrole{n}{coefs}}, \emph{\DUrole{n}{scope}}, \emph{\DUrole{n}{operand}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}==\textquotesingle{}}}, \emph{\DUrole{n}{rightcoef}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
AddLinearConstraint creates a linear constraint with integer coefficients.
The scope corresponds to the variables involved in the left part of the constraint.
All variables must belong to the left part (change their coefficient sign if they are originally in the right part).
All constant terms must belong to the rigt part.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coefs}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} array of integer coefficients associated to the left\sphinxhyphen{}part variables.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scope}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} variables involved in the left part of the constraint. A variable can be represented by its name (str) or its index (int).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{operand}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} can be either ‘==’ or ‘\textless{}=’ or ‘\textgreater{}=’.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rightcoef}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} constant term in the right part.

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Example}

\sphinxAtStartPar
AddLinearConstraint({[}1,1,\sphinxhyphen{}2{]}, {[}x,y,z{]}, ‘==’, \sphinxhyphen{}1) encodes x + y \sphinxhyphen{}2z = \sphinxhyphen{}1.

\end{fulllineitems}

\index{AddVariable() (pytoulbar2.CFN method)@\spxentry{AddVariable()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.AddVariable}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{AddVariable}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{values}}}{}
\pysigstopsignatures
\sphinxAtStartPar
AddVariable creates a new discrete variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} variable name.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{iterable}}) \textendash{} list of domain values represented by numerical (int) or symbolic (str) values.

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Index of the created variable in the problem (int).

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Symbolic values are implicitely associated to integer values (starting from zero) in the other functions.
In case of numerical values, the initial domain size is equal to max(values)\sphinxhyphen{}min(values)+1 and not equal to len(values).
Otherwise (symbolic case), the initial domain size is equal to len(values).
\end{sphinxadmonition}

\end{fulllineitems}

\index{Assign() (pytoulbar2.CFN method)@\spxentry{Assign()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Assign}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Assign}}}{\emph{\DUrole{n}{varIndex}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Assign assigns a variable to a domain value.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of the variable as returned by AddVariable.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} domain value.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{ClearPropagationQueues() (pytoulbar2.CFN method)@\spxentry{ClearPropagationQueues()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.ClearPropagationQueues}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ClearPropagationQueues}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
ClearPropagationQueues resets propagation queues. It should be called when an exception Contradiction occurs.

\end{fulllineitems}

\index{Deconnect() (pytoulbar2.CFN method)@\spxentry{Deconnect()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Deconnect}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Deconnect}}}{\emph{\DUrole{n}{varIndex}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Deconnect deconnects a variable from the rest of the problem and assigns it to its support value.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of the variable as returned by AddVariable.

\end{description}\end{quote}

\end{fulllineitems}

\index{Decrease() (pytoulbar2.CFN method)@\spxentry{Decrease()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Decrease}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Decrease}}}{\emph{\DUrole{n}{varIndex}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Decrease removes the last values strictly greater than a given value in the domain of a variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of the variable as returned by AddVariable.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} domain value.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Depth() (pytoulbar2.CFN method)@\spxentry{Depth()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Depth}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Depth}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Depth returns the current solver depth value.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Current solver depth value (int).

\end{description}\end{quote}

\end{fulllineitems}

\index{Domain() (pytoulbar2.CFN method)@\spxentry{Domain()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Domain}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Domain}}}{\emph{\DUrole{n}{varIndex}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Domain returns the current domain of a given variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of the variable as returned by AddVariable.

\sphinxlineitem{Returns}
\sphinxAtStartPar
List of domain values (list).

\end{description}\end{quote}

\end{fulllineitems}

\index{Dump() (pytoulbar2.CFN method)@\spxentry{Dump()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Dump}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Dump}}}{\emph{\DUrole{n}{filename}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Dump outputs the problem in a file (without doing any preprocessing).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} problem filename. The suffix must be ‘.wcsp’ or ‘.cfn’ to select in which format to save the problem.

\end{description}\end{quote}

\end{fulllineitems}

\index{GetLB() (pytoulbar2.CFN method)@\spxentry{GetLB()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetLB}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetLB}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetLB returns the current problem lower bound.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Current lower bound (decimal cost).

\end{description}\end{quote}

\end{fulllineitems}

\index{GetNbBacktracks() (pytoulbar2.CFN method)@\spxentry{GetNbBacktracks()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetNbBacktracks}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetNbBacktracks}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetNbBacktracks returns the number of backtracks done so far.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Current number of backtracks (int).

\end{description}\end{quote}

\end{fulllineitems}

\index{GetNbConstrs() (pytoulbar2.CFN method)@\spxentry{GetNbConstrs()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetNbConstrs}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetNbConstrs}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetNbConstrs returns the number of non\sphinxhyphen{}unary cost functions.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Number of non\sphinxhyphen{}unary cost functions (int).

\end{description}\end{quote}

\end{fulllineitems}

\index{GetNbNodes() (pytoulbar2.CFN method)@\spxentry{GetNbNodes()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetNbNodes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetNbNodes}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetNbNodes returns the number of search nodes explored so far.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Current number of search nodes (int).

\end{description}\end{quote}

\end{fulllineitems}

\index{GetNbVars() (pytoulbar2.CFN method)@\spxentry{GetNbVars()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetNbVars}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetNbVars}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetNbVars returns the number of variables.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Number of variables (int).

\end{description}\end{quote}

\end{fulllineitems}

\index{GetSolutions() (pytoulbar2.CFN method)@\spxentry{GetSolutions()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetSolutions}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetSolutions}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetSolutions returns all the solutions found so far with their associated costs.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
List of pairs (decimal cost, solution) where a solution is a list of domain values.

\end{description}\end{quote}

\end{fulllineitems}

\index{GetUB() (pytoulbar2.CFN method)@\spxentry{GetUB()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.GetUB}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{GetUB}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
GetUB returns the initial upper bound.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Current initial upper bound (decimal cost).

\end{description}\end{quote}

\end{fulllineitems}

\index{Increase() (pytoulbar2.CFN method)@\spxentry{Increase()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Increase}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Increase}}}{\emph{\DUrole{n}{varIndex}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Increase removes the first values strictly lower than a given value in the domain of a variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of the variable as returned by AddVariable.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} domain value.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{MultipleAssign() (pytoulbar2.CFN method)@\spxentry{MultipleAssign()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.MultipleAssign}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{MultipleAssign}}}{\emph{\DUrole{n}{varIndexes}}, \emph{\DUrole{n}{values}}}{}
\pysigstopsignatures
\sphinxAtStartPar
MultipleAssign assigns several variables at once.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndexes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of indexes of variables.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{values}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of domain values.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{MultipleDeconnect() (pytoulbar2.CFN method)@\spxentry{MultipleDeconnect()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.MultipleDeconnect}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{MultipleDeconnect}}}{\emph{\DUrole{n}{varIndexes}}}{}
\pysigstopsignatures
\sphinxAtStartPar
MultipleDeconnect deconnects a set of variables from the rest of the problem and assigns them to their support value.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndexes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of indexes of variables.

\end{description}\end{quote}

\end{fulllineitems}

\index{NoPreprocessing() (pytoulbar2.CFN method)@\spxentry{NoPreprocessing()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.NoPreprocessing}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{NoPreprocessing}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
NoPreprocessing deactivates most preprocessing methods.

\end{fulllineitems}

\index{Parse() (pytoulbar2.CFN method)@\spxentry{Parse()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Parse}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Parse}}}{\emph{\DUrole{n}{certificate}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Parse performs a list of elementary reduction operations on domains of variables.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{certificate}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} a string composed of a list of operations on domains, each operation in the form ‘,varIndex{[}=\#\textless{}\textgreater{}{]}value’
where varIndex (int) is the index of a variable as returned by AddVariable and value (int) is a domain value
(comma is mandatory even for the first operation, add no space).
Possible operations are: assign (‘=’), remove (‘\#’), decrease maximum value (‘\textless{}’), increase minimum value (‘\textgreater{}’).

\end{description}\end{quote}
\subsubsection*{Example}

\sphinxAtStartPar
Parse(‘(,0=1,1=1,2\#0)’): assigns the first and second variable to value 1 and remove value 0 from the third variable.

\end{fulllineitems}

\index{Read() (pytoulbar2.CFN method)@\spxentry{Read()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Read}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Read}}}{\emph{\DUrole{n}{filename}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Read reads the problem from a file.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} problem filename.

\end{description}\end{quote}

\end{fulllineitems}

\index{Remove() (pytoulbar2.CFN method)@\spxentry{Remove()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Remove}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Remove}}}{\emph{\DUrole{n}{varIndex}}, \emph{\DUrole{n}{value}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Remove removes a value from the domain of a variable.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{varIndex}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} index of the variable as returned by AddVariable.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{value}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} domain value.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Restore() (pytoulbar2.CFN method)@\spxentry{Restore()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Restore}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Restore}}}{\emph{\DUrole{n}{depth}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Restore retrieves the copy made at a given solver depth value.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{depth}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} solver depth value. It must be lower than the current solver depth.

\end{description}\end{quote}

\end{fulllineitems}

\index{SetUB() (pytoulbar2.CFN method)@\spxentry{SetUB()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.SetUB}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SetUB}}}{\emph{\DUrole{n}{cost}}}{}
\pysigstopsignatures
\sphinxAtStartPar
SetUB resets the initial upper bound to a given value. It should be done before modifying the problem.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{decimal cost}}) \textendash{} new initial upper bound.

\end{description}\end{quote}

\end{fulllineitems}

\index{Solve() (pytoulbar2.CFN method)@\spxentry{Solve()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Solve}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Solve}}}{\emph{\DUrole{n}{showSolutions}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{allSolutions}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{diversityBound}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{timeLimit}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Solve solves the problem (i.e., finds its optimum and proves optimality). It can also enumerate (diverse) solutions depending on the arguments.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{showSolutions}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} prints solution(s) found (0: show nothing, 1: domain values, 2: variable names with their assigned values,
3: variable and value names).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{allSolutions}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} if non\sphinxhyphen{}zero, enumerates all the solutions with a cost strictly better than the initial upper bound
until a given limit on the number of solutions is reached.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{diversityBound}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} if non\sphinxhyphen{}zero, finds a greedy sequence of diverse solutions where a solution in the list is optimal
such that it also has a Hamming\sphinxhyphen{}distance from the previously found solutions greater than a given bound.
The number of diverse solutions is bounded by the argument value of allSolutions.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timeLimit}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} CPU\sphinxhyphen{}time limit in seconds (or 0 if no time limit)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The best (or last if enumeration/diversity) solution found as a list of domain values, its associated cost, always strictly lower
than the initial upper bound, and the number of solutions found (returned type: tuple(list, decimal cost, int)).
or None if no solution has been found (the problem has no solution better than the initial upper bound or a search limit occurs).
See GetSolutions to retrieve of the solutions found so far.

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This operation cannot be called multiple times on the same CFN object (it may modify the problem or its upper bound).
\end{sphinxadmonition}

\end{fulllineitems}

\index{SolveFirst() (pytoulbar2.CFN method)@\spxentry{SolveFirst()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.SolveFirst}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SolveFirst}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
SolveFirst performs problem preprocessing before doing incremental solving.
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Initial upper bound (decimal cost), possibly improved by considering a worst\sphinxhyphen{}case situation
based on the sum of maximum finite cost per function plus one.
or None if the problem has no solution (a contradiction occurs during preprocessing).

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This operation must be done at solver depth 0 (see Depth).
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This operation cannot be called multiple times on the same CFN object.
\end{sphinxadmonition}

\end{fulllineitems}

\index{SolveNext() (pytoulbar2.CFN method)@\spxentry{SolveNext()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.SolveNext}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{SolveNext}}}{\emph{\DUrole{n}{showSolutions}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{timeLimit}\DUrole{o}{=}\DUrole{default_value}{0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
SolveNext solves the problem (i.e., finds its optimum and proves optimality).
It should be done after calling SolveFirst and modifying the problem if necessary.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{showSolutions}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} prints solution(s) found (0: show nothing, 1: domain values, 2: variable names with their assigned values,
3: variable and value names).

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timeLimit}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} CPU\sphinxhyphen{}time limit in seconds (or 0 if no time limit)

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
The best solution found as a list of domain values, its associated cost, always strictly lower
than the initial upper bound, and None (returned type: tuple(list, decimal cost, None)).
or None if no solution has been found (the problem has no solution better than the initial upper bound or a search limit occurs, see Limit).

\end{description}\end{quote}

\end{fulllineitems}

\index{Store() (pytoulbar2.CFN method)@\spxentry{Store()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.Store}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{Store}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Store makes a copy (incremental) of the current problem and increases the solver depth by one.

\end{fulllineitems}

\index{UpdateUB() (pytoulbar2.CFN method)@\spxentry{UpdateUB()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.UpdateUB}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{UpdateUB}}}{\emph{\DUrole{n}{cost}}}{}
\pysigstopsignatures
\sphinxAtStartPar
UpdateUB decreases the initial upper bound to a given value. Does nothing if this value is greater than the current upper bound.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cost}} (\sphinxstyleliteralemphasis{\sphinxupquote{decimal cost}}) \textendash{} new initial upper bound.

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This operation might generate a Contradiction if the new upper bound is lower than or equal to the problem lower bound.
\end{sphinxadmonition}

\end{fulllineitems}

\index{flatten() (pytoulbar2.CFN static method)@\spxentry{flatten()}\spxextra{pytoulbar2.CFN static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.flatten}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{flatten}}}{\emph{\DUrole{n}{S}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{initFromMultiCFN() (pytoulbar2.CFN method)@\spxentry{initFromMultiCFN()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.initFromMultiCFN}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{initFromMultiCFN}}}{\emph{\DUrole{n}{multicfn}}}{}
\pysigstopsignatures
\sphinxAtStartPar
initFromMultiCFN initialize the cfn from a multiCFN instance (linear combination of multiple CFN).
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{multicfn}} (\sphinxstyleliteralemphasis{\sphinxupquote{MultiCFN}}) \textendash{} the instance containing the CFNs.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
After beeing initialized, it is possible to add cost functions to the CFN but the upper bound may be inconsistent.
\end{sphinxadmonition}

\end{fulllineitems}

\index{setName() (pytoulbar2.CFN method)@\spxentry{setName()}\spxextra{pytoulbar2.CFN method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ref/ref_python:pytoulbar2.CFN.setName}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{setName}}}{\emph{\DUrole{n}{name}}}{}
\pysigstopsignatures
\sphinxAtStartPar
setName set the name of the CFN.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the new name of the CFN.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}




\renewcommand{\indexname}{Index}
\printindex
\end{document}